<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="kotlin 协程," />










<meta name="description" content="1. 协程基础1.1 第一个coroutine程序12345678fun main()&amp;#123;    GLobalScope.launch&amp;#123;        delay(1000L) //后台建一个全局协程        println(&amp;quot;world,&amp;quot;)    &amp;#125;    println(&amp;quot;hello,&amp;quot;)//主线程不会被delay阻塞">
<meta name="keywords" content="kotlin 协程">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin协程">
<meta property="og:url" content="http://hcyxy.tech/2019/01/18/kotlin协程/index.html">
<meta property="og:site_name" content="万水千山">
<meta property="og:description" content="1. 协程基础1.1 第一个coroutine程序12345678fun main()&amp;#123;    GLobalScope.launch&amp;#123;        delay(1000L) //后台建一个全局协程        println(&amp;quot;world,&amp;quot;)    &amp;#125;    println(&amp;quot;hello,&amp;quot;)//主线程不会被delay阻塞">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-03T02:00:22.448Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kotlin协程">
<meta name="twitter:description" content="1. 协程基础1.1 第一个coroutine程序12345678fun main()&amp;#123;    GLobalScope.launch&amp;#123;        delay(1000L) //后台建一个全局协程        println(&amp;quot;world,&amp;quot;)    &amp;#125;    println(&amp;quot;hello,&amp;quot;)//主线程不会被delay阻塞">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hcyxy.tech/2019/01/18/kotlin协程/"/>





  <title>kotlin协程 | 万水千山</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">万水千山</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">wechat:LEILE111 email:hcy_xy@qq.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/01/18/kotlin协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">kotlin协程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T22:18:36+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>	阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-协程基础"><a href="#1-协程基础" class="headerlink" title="1. 协程基础"></a>1. 协程基础</h4><h5 id="1-1-第一个coroutine程序"><a href="#1-1-第一个coroutine程序" class="headerlink" title="1.1 第一个coroutine程序"></a>1.1 第一个coroutine程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    GLobalScope.launch&#123;</span><br><span class="line">        delay(1000L) //后台建一个全局协程</span><br><span class="line">        println(&quot;world,&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)//主线程不会被delay阻塞</span><br><span class="line">    Thread.sleep(2000L)//阻塞主线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,</span><br><span class="line">world</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-将阻塞和非阻塞桥接起来"><a href="#1-2-将阻塞和非阻塞桥接起来" class="headerlink" title="1.2 将阻塞和非阻塞桥接起来"></a>1.2 将阻塞和非阻塞桥接起来</h5><p>上面一个示例将非阻塞方法(non-blocking)和阻塞方法Thread.sleep写在一个方法块中，很容易混淆哪一部分是阻塞，哪一部分不是阻塞。可以利用runblocking这种协程的builder使阻塞更加明确。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(vararg args: String) &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)//主线程立即执行</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        delay(2000L)//延迟2s，使jvm保持活跃</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果相同，但是这块代码只使用了非阻塞delay。主线程执行runBlocking，内部阻塞了协程，直到runblocking完成。<br>也可以使用更加符合语言习惯的写法，利用runBlocking包括主函数的执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt;&#123; //启动main协程</span><br><span class="line">    GLobalScope.launch&#123; //新建一个协程</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;) //主协程立即执行</span><br><span class="line">    delay(2000L) //延迟2s，使jvm保持活跃</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-3-等待一个job"><a href="#1-3-等待一个job" class="headerlink" title="1.3 等待一个job"></a>1.3 等待一个job</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch &#123; //新建一个协程</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)</span><br><span class="line">    job.join() //等到子协程完成 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-4-结构化并发"><a href="#1-4-结构化并发" class="headerlink" title="1.4 结构化并发"></a>1.4 结构化并发</h5><p>GlobalScope.launch是一个top-level协程，虽然是一个轻量级的，但是运行时仍然会消耗内存。如果创建太多，仍然会很消耗性能。<br>有一个更好的方法，就是在代码中结构化并发的代码。不在GlobalScope范围内新建协程，可以在一个明确范围内启动一个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; //CoroutineScope</span><br><span class="line">    launch &#123; //在runBlocking范围内新建一个协程</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-5-Scope-builder"><a href="#1-5-Scope-builder" class="headerlink" title="1.5 Scope builder"></a>1.5 Scope builder</h5><p>除了不同的builder已经提供的协程范围，我们自己定义coroutineScope也是可以的。创建一个新的携程范围，直到所有子协程执行完毕，它才会结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; // this CoroutineScope</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;first&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineScope &#123; //新建一个coroutine范围</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(500)</span><br><span class="line">            println(&quot;second&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(100)</span><br><span class="line">        println(&quot;third&quot;) //嵌套的执行完，这一行才会输出</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;over&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-6-抽取阻塞的代码块"><a href="#1-6-抽取阻塞的代码块" class="headerlink" title="1.6 抽取阻塞的代码块"></a>1.6 抽取阻塞的代码块</h5><p>我们可以将launch{}代码块放进独立的方法，当你使用这种方式时，需要在重构的方法前面加上suspend，这种方法可以在协程内部调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doWorld() &#123;</span><br><span class="line">    delay(1000L)</span><br><span class="line">    println(&quot;World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>coroutine是更加轻量的，一个线程可以轻而易举创建上百万协程。速度比线程更快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&#123;</span><br><span class="line">    repeat(100_000)&#123;</span><br><span class="line">        launch&#123;</span><br><span class="line">            delay(1000)</span><br><span class="line">            print(.)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-7-global-coroutines就像是守护线程"><a href="#1-7-global-coroutines就像是守护线程" class="headerlink" title="1.7 global coroutines就像是守护线程"></a>1.7 global coroutines就像是守护线程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 回退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-协程的取消和超时"><a href="#2-协程的取消和超时" class="headerlink" title="2. 协程的取消和超时"></a>2. 协程的取消和超时</h4><h5 id="2-1-取消协程的执行"><a href="#2-1-取消协程的执行" class="headerlink" title="2.1 取消协程的执行"></a>2.1 取消协程的执行</h5><p>在一个运行时间很长的应用中，在运行完后，需要将任务取消掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        repeat(1000) &#123;</span><br><span class="line">            println(&quot;sleep $it&quot;)</span><br><span class="line">            delay(500)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(2300)</span><br><span class="line">    job.cancel() //将任务取消</span><br><span class="line">    job.join() //等待任务完毕</span><br><span class="line">    println(&quot;quit now&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-协程的取消应该是协作式的"><a href="#2-2-协程的取消应该是协作式的" class="headerlink" title="2.2 协程的取消应该是协作式的"></a>2.2 协程的取消应该是协作式的</h5><p>协程的取消应该是协作式的。所有suspend方法都是可以取消的。如果一个还在工作的协程被取消，那么它是不会被取消的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    //任务开始</span><br><span class="line">    val startTime = System.currentTimeMillis()</span><br><span class="line">    val job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        var nextPrintTime = startTime</span><br><span class="line">        var i = 0</span><br><span class="line">        while (i &lt; 5) &#123; // 执行一个计算逻辑</span><br><span class="line">            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;)</span><br><span class="line">                nextPrintTime += 500L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 延迟一会</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() //等待任务完成</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3-内置的isActive判断协程执行状态"><a href="#2-3-内置的isActive判断协程执行状态" class="headerlink" title="2.3 内置的isActive判断协程执行状态"></a>2.3 内置的isActive判断协程执行状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val startTime = System.currentTimeMillis()</span><br><span class="line">    val job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        var nextPrintTime = startTime</span><br><span class="line">        var i = 0</span><br><span class="line">        while (isActive) &#123; // cancellable computation loop</span><br><span class="line">            // print a message twice a second</span><br><span class="line">            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;)</span><br><span class="line">                nextPrintTime += 500L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4-finally取消任务"><a href="#2-4-finally取消任务" class="headerlink" title="2.4 finally取消任务"></a>2.4 finally取消任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">                delay(500L)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;I&apos;m running finally&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-NonCancellable使任务变为不可取消"><a href="#2-5-NonCancellable使任务变为不可取消" class="headerlink" title="2.5 NonCancellable使任务变为不可取消"></a>2.5 NonCancellable使任务变为不可取消</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">                delay(500L)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(&quot;I&apos;m running finally&quot;)</span><br><span class="line">                delay(1000L)</span><br><span class="line">                println(&quot;And I&apos;ve just delayed for 1 sec because I&apos;m non-cancellable&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-6-超时"><a href="#2-6-超时" class="headerlink" title="2.6 超时"></a>2.6 超时</h5><p>给一个协程任务设置超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    withTimeout(1300L) &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会发现withTimeout会抛出timeoutCancellationException。我们可以使用try catch或者使用withTimeoutOrNull返回一个空值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val result = withTimeoutOrNull(1300L) &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;Done&quot; // will get cancelled before it produces this result</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Result is $result&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-编写suspend函数"><a href="#3-编写suspend函数" class="headerlink" title="3. 编写suspend函数"></a>3. 编写suspend函数</h4><h5 id="3-1-串行执行"><a href="#3-1-串行执行" class="headerlink" title="3.1 串行执行"></a>3.1 串行执行</h5><p>假设我们有两个suspend函数，需要两个协程按顺序执行。想要获得A函数和B函数的和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val time = measureTimeMillis&#123;</span><br><span class="line">        val sum1 = sum1()</span><br><span class="line">        val sum2 = sum2()</span><br><span class="line">        println(&quot;sum is $&#123;sum1+sum2&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;time cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun sum1():Int&#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 12</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum2():Int&#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-并发使用async"><a href="#2-2-并发使用async" class="headerlink" title="2.2 并发使用async"></a>2.2 并发使用async</h5><p>有些方法间是没有相关性的，想要更快的得到结果，可以使用async提高性能。async类似launch，也是一个轻量级的线程。不同点是launch返回一个job，async返回一个非阻塞的future。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val sum1 = async &#123; sum1() &#125;</span><br><span class="line">        val sum2 = async &#123; sum2() &#125;</span><br><span class="line">        println(&quot;sum is $&#123;sum1.await() + sum2.await()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;time cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum1(): Int &#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 12</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum2(): Int &#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3-延迟启动async"><a href="#2-3-延迟启动async" class="headerlink" title="2.3 延迟启动async"></a>2.3 延迟启动async</h5><p>可以设置async在调用start或async的时候，才执行async中的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        // some computation</span><br><span class="line">        one.start() // start the first one</span><br><span class="line">        two.start() // start the second one</span><br><span class="line">        println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here, too</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不调用start，和串行执行等价。</p>
<h5 id="2-4-异步执行的方法"><a href="#2-4-异步执行的方法" class="headerlink" title="2.4 异步执行的方法"></a>2.4 异步执行的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun somethingUsefulOneAsync() = GlobalScope.async &#123;</span><br><span class="line">    doSomethingUsefulOne()</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-用async结构化并发"><a href="#2-5-用async结构化并发" class="headerlink" title="2.5 用async结构化并发"></a>2.5 用async结构化并发</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        println(&quot;The answer is $&#123;concurrentSum()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br><span class="line">suspend fun concurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    val two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">     one.await() + two.await()</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here, too</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的方法和exception结合在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        failedConcurrentSum()</span><br><span class="line">    &#125; catch(e: ArithmeticException) &#123;</span><br><span class="line">        println(&quot;Computation failed with ArithmeticException&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">suspend fun failedConcurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            delay(Long.MAX_VALUE) // Emulates very long computation</span><br><span class="line">            42</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;First child was cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val two = async&lt;Int&gt; &#123;</span><br><span class="line">        println(&quot;Second child throws an exception&quot;)</span><br><span class="line">        throw ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-协程的上下文和调度器"><a href="#3-协程的上下文和调度器" class="headerlink" title="3. 协程的上下文和调度器"></a>3. 协程的上下文和调度器</h4><h5 id="3-1-调度器和线程"><a href="#3-1-调度器和线程" class="headerlink" title="3.1 调度器和线程"></a>3.1 调度器和线程</h5><p>协程上下文包括了协程调度器，其决定了用哪个线程去执行。协程调度器限制了了指定线程去执行，由某个线程、线程池或无限制。<br>所有的协程builder像launch、async都会接受一个CoroutineContext的参数，这个参数可以明确的指定这个调度器为这个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch &#123; // context of the parent, main runBlocking coroutine</span><br><span class="line">        println(&quot;main runBlocking      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread</span><br><span class="line">        println(&quot;Unconfined            : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; // will get dispatched to DefaultDispatcher</span><br><span class="line">        println(&quot;Default               : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) &#123; // will get its own new thread</span><br><span class="line">        println(&quot;newSingleThreadContext: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>launch{…}</strong> 这种无参使用，默认集成启动的CoroutineScope的上下文，或者main函数的runBlocking。</p>
<p><strong>Dispatcher.Unconfined</strong> 是一个特殊的调度器，也会出现在main线程中。</p>
<p>默认的调度器<strong>default</strong>，当协程以GlobalScope方式启时， 而且以Dispatchers.Default表示，用的是共享的后台线程池，因此<strong>launch(Dispatchers.Default){…}</strong>用的是和GlobalScope.launch{…}的方式。</p>
<h5 id="3-2-约束性和非约束的调度"><a href="#3-2-约束性和非约束的调度" class="headerlink" title="3.2 约束性和非约束的调度"></a>3.2 约束性和非约束的调度</h5><p>非约束性调度器适合不消耗CPU、也不会更新共享数据的协程，这种协程会指定给特定的线程。约束性调度器在遇到第一个暂停点(suspend)之前，执行的都是调用者线程。遇到suspend函数后，用的是suspend方法决定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread</span><br><span class="line">        println(&quot;Unconfined      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;Unconfined      : After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123; // context of the parent, main runBlocking coroutine</span><br><span class="line">        println(&quot;main runBlocking: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;main runBlocking: After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unconfined      : I&apos;m working in thread main [遇到delay前]</span><br><span class="line">main runBlocking: I&apos;m working in thread main</span><br><span class="line">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor [遇到delay后]</span><br><span class="line">main runBlocking: After delay in thread main</span><br></pre></td></tr></table></figure></p>
<h5 id="3-3-协程和线程的调试"><a href="#3-3-协程和线程的调试" class="headerlink" title="3.3 协程和线程的调试"></a>3.3 协程和线程的调试</h5><p>协程可以在一个线程中挂起，或者在另一线程中恢复。即使使用单线程调度程序，也很难确定协程何时、何地做了什么。<br>启动程序的时候加上：<strong>-Dkotlinx.coroutines.debug</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val a = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing a piece of the answer&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    val b = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing another piece of the answer&quot;)</span><br><span class="line">        7</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer is $&#123;a.await() * b.await()&#125;&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#2] I&apos;m computing a piece of the answer</span><br><span class="line">[main @coroutine#3] I&apos;m computing another piece of the answer</span><br><span class="line">[main @coroutine#1] The answer is 42</span><br></pre></td></tr></table></figure></p>
<p>可以看出日志会输出线程名称、协程名称。</p>
<h5 id="3-4-在线程间跳跃"><a href="#3-4-在线程间跳跃" class="headerlink" title="3.4 在线程间跳跃"></a>3.4 在线程间跳跃</h5><p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    newSingleThreadContext(&quot;Ctx1&quot;).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(&quot;Ctx2&quot;).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(&quot;Started in ctx1&quot;)</span><br><span class="line">                withContext(ctx2) &#123;</span><br><span class="line">                    log(&quot;Working in ctx2&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;Back to ctx1&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>展示了两种技术，一个是使用runBlocking给其指定上下文，另外一个就是使用withContext，改变一个协程的上下文，但是仍然在一个协程内。</p>
<h5 id="3-5-上下文中的job"><a href="#3-5-上下文中的job" class="headerlink" title="3.5 上下文中的job"></a>3.5 上下文中的job</h5><p>协程的job是上下文的一部分，协程可以使用coroutineContext。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    println(&quot;My job is $&#123;coroutineContext[Job]&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-6-协程的子协程"><a href="#3-6-协程的子协程" class="headerlink" title="3.6 协程的子协程"></a>3.6 协程的子协程</h5><p>当在另一个协程中的CoroutineScope中启动一个协程，它继承了其coroutineContext。当父协程取消，子协程也会被递归的取消。<br>当GlobalScope被用来启动一个协程，这种启动方式时独立启动,不被父协程影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    // launch a coroutine to process some kind of incoming request</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        // it spawns two other jobs, one with GlobalScope</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(&quot;job1: I run in GlobalScope and execute independently!&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job1: I am not affected by cancellation of the request&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        // and the other inherits the parent context</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            println(&quot;job2: I am a child of the request coroutine&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(500)</span><br><span class="line">    request.cancel() // cancel processing of the request</span><br><span class="line">    delay(1000) // delay a second to see what happens</span><br><span class="line">    println(&quot;main: Who has survived request cancellation?&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-7-父协程等待子协程"><a href="#3-7-父协程等待子协程" class="headerlink" title="3.7 父协程等待子协程"></a>3.7 父协程等待子协程</h5><p>父协程会等待所有子协程执行完毕，父协程不用显示的追踪子协程，也不用使用job.join，如果想要保证在job完成后执行某个逻辑，可以使用job.join。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // launch a coroutine to process some kind of incoming request</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        repeat(3) &#123; i -&gt; // launch a few children jobs</span><br><span class="line">            launch  &#123;</span><br><span class="line">                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;request: I&apos;m done and I don&apos;t explicitly join my children that are still active&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    request.join() // wait for completion of the request, including all its children</span><br><span class="line">    println(&quot;Now processing of the request is complete&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-8-协程的命名"><a href="#3-8-协程的命名" class="headerlink" title="3.8 协程的命名"></a>3.8 协程的命名</h5><p>为了方便协程的追踪，也可以给协程命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking(CoroutineName(&quot;main&quot;)) &#123;</span><br><span class="line">    log(&quot;Started main coroutine&quot;)</span><br><span class="line">    // run two background value computations</span><br><span class="line">    val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) &#123;</span><br><span class="line">        delay(500)</span><br><span class="line">        log(&quot;Computing v1&quot;)</span><br><span class="line">        252</span><br><span class="line">    &#125;</span><br><span class="line">    val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        log(&quot;Computing v2&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer for v1 / v2 = $&#123;v1.await() / v2.await()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-9-将上下文连起来"><a href="#3-9-将上下文连起来" class="headerlink" title="3.9 将上下文连起来"></a>3.9 将上下文连起来</h5><p>有时我们需要为协程的上线定义很多成分，我们可以使用+符号。例如我们用一个显示指定的调度器和一个显示指定的名启动一个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Default + CoroutineName(&quot;test&quot;)) &#123;</span><br><span class="line">        println(&quot;I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-10-显示job的取消"><a href="#3-10-显示job的取消" class="headerlink" title="3.10 显示job的取消"></a>3.10 显示job的取消</h5><p>将上下文、子协程、任务综合在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Activity : CoroutineScope &#123;</span><br><span class="line">    lateinit var job: Job</span><br><span class="line"></span><br><span class="line">    fun create() &#123;</span><br><span class="line">        job = Job()</span><br><span class="line">    &#125;</span><br><span class="line">    fun destroy() &#123;</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    // to be continued ...</span><br><span class="line"></span><br><span class="line">    // class Activity continues</span><br><span class="line">    override val coroutineContext: CoroutineContext</span><br><span class="line">        get() = Dispatchers.Default + job</span><br><span class="line">    // to be continued ...</span><br><span class="line">    // class Activity continues</span><br><span class="line">    fun doSomething() &#123;</span><br><span class="line">        // launch ten coroutines for a demo, each working for a different time</span><br><span class="line">        repeat(10) &#123; i -&gt;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // class Activity ends</span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val activity = Activity()</span><br><span class="line">    activity.create() // create an activity</span><br><span class="line">    activity.doSomething() // run test function</span><br><span class="line">    println(&quot;Launched coroutines&quot;)</span><br><span class="line">    delay(500L) // delay for half a second</span><br><span class="line">    println(&quot;Destroying activity!&quot;)</span><br><span class="line">    activity.destroy() // cancels all coroutines</span><br><span class="line">    delay(1000) // visually confirm that they don&apos;t work</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Launched coroutines</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Destroying activity!</span><br></pre></td></tr></table></figure></p>
<h5 id="3-11-Thread-local"><a href="#3-11-Thread-local" class="headerlink" title="3.11 Thread-local"></a>3.11 Thread-local</h5><p>多线程中有thread-local，但是对协程而言，并不和特定的线程绑定。<br>对于ThreadLocal，扩展方法asContextElement就是来解决这种问题的。它创建一个额外的上下文环境组件，每次协程切换上下文，将会恢复它的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val threadLocal = ThreadLocal&lt;String?&gt;() // declare thread-local variable</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    threadLocal.set(&quot;main&quot;)</span><br><span class="line">    println(&quot;Pre-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = &quot;launch&quot;)) &#123;</span><br><span class="line">       println(&quot;Launch start, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">        yield()</span><br><span class="line">        println(&quot;After yield, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    println(&quot;Post-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，使用Dispatchers.Default新启动了一个协程，因此它在一个线程池里不同的线程中工作。使用了threadLocal.asContextElement(value=”launch”)不管协程怎么切换线程，输出结果都是不变的。<br>其中有一个关键的限制：当threadlocal是发生突变，一个新的值并不会传播到协程调用者，因为上下文不能跟踪所有的threadLocal对象访问，并且更新的值将会在下一个暂停点丢失，使用withContext去更新协程中的threadLocal.</p>
<h4 id="4-处理异常与监控"><a href="#4-处理异常与监控" class="headerlink" title="4. 处理异常与监控"></a>4. 处理异常与监控</h4><h5 id="4-1-异常的继承"><a href="#4-1-异常的继承" class="headerlink" title="4.1 异常的继承"></a>4.1 异常的继承</h5><p>协程构建有两种风格，自动继承（launch actor）或者将其暴露给用户（async produce）。前者将异常视为未处理，类似java中Thread.uncaughtExceptionHandler，后者依赖用户执行报错，比如去消费、调用。通过await或者receive的方式。</p>
<h5 id="4-2-取消和异常"><a href="#4-2-取消和异常" class="headerlink" title="4.2 取消和异常"></a>4.2 取消和异常</h5><p>取消和异常严格绑定在一起的，协程中使用cancellationException处理cancellation。这些异常可以被handler忽略。可以通过catch块捕获。</p>
<h5 id="4-3-异常聚合"><a href="#4-3-异常聚合" class="headerlink" title="4.3 异常聚合"></a>4.3 异常聚合</h5><p>多个子协程都抛错，第一个异常将会被捕获。这样可能会导致丢失一些异常，例如一个协程在finally中抛异常，但是额外的异常被抑制了。</p>
<h5 id="4-4-监控"><a href="#4-4-监控" class="headerlink" title="4.4 监控"></a>4.4 监控</h5><p>取消是协程层次结构传播的双向关系，如果需要单向取消，该如何处理。<br>很好的示例是一个服务器进程，生成多个子作业，并且需要监视他们的执行、跟踪故障，并重新启动已经失败的子作业。</p>
<h5 id="4-5-监控范围"><a href="#4-5-监控范围" class="headerlink" title="4.5 监控范围"></a>4.5 监控范围</h5><p>对于作用域的并发，可以使用supervisorScope代替coroutineScope。只是单向传播取消，只有主进程失败，所有子协程才会被取消。</p>
<h4 id="5-channel"><a href="#5-channel" class="headerlink" title="5. channel"></a>5. channel</h4><p>deferred values（延迟值）提供了一种方便的方式在协程间传递单个的值。channels提供一种传输流的方法。</p>
<h5 id="5-1-channel基础概念"><a href="#5-1-channel基础概念" class="headerlink" title="5.1 channel基础概念"></a>5.1 channel基础概念</h5><p>channel和blockingQueue非常像，一个关键的不同点是：suspend -&gt; put，suspend receive -&gt; take</p>
<h5 id="5-2-channel的关闭和迭代"><a href="#5-2-channel的关闭和迭代" class="headerlink" title="5.2 channel的关闭和迭代"></a>5.2 channel的关闭和迭代</h5><p>和队列不同，通道的关闭表明没有更多的元素。receiver端，可以使用for循环从channel中取元素。<br>channel的关闭就像是给channel发送一个特殊的token，表示channel已经关闭了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;Int&gt;()</span><br><span class="line">    launch &#123;</span><br><span class="line">        for (x in 1..5) channel.send(x * x)</span><br><span class="line">        channel.close() // we&apos;re done sending</span><br><span class="line">    &#125;</span><br><span class="line">    // here we print received values using `for` loop (until the channel is closed)</span><br><span class="line">    for (y in channel) println(y)</span><br><span class="line">    println(&quot;Done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-3-build一个channel的producer"><a href="#5-3-build一个channel的producer" class="headerlink" title="5.3 build一个channel的producer"></a>5.3 build一个channel的producer</h5><p>并发场景中的生产/消费模式，下面就抽象出一个producer模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.produceSquares(): ReceiveChannel&lt;Int&gt; = produce &#123;</span><br><span class="line">    for (x in 1..5) send(x * x)</span><br><span class="line">&#125;</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val squares = produceSquares()</span><br><span class="line">    squares.consumeEach &#123; println(it) &#125;</span><br><span class="line">    println(&quot;Done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-4-pipelines"><a href="#5-4-pipelines" class="headerlink" title="5.4 pipelines"></a>5.4 pipelines</h5><p>pipeline是一种协程生产的模式，可能是无限的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val numbers = produceNumbers() // produces integers from 1 and on</span><br><span class="line">    val squares = square(numbers) // squares integers</span><br><span class="line">    for (i in 1..5) println(squares.receive()) // print first five</span><br><span class="line">    println(&quot;Done!&quot;) // we are done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; &#123;</span><br><span class="line">    var x = 1</span><br><span class="line">    while (true) send(x++) // infinite stream of integers starting from 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.square(numbers: ReceiveChannel&lt;Int&gt;): ReceiveChannel&lt;Int&gt; = produce &#123;</span><br><span class="line">    for (x in numbers) send(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如有一个流水线过滤器，对生产的数字进行一系列处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ...</span><br></pre></td></tr></table></figure></p>
<p>比如有一个过滤器的流水线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    var cur = numbersFrom(2)</span><br><span class="line">    for (i in 1..10) &#123;</span><br><span class="line">        val prime = cur.receive()</span><br><span class="line">        println(prime)</span><br><span class="line">        cur = filter(cur, prime)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel all children to let main finish</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.numbersFrom(start: Int) = produce &#123;</span><br><span class="line">    var x = start</span><br><span class="line">    while (true) send(x++) // infinite stream of integers from start</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.filter(numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce &#123;</span><br><span class="line">    for (x in numbers) if (x % prime != 0) send(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流水线也可以使用标准库中的buildIterator，yield代替send，next代替receive，Iterator代替ReceiveChannel，去掉coroutine scope，不需要使用runBlocking。</p>
<h5 id="5-5-fan-out-单生产-gt-多消费模式"><a href="#5-5-fan-out-单生产-gt-多消费模式" class="headerlink" title="5.5 fan-out 单生产-&gt;多消费模式"></a>5.5 fan-out 单生产-&gt;多消费模式</h5><p>代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val producer = produceNumbers()</span><br><span class="line">    repeat(5) &#123; launchProcessor(it, producer) &#125;</span><br><span class="line">    delay(950)</span><br><span class="line">    producer.cancel() // cancel producer coroutine and thus kill them all</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.produceNumbers() = produce &#123;</span><br><span class="line">    var x = 1 // start from 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        send(x++) // produce next</span><br><span class="line">        delay(100) // wait 0.1s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch &#123;</span><br><span class="line">    for (msg in channel) &#123;</span><br><span class="line">        println(&quot;Processor #$id received $msg&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种模式下不像<strong>consumeEach</strong>，这种for循环的使用完全是线程安全的。如果其中一个processor失败，其他的协程会继续处理。然而通过consumeEach编写的的处理器在正常、异常完成时总是消费底层channel。</p>
<h5 id="5-6-多生产-gt-单消费"><a href="#5-6-多生产-gt-单消费" class="headerlink" title="5.6 多生产-&gt;单消费"></a>5.6 多生产-&gt;单消费</h5><p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;String&gt;()</span><br><span class="line">    launch &#123; sendString(channel, &quot;foo&quot;, 200L) &#125;</span><br><span class="line">    launch &#123; sendString(channel, &quot;BAR!&quot;, 500L) &#125;</span><br><span class="line">    repeat(6) &#123; // receive first six</span><br><span class="line">        println(channel.receive())</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel all children to let main finish</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        delay(time)</span><br><span class="line">        channel.send(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-7-缓冲通道-buffered-channel"><a href="#5-7-缓冲通道-buffered-channel" class="headerlink" title="5.7 缓冲通道[buffered channel]"></a>5.7 缓冲通道[buffered channel]</h5><p>上面介绍的channel都没有缓冲区，发送方、接收方相遇时，未缓冲通道会传输元素。如果先调用send，则会挂起，直到receive执行；如果先调用receive，则其也会挂起，直到调用send。</p>
<p>channel facotry和producer都可以选择一个参数来指定缓冲区大小。缓冲区允许发送方挂起前发送多个元素，类似指定容量的BlockingQueue，缓冲区满的时候会被阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;Int&gt;(10) // create buffered channel</span><br><span class="line">    val sender = launch &#123; // launch sender coroutine</span><br><span class="line">        repeat(10) &#123;</span><br><span class="line">            println(&quot;Sending $it&quot;) // print before sending each element</span><br><span class="line">            channel.send(it) // will suspend when buffer is full</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // don&apos;t receive anything... just wait....</span><br><span class="line">    delay(1000)</span><br><span class="line">    sender.cancel() // cancel sender coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-8-channels是公平的"><a href="#5-8-channels是公平的" class="headerlink" title="5.8 channels是公平的"></a>5.8 channels是公平的</h5><p>对通道的send和receive操作对于多个协程调用顺序是公平的,以先进先出的顺序提供。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val table = Channel&lt;Ball&gt;() // a shared table</span><br><span class="line">    launch &#123; player(&quot;ping&quot;, table) &#125;</span><br><span class="line">    launch &#123; player(&quot;pong&quot;, table) &#125;</span><br><span class="line">    table.send(Ball(0)) // serve the ball</span><br><span class="line">    delay(1000) // delay 1 second</span><br><span class="line">    coroutineContext.cancelChildren() // game over, cancel them</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun player(name: String, table: Channel&lt;Ball&gt;) &#123;</span><br><span class="line">    for (ball in table) &#123; // receive the ball in a loop</span><br><span class="line">        ball.hits++</span><br><span class="line">        println(&quot;$name $ball&quot;)</span><br><span class="line">        delay(300) // wait a bit</span><br><span class="line">        table.send(ball) // send the ball back</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-9-ticker信道"><a href="#5-9-ticker信道" class="headerlink" title="5.9 ticker信道"></a>5.9 ticker信道</h5><p>ticker信道是一种特殊的集合信道，从上次从通道中消费后，在指定的延迟，会返回一个Unit。虽然这种方式看起来像一种无用的、独立的，但是它是创建复杂的基于时间的生产pipepiles和其他基于窗口和时间独立的处理进程。ticker channel</p>
<h4 id="6-共享可变状态和并发性"><a href="#6-共享可变状态和并发性" class="headerlink" title="6 共享可变状态和并发性"></a>6 共享可变状态和并发性</h4><p>协程也可以在多线程中运行，所以也会产生并发性问题。主要问题是访问共享可变状态的同步，在协程中，有些解决方案和多线程领域类似，但有些是独一无二。</p>
<h5 id="6-1-细粒度线程限制"><a href="#6-1-细粒度线程限制" class="headerlink" title="6.1 细粒度线程限制"></a>6.1 细粒度线程限制</h5><p>线程限制指接触到共享变量的地方都用一个线程访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val counterContext = newSingleThreadContext(&quot;CounterContext&quot;)</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.massiveRun &#123; // run each coroutine with DefaultDispathcer</span><br><span class="line">        withContext(counterContext) &#123; // but confine each increment to the single-threaded context</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码非常慢，因为其执行细粒度线程限制，每次做加法，都会从多线程调度器切换，默认使用withContext切换到单线程上下文。</p>
<h5 id="6-2-粗粒度线程限制"><a href="#6-2-粗粒度线程限制" class="headerlink" title="6.2 粗粒度线程限制"></a>6.2 粗粒度线程限制</h5><p>实际运用中，线程限制以大块执行的。比如，状态更新的业务逻辑被限制当个线程中。下面的示例就是这么做的，在单线程上下文运行每个协程，使用coroutineScope.相比上个例子，性能提升很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val counterContext = newSingleThreadContext(&quot;CounterContext&quot;)</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    CoroutineScope(counterContext).massiveRun &#123; // run each coroutine in the single-threaded context</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-3-使用互斥访问"><a href="#6-3-使用互斥访问" class="headerlink" title="6.3 使用互斥访问"></a>6.3 使用互斥访问</h5><p>互斥解决方案是保护共享状态的修改，关键部分不会并发执行。多线程中，通常会使用synchronized或reentrantlock，coroutine中另一个选择是mutex。具有加锁、解锁来执行关键部分。mutex.lock是一个挂起函数，不会阻塞线程。加锁的方式也是细粒度的。在某些场景中，你需要周期性修改共享变量，但是没有任何天然的线程限制这种状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line">val mutex = Mutex()</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.massiveRun &#123;</span><br><span class="line">        mutex.withLock &#123;</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-4-actor模型"><a href="#6-4-actor模型" class="headerlink" title="6.4 actor模型"></a>6.4 actor模型</h5><p>actor是一个实体，由一个协程、和被限制并封装在这个协程中的状态，也是一个channel，和其他协程通信。一个简单的actor，可以是一个函数，如果有更复杂的状态，一个类更适合。<br>一个actor协程builder，可以很方便的将actor的信箱组合到其作用域，用来接收消息，并将发送通道组合到生成的作业对象中，这样可以将对actor的单个引用作为句柄携带。<br>第一步是定义actor要处理的消息类。kotlin中sealed class非常适合这个场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Message types for counterActor</span><br><span class="line">sealed class CounterMsg</span><br><span class="line">object IncCounter : CounterMsg() // one-way message to increment counter</span><br><span class="line">class GetCounter(val response: CompletableDeferred&lt;Int&gt;) : CounterMsg() // a request with reply</span><br><span class="line"></span><br><span class="line">// This function launches a new counter actor</span><br><span class="line">fun CoroutineScope.counterActor() = actor&lt;CounterMsg&gt; &#123;</span><br><span class="line">    var counter = 0 // actor state</span><br><span class="line">    for (msg in channel) &#123; // iterate over incoming messages</span><br><span class="line">        when (msg) &#123;</span><br><span class="line">            is IncCounter -&gt; counter++</span><br><span class="line">            is GetCounter -&gt; msg.response.complete(counter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val counter = counterActor() // create the actor</span><br><span class="line">    GlobalScope.massiveRun &#123;</span><br><span class="line">        counter.send(IncCounter)</span><br><span class="line">    &#125;</span><br><span class="line">    // send a message to get a counter value from an actor</span><br><span class="line">    val response = CompletableDeferred&lt;Int&gt;()</span><br><span class="line">    counter.send(GetCounter(response))</span><br><span class="line">    println(&quot;Counter = $&#123;response.await()&#125;&quot;)</span><br><span class="line">    counter.close() // shutdown the actor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actor在什么上下文中执行并不重要，actor就是一个协程，按照顺序执行。因此将状态限制到指定的协程可以解决共享可变状态的问题。</p>
<h4 id="7-选择表达式"><a href="#7-选择表达式" class="headerlink" title="7. 选择表达式"></a>7. 选择表达式</h4><p>选择表达式可以同时等待多个挂起函数，并选择第一个可用的函数。<br>选择表达式是kotlinx.coroutines的一个实验特性。其中的API在接下来的版本中，可能会有比较大的改变。</p>
<h5 id="7-1-从channel中选择"><a href="#7-1-从channel中选择" class="headerlink" title="7.1 从channel中选择"></a>7.1 从channel中选择</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.fizz() = produce &#123;</span><br><span class="line">    while (true) &#123; // sends &quot;Fizz&quot; every 300 ms</span><br><span class="line">        delay(300)</span><br><span class="line">        send(&quot;Fizz&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.buzz() = produce &#123;</span><br><span class="line">    while (true) &#123; // sends &quot;Buzz!&quot; every 500 ms</span><br><span class="line">        delay(500)</span><br><span class="line">        send(&quot;Buzz!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">suspend fun selectFizzBuzz(fizz: ReceiveChannel&lt;String&gt;, buzz: ReceiveChannel&lt;String&gt;) &#123;</span><br><span class="line">    select&lt;Unit&gt; &#123; // &lt;Unit&gt; means that this select expression does not produce any result</span><br><span class="line">        fizz.onReceive &#123; value -&gt;  // this is the first select clause</span><br><span class="line">            println(&quot;fizz -&gt; &apos;$value&apos;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        buzz.onReceive &#123; value -&gt;  // this is the second select clause</span><br><span class="line">            println(&quot;buzz -&gt; &apos;$value&apos;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val fizz = fizz()</span><br><span class="line">    val buzz = buzz()</span><br><span class="line">    repeat(7) &#123;</span><br><span class="line">        selectFizzBuzz(fizz, buzz)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel fizz &amp; buzz coroutines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-2-通道关闭"><a href="#7-2-通道关闭" class="headerlink" title="7.2 通道关闭"></a>7.2 通道关闭</h5><p>当通道关闭时，select中onReceive会失败，导致相应select发生异常；当通道关闭时，可以使用onReceiveOrNull执行特定操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">suspend fun selectAorB(a: ReceiveChannel&lt;String&gt;, b: ReceiveChannel&lt;String&gt;): String =</span><br><span class="line">        select &#123;</span><br><span class="line">            a.onReceiveOrNull &#123; value -&gt;</span><br><span class="line">                if (value == null)</span><br><span class="line">                    &quot;Channel &apos;a&apos; is closed&quot;</span><br><span class="line">                else</span><br><span class="line">                    &quot;a -&gt; &apos;$value&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            b.onReceiveOrNull &#123; value -&gt;</span><br><span class="line">                if (value == null)</span><br><span class="line">                    &quot;Channel &apos;b&apos; is closed&quot;</span><br><span class="line">                else</span><br><span class="line">                    &quot;b -&gt; &apos;$value&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val a = produce &#123;</span><br><span class="line">        repeat(4) &#123; send(&quot;Hello $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val b = produce &#123;</span><br><span class="line">        repeat(4) &#123; send(&quot;World $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(8) &#123; // print first eight results</span><br><span class="line">        println(selectAorB(a, b))</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>select偏向于第一个子句，当多个子句可以选择时，其中第一个子句将会被选择。当channel关闭时，onReceiveOrNull会立马得到响应。</p>
<h5 id="7-3-选择发送"><a href="#7-3-选择发送" class="headerlink" title="7.3 选择发送"></a>7.3 选择发送</h5><p>select的onSend表达式，可以结合有偏向的特性使用。<br>下面的例子是，通道消费者无法跟上生成速度，会把值发送到一个侧通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.produceNumbers(side: SendChannel&lt;Int&gt;) = produce&lt;Int&gt; &#123;</span><br><span class="line">    for (num in 1..10) &#123; // produce 10 numbers from 1 to 10</span><br><span class="line">        delay(100) // every 100 ms</span><br><span class="line">        select&lt;Unit&gt; &#123;</span><br><span class="line">            onSend(num) &#123;&#125; // Send to the primary channel</span><br><span class="line">            side.onSend(num) &#123;&#125; // or to the side channel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val side = Channel&lt;Int&gt;() // allocate side channel</span><br><span class="line">    launch &#123; // this is a very fast consumer for the side channel</span><br><span class="line">        side.consumeEach &#123; println(&quot;Side channel has $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    produceNumbers(side).consumeEach &#123;</span><br><span class="line">        println(&quot;Consuming $it&quot;)</span><br><span class="line">        delay(250) // let us digest the consumed number properly, do not hurry</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Done consuming&quot;)</span><br><span class="line">    coroutineContext.cancelChildren()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-4-选择延迟的值（deferred-value）"><a href="#7-4-选择延迟的值（deferred-value）" class="headerlink" title="7.4 选择延迟的值（deferred value）"></a>7.4 选择延迟的值（deferred value）</h5><p>延迟的值可以使用onAwait接收到。以下例子说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.asyncString(time: Int) = async &#123;</span><br><span class="line">    delay(time.toLong())</span><br><span class="line">    &quot;Waited for $time ms&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.asyncStringsList(): List&lt;Deferred&lt;String&gt;&gt; &#123;</span><br><span class="line">    val random = Random(3)</span><br><span class="line">    return List(12) &#123; asyncString(random.nextInt(1000)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val list = asyncStringsList()</span><br><span class="line">    val result = select&lt;String&gt; &#123;</span><br><span class="line">        list.withIndex().forEach &#123; (index, deferred) -&gt;</span><br><span class="line">            deferred.onAwait &#123; answer -&gt;</span><br><span class="line">                &quot;Deferred $index produced answer &apos;$answer&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">    val countActive = list.count &#123; it.isActive &#125;</span><br><span class="line">    println(&quot;$countActive coroutines are still active&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数等待第一个函数完成，并计算仍处于活跃状态的延迟值的数量。select是kotlin的一个kotlin dsl表达式，可以使用任意代码为其提供子句，这种情况下，迭代一个延迟值列表，为每个延迟值提供onWait子句。</p>
<h5 id="7-5-切换延迟值的通道"><a href="#7-5-切换延迟值的通道" class="headerlink" title="7.5 切换延迟值的通道"></a>7.5 切换延迟值的通道</h5><p>例子是producer会消费通道中的延迟值，等待每个接收到的延迟值，直到下一个值到来，或者通道关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@ExperimentalCoroutinesApi</span><br><span class="line">fun CoroutineScope.switchMapDeferreds(input: ReceiveChannel&lt;Deferred&lt;String&gt;&gt;) = produce &#123;</span><br><span class="line">    var current = input.receive() // start with first received deferred value</span><br><span class="line">    while (isActive) &#123; // loop while not cancelled/closed</span><br><span class="line">        val next = select&lt;Deferred&lt;String&gt;?&gt; &#123; // return next deferred value from this select or null</span><br><span class="line">            input.onReceiveOrNull &#123; update -&gt;</span><br><span class="line">                update // replaces next value to wait</span><br><span class="line">            &#125;</span><br><span class="line">            current.onAwait &#123; value -&gt;</span><br><span class="line">                send(value) // send value that current deferred has produced</span><br><span class="line">                input.receiveOrNull() // and use the next deferred from the input channel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            println(&quot;Channel was closed&quot;)</span><br><span class="line">            break // out of loop</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current = next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.asyncString(str: String, time: Long) = async &#123;</span><br><span class="line">    delay(time)</span><br><span class="line">    str</span><br><span class="line">&#125;</span><br><span class="line">@ExperimentalCoroutinesApi</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val chan = Channel&lt;Deferred&lt;String&gt;&gt;() // the channel for test</span><br><span class="line">    launch &#123; // launch printing coroutine</span><br><span class="line">        for (s in switchMapDeferreds(chan))</span><br><span class="line">            println(s) // print each received string</span><br><span class="line">    &#125;</span><br><span class="line">    chan.send(asyncString(&quot;BEGIN&quot;, 100))</span><br><span class="line">    delay(200) // enough time for &quot;BEGIN&quot; to be produced</span><br><span class="line">    chan.send(asyncString(&quot;Slow&quot;, 500))</span><br><span class="line">    delay(100) // not enough time to produce slow</span><br><span class="line">    chan.send(asyncString(&quot;Replace&quot;, 100))</span><br><span class="line">    delay(500) // give it time before the last one</span><br><span class="line">    chan.send(asyncString(&quot;END&quot;, 500))</span><br><span class="line">    delay(1000) // give it time to process</span><br><span class="line">    chan.close() // close the channel ...</span><br><span class="line">    delay(500) // and wait some time to let it finish</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kotlin-协程/" rel="tag"># kotlin 协程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/29/gradle使用/" rel="next" title="gradle使用">
                <i class="fa fa-chevron-left"></i> gradle使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/22/数据密集型应用/" rel="prev" title="数据密集型应用">
                数据密集型应用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hecy</p>
              <p class="site-description motion-element" itemprop="description">dreamer</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hecyxy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hcy_xy@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-gmail"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-协程基础"><span class="nav-number">1.</span> <span class="nav-text">1. 协程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-第一个coroutine程序"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 第一个coroutine程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-将阻塞和非阻塞桥接起来"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 将阻塞和非阻塞桥接起来</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-等待一个job"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 等待一个job</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-结构化并发"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 结构化并发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-Scope-builder"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 Scope builder</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-抽取阻塞的代码块"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 抽取阻塞的代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-global-coroutines就像是守护线程"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 global coroutines就像是守护线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-协程的取消和超时"><span class="nav-number">2.</span> <span class="nav-text">2. 协程的取消和超时</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-取消协程的执行"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 取消协程的执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-协程的取消应该是协作式的"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 协程的取消应该是协作式的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-内置的isActive判断协程执行状态"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 内置的isActive判断协程执行状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-finally取消任务"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 finally取消任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-NonCancellable使任务变为不可取消"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 NonCancellable使任务变为不可取消</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-超时"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 超时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-编写suspend函数"><span class="nav-number">3.</span> <span class="nav-text">3. 编写suspend函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-串行执行"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 串行执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-并发使用async"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 并发使用async</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-延迟启动async"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 延迟启动async</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-异步执行的方法"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 异步执行的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-用async结构化并发"><span class="nav-number">3.5.</span> <span class="nav-text">2.5 用async结构化并发</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-协程的上下文和调度器"><span class="nav-number">4.</span> <span class="nav-text">3. 协程的上下文和调度器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-调度器和线程"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 调度器和线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-约束性和非约束的调度"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 约束性和非约束的调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-协程和线程的调试"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 协程和线程的调试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-在线程间跳跃"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 在线程间跳跃</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-上下文中的job"><span class="nav-number">4.5.</span> <span class="nav-text">3.5 上下文中的job</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-协程的子协程"><span class="nav-number">4.6.</span> <span class="nav-text">3.6 协程的子协程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-父协程等待子协程"><span class="nav-number">4.7.</span> <span class="nav-text">3.7 父协程等待子协程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-协程的命名"><span class="nav-number">4.8.</span> <span class="nav-text">3.8 协程的命名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-9-将上下文连起来"><span class="nav-number">4.9.</span> <span class="nav-text">3.9 将上下文连起来</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-10-显示job的取消"><span class="nav-number">4.10.</span> <span class="nav-text">3.10 显示job的取消</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-11-Thread-local"><span class="nav-number">4.11.</span> <span class="nav-text">3.11 Thread-local</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-处理异常与监控"><span class="nav-number">5.</span> <span class="nav-text">4. 处理异常与监控</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-异常的继承"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 异常的继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-取消和异常"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 取消和异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-异常聚合"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 异常聚合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-监控"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 监控</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-监控范围"><span class="nav-number">5.5.</span> <span class="nav-text">4.5 监控范围</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-channel"><span class="nav-number">6.</span> <span class="nav-text">5. channel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-channel基础概念"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 channel基础概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-channel的关闭和迭代"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 channel的关闭和迭代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-build一个channel的producer"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 build一个channel的producer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-pipelines"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 pipelines</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-fan-out-单生产-gt-多消费模式"><span class="nav-number">6.5.</span> <span class="nav-text">5.5 fan-out 单生产-&gt;多消费模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-多生产-gt-单消费"><span class="nav-number">6.6.</span> <span class="nav-text">5.6 多生产-&gt;单消费</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-7-缓冲通道-buffered-channel"><span class="nav-number">6.7.</span> <span class="nav-text">5.7 缓冲通道[buffered channel]</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-8-channels是公平的"><span class="nav-number">6.8.</span> <span class="nav-text">5.8 channels是公平的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-9-ticker信道"><span class="nav-number">6.9.</span> <span class="nav-text">5.9 ticker信道</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-共享可变状态和并发性"><span class="nav-number">7.</span> <span class="nav-text">6 共享可变状态和并发性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-细粒度线程限制"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 细粒度线程限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-粗粒度线程限制"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 粗粒度线程限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-使用互斥访问"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 使用互斥访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-actor模型"><span class="nav-number">7.4.</span> <span class="nav-text">6.4 actor模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-选择表达式"><span class="nav-number">8.</span> <span class="nav-text">7. 选择表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-从channel中选择"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 从channel中选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-通道关闭"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 通道关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-选择发送"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 选择发送</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-选择延迟的值（deferred-value）"><span class="nav-number">8.4.</span> <span class="nav-text">7.4 选择延迟的值（deferred value）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-切换延迟值的通道"><span class="nav-number">8.5.</span> <span class="nav-text">7.5 切换延迟值的通道</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hecy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
