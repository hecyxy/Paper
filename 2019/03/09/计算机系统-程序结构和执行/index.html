<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="第一部分 了解计算机系统1.1 信息就是位+上下文系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法：是我们读到的这些数据对象时的上下文。 比如在不同上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或机器指令。 1.2 程序被其他程序翻译成不同格式为了在系统上运行c程序，每条C语句都被其他程序转化为一">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机系统(1)">
<meta property="og:url" content="http://hcyxy.tech/2019/03/09/计算机系统-程序结构和执行/index.html">
<meta property="og:site_name" content="万水千山">
<meta property="og:description" content="第一部分 了解计算机系统1.1 信息就是位+上下文系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法：是我们读到的这些数据对象时的上下文。 比如在不同上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或机器指令。 1.2 程序被其他程序翻译成不同格式为了在系统上运行c程序，每条C语句都被其他程序转化为一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCEc7c89e0ae49c5e590b3c392e5082ef11/27775">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCE27dc8912cba66ae85ad101f8e0d2598e/27899">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCEcd1c97a23f754da2b46c224be0a02f8b/27993">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/95E079DB5923452283675415CA1A9691/29061">
<meta property="og:updated_time" content="2019-03-09T16:09:19.906Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机系统(1)">
<meta name="twitter:description" content="第一部分 了解计算机系统1.1 信息就是位+上下文系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法：是我们读到的这些数据对象时的上下文。 比如在不同上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或机器指令。 1.2 程序被其他程序翻译成不同格式为了在系统上运行c程序，每条C语句都被其他程序转化为一">
<meta name="twitter:image" content="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCEc7c89e0ae49c5e590b3c392e5082ef11/27775">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hcyxy.tech/2019/03/09/计算机系统-程序结构和执行/"/>





  <title>计算机系统(1) | 万水千山</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">万水千山</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">mail:hcy_xy@qq.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/09/计算机系统-程序结构和执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算机系统(1)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T20:05:30+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index">
                    <span itemprop="name">计算机系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>	阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="第一部分-了解计算机系统"><a href="#第一部分-了解计算机系统" class="headerlink" title="第一部分 了解计算机系统"></a>第一部分 了解计算机系统</h3><h4 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h4><p>系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。<strong>区分不同数据对象的唯一方法：是我们读到的这些数据对象时的上下文。</strong> 比如在不同上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或机器指令。</p>
<h4 id="1-2-程序被其他程序翻译成不同格式"><a href="#1-2-程序被其他程序翻译成不同格式" class="headerlink" title="1.2 程序被其他程序翻译成不同格式"></a>1.2 程序被其他程序翻译成不同格式</h4><p>为了在系统上运行c程序，每条C语句都被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件形式存放起来，目标程序也称为可执行目标文件。GCC编译驱动程序读取源程序文件xxx.c，将其翻译成一个可执行目标文件xxx。这个翻译过程可分为四个阶段完成。执行这四个阶段的程序（预处理器、编译器、汇编器、链接器）一起构成编译系统。<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCEc7c89e0ae49c5e590b3c392e5082ef11/27775" alt="image"></p>
<ul>
<li>预处理阶段。预处理器CPP根据以字符#开头的命令，修改原始的C程序。比如hello.c第1行#include &lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h内容，并把它插入程序文本中，于是得到另一个以.i作文文件扩展名</li>
<li>编译阶段。编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，包含一个汇编语言程序，该程序包含main函数定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">  subq $8 %rsp</span><br><span class="line">  movl $.LCO,%edi</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上每条语句都以一种文本格式描述了一条低级机器语言指令，汇编语言为不同高级语言的不同编译器提供了通用的输出语言，例如C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。</p>
<ul>
<li>汇编阶段。接下来，汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序relocatable object program的格式，并将结果保存在目标文件hello.o中，是一个二进制文件，包含的17个字节是函数main的指令编码。</li>
<li>链接阶段。hello程序调用printf函数，它是每个C编译器提供的标准C库的一个函数。printf函数存在一个printf.o的单独的预编译好的目标文件中，而这个文件必须以某种方式合并到hello.o程序中。链接器ld就负责处理这种合并，结果就得到hello文件，是一个可执行目标文件（可执行文件），可被加载到内存中，由系统执行。</li>
</ul>
<p><strong>GUN环境包括EMACS编译器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。</strong></p>
<h4 id="1-3-了解编译系统"><a href="#1-3-了解编译系统" class="headerlink" title="1.3 了解编译系统"></a>1.3 了解编译系统</h4><ul>
<li>优化程序性能。为了在C程序中做出好的编码选择，需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。如一个switch语句是否比一系列if-else语句高效；一个函数调用的开销有多大？while循环比for循环高效么；指针引用比数组索引更有效么，为了将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快的多呢？为什么只是简单地重新排列一下算术表达式中的括号就能让函数运行的更快？</li>
<li>理解链接时出现的错误。一些最令人困扰的程序错误往往斗鱼链接器操作有关，比如链接器报告无法解析一个引用？静态变量和全局变量的区别是什么，在不同c文件定义了名字相同的两个全局变量会发生什么，静态库和动态库的区别是什么，命令行上排列库的顺序有什么影响。还有一些链接错误直到运行时才出现</li>
<li>避免安全漏洞。缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误的原因是因为很少有程序员能理解需要限制从不受信任的源接受数据的数量和格式。第一步要理解数据和控制信息存储在程序栈上的方式会引起的后果。</li>
</ul>
<h4 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h4><ul>
<li>总线。贯穿整个系统的是一组电子管道，称作总线，携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字word。大多数机器字长是4byte或8byte。</li>
<li>I/O设备。如键盘、鼠标、显示器、以及长期存储数据和程序的磁盘驱动器(磁盘)。</li>
<li>主存。临时存储设备，处理执行程序时，用来存放程序和程序处理的数据。物理上来说是由一组动态随机存取存储器DRAM芯片组成；逻辑上说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)。</li>
<li><p>处理器。中央处理单元CPU，是解释或执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器PC。任何时候PC都指向主存中某条机器语言指令，即含有该条指令的地址。从系统通电开始，处理器不断执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。CPU在指令要求下可能会执行：</p>
</li>
<li><p>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容</p>
</li>
<li>存储：从寄存器复制一个字节或一个字到主存的某个位置，以覆盖这个位置上内容。</li>
<li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li>跳转：从指令本身抽取一个字，并将这个字复制到程序计数器PC中，覆盖原来的值。</li>
</ul>
<h4 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb控制器-&gt; I/O桥 -&gt;总线接口-&gt;寄存器文件-&gt;IO桥-&gt;主存储器</span><br></pre></td></tr></table></figure>
<p>比如运行hello，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器读取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。</p>
<h4 id="1-5-高速缓存"><a href="#1-5-高速缓存" class="headerlink" title="1.5 高速缓存"></a>1.5 高速缓存</h4><p>一个典型寄存器只存储几百字节信息，主存可存放几十亿字节，L1高速缓存容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快；数十万到数百万自己的更大的L2高速缓存通过一条特殊总线连接到处理器。进程访问L2比L1慢5倍，仍然比访问主存快5-10倍。L1和L2高速缓存</p>
<h4 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h4><p><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCE27dc8912cba66ae85ad101f8e0d2598e/27899" alt="image"></p>
<h4 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h4><p>操作系统有两个基本功能：</p>
<ul>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li>
</ul>
<p>OS通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O设备的抽象，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</p>
<h5 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h5><p>进程是操作系统对一个正在运行的程序一种抽象。多核处理器能同时能够执行多个程序，无论单核还是多核系统，一个cpu都像是在并发执行多个进程，是通过上下文切换实现的。OS跟踪进程所需的所有状态信息，就是上下文，如PC和寄存器文件的当前值、以及主存的内容。</p>
<h5 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h5><p>事实上，一个进程实际上可以由多个称为线程的执行单元组成，<strong>每个线程都运行在进程的上下文中，共享同样的代码和全局数据。</strong> 由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程高效。</p>
<h5 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h5><p>虚拟内存是一个抽象概念，为每个进程提供了一个假象，即每个进程独占使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成那个，每个区都有专门的功能。</p>
<ul>
<li>程序代码和数据。代码从一固定地址开始，紧接着是和C全局变量相对应的数据位置。</li>
<li>堆。代码和数据区后紧随着是运行时堆。当调用malloc和free这样的C标准库，堆可以在运行时动态扩展和收缩。</li>
<li>共享库。地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li>栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和碓一样，用户栈在程序执行期间可以动态的扩展和收缩。每次调用一个函数，栈就会增长；从一个函数返回，就会收缩。</li>
<li>内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们不调用内核来执行这些操作。</li>
</ul>
<h5 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h5><p>文件就是字节序列。每个I/O设备，包括磁盘、键盘、显示器、甚至网络都可以看成是文件。系统中所有输入输出都是通过一小组称为Unix I/O的系统函数调用读写文件来实现的。向应用程序提供了一个统一的视图。</p>
<h4 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h4><p>网络可视为一个I/O设备，当系统从主存复制一串字节到网络适配器，数据流经过网络到达另一台机器。</p>
<h4 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h4><h5 id="1-9-1-Amdahl定律-阿姆达尔定律"><a href="#1-9-1-Amdahl定律-阿姆达尔定律" class="headerlink" title="1.9.1 Amdahl定律 阿姆达尔定律"></a>1.9.1 Amdahl定律 阿姆达尔定律</h5><p>对提升系统某一部分性能所带来的效果做出了简单却有见地的观察，这个定律被称为阿姆达尔定律。主要思想：<strong>当对系统某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为<code>$T_{old}$</code>.假设系统某部分所需执行时间与该时间的比例为<code>$\alpha$</code>，而该部分性能提升比例为k。即该部分初始所需时间为<code>$\alpha T_{old}$</code>,现在所需时间为<code>$(\alpha T_{old})/k$</code></strong>，因此总的执行时间为：<br><code>$T_{new}$</code>=(1-<code>$\alpha$</code>)<code>$T_{old}$</code>+(<code>$\alpha T_{old}$</code>)/k</p>
<p>由此可以计算加速比<code>$S=T_{old}/T_{new}$</code><br><br><code>$S=\frac{1}{(1-\alpha)+\alpha/k}$</code></p>
<h5 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h5><h5 id="1-线程级并发"><a href="#1-线程级并发" class="headerlink" title="1.线程级并发"></a>1.线程级并发</h5><p>多核处理器是将多个CPU(核)集成到一个集成电路芯片上。下图是一个典型的多核处理器组织结构，微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，L1高速缓存分为两个部分：一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口，工业界专家预言能够将几十个、上百个核做到一个芯片上。<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCEcd1c97a23f754da2b46c224be0a02f8b/27993" alt="image"></p>
<p>超线程，也称为同时多线程，允许一个CPU执行多个控制流。涉及CPU某些硬件有多个备份，比如PC和寄存器，而其他的硬件部分只有一份，比如之幸福店算术运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪个线程。这使得CPU能够更好地利用它的处理资源，比如一个线程必须等到某些数据被装载到高速缓存中，那么CPU就可以继续执行另一个线程。比如Intel i7可以让每个核并行执行两个线程。</p>
<p>多处理器可以从两方面提高系统性能。</p>
<ul>
<li>减少了在执行多个任务时模拟并发的需要。</li>
<li>其次，可以使应用程序运行的更快。必须要求程序是以多线程方式来书写，这些线程可以并行的高效执行。</li>
</ul>
<h5 id="2-指令级并行"><a href="#2-指令级并行" class="headerlink" title="2.指令级并行"></a>2.指令级并行</h5><p>早期的微处理器，需要多个(3-10)时钟周期来执行一条指令，最近的处理器每个时钟周期执行2-4条指令。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量处理器的高级模型。</strong></p>
<h5 id="3-单指令、多数据并行"><a href="#3-单指令、多数据并行" class="headerlink" title="3.单指令、多数据并行"></a>3.单指令、多数据并行</h5><p>许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如，较新几代的Intel和AMD处理器都具有并行的对8对单精度浮点数做加法的指令。</p>
<p>提供这些SIMD指令是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C程序自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。</p>
<p>并行：</p>
<ul>
<li>位级并行ILP，处理器处理的字长不断增加，并行度自然增加；</li>
<li>instruction level parallelismILP：指令级并行，处理器同时处理多条指令。超标量和超长指令字是目前最基本的两类指令级并行技术；</li>
<li>DLP：数据级并行，能同时处理多条数据；SIMD</li>
<li><p>TLP：任务级并行。更多的是被称为Thread-level parallelism。TLP，线程级并行。</p>
</li>
<li><p>时间级并行，指流水线并行；</p>
</li>
<li>空间并行：包括指令并行、数据并行、线程并行；</li>
</ul>
<p>简单理解，向量a[n],b[n],c[n],那么：</p>
<ul>
<li>垂直计算模式：a[i] op b[i] = c[i]</li>
<li>水平计算模式：a[i] op a[i+1] = c[i]</li>
<li>标量计算模式： a[0] op b[0] = c[0]<br>对于多媒体的计算和科学计算，存在大量类似计算，所以说SIMD能极大提高计算性能。<br><br>比如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;N;i++)c[i]=a[i]+b[i]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样的代码就能生成SIMD指令，但是不能接受无限大的N，对不同指令集，能接受的数据长度是一定的，比如AVX指令级，能接受的长度为256字节，所以可以这样优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;N;i+=4)&#123;</span><br><span class="line">    c[i]=a[i]+b[i];</span><br><span class="line">    c[i+1]=a[i+1]+b[i+1]</span><br><span class="line">    c[i+2]=a[i+2]+b[i+2]</span><br><span class="line">    c[i+3]=a[i+3]+b[i+3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的代码，很容易生成SIMD指令，具体需要依赖编译器实现，这里的4也是一个例子，前提是数组a/b/c的数据元素乘以4为SIMD指令集能接受一次运算的长度。</p>
<p>线程级并行：是一种更高层的数据并行，是一种分时复用的思想，可以依靠OS来完成，现在的处理器，硬件也会为线程并行提供帮助，提高效率。</p>
<h5 id="1-9-3-计算机系统中的抽象"><a href="#1-9-3-计算机系统中的抽象" class="headerlink" title="1.9.3 计算机系统中的抽象"></a>1.9.3 计算机系统中的抽象</h5><p>文件是对I/O设备的抽象，虚拟内存是对主存和IO设备的抽象；指令集架构是对处理器的抽象；进程是对IO、主存、处理器【正在运行的程序】的抽象；虚拟机是对整个计算机的抽象，包括OS、处理器程序。</p>
<h3 id="第二部分-程序结构和执行"><a href="#第二部分-程序结构和执行" class="headerlink" title="第二部分 程序结构和执行"></a>第二部分 程序结构和执行</h3><h3 id="2-1-信息的表示和处理"><a href="#2-1-信息的表示和处理" class="headerlink" title="2.1 信息的表示和处理"></a>2.1 信息的表示和处理</h3><h4 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h4><p>对于跨越多字节的程序对象，需要建立两个规则：<strong>这个对象地址是什么，以及在内存中如何排列这些字节。</strong> 几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。排列一个对象的字节有两个通用规则：</p>
<ul>
<li>某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，最低有效字节在最前面的方式，称为小端法</li>
<li>最高有效字节在最前面的方式，称为大端法。</li>
</ul>
<p>最前面指低地址位置。大多数Intel兼容机只用小端模式，另一方面IBM、Oracle的大多数机器则是按大端模式操作。</p>
<h3 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h3><p>了解如何将C程序编译成汇编语言。如何实现C语言中的控制结构，如if、while、switch语句，实现的过程包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。接着考虑在机器级如何实现像数组、结构和联合这样的数据结构。还会讨论内存访问越界、以及易受缓冲区溢出攻击问题和一些GDB调试技巧。</p>
<h4 id="3-1-机器级代码"><a href="#3-1-机器级代码" class="headerlink" title="3.1 机器级代码"></a>3.1 机器级代码</h4><p>计算机使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现细节，对于机器级编程来说，其中两种抽象很重要：</p>
<ul>
<li>指令集体系结构或指令集架构Instruction Set Architecture(ISA)来定义机器级程序的格式和行为，定义了处理器状态、指令格式，以及每条指令对状态的影响。大多数ISA将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条开始。处理器的硬件远比描述的精细复杂，并发执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的完全一致。</li>
<li>机器级程序使用的内存地址是虚拟地址，提供的内存模型和OS软件组合起来。</li>
</ul>
<p>X86-64的机器代码和原始C代码差距很大，一些通常对C语言程序员隐藏的处理器都是可见的：</p>
<ul>
<li>程序计数器PC，给出要执行的下一条指令在内存中的地址</li>
<li>整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言指针)或整数数据，有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保留临时数据，例如参数、局部变量、以及函数返回值；</li>
<li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。用来控制或数据流中的条件变化，比如if、while</li>
<li>一组向量寄存器可以存放一个或多个整数或浮点数值，为了支持向量计算，系统也提供了众多的向量寄存器</li>
</ul>
<p>机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。 程序内存包含：程序的可执行机器代码，OS需要的信息、管理过程调用和返回的运行时栈，以及用户分配的内存块(比如malloc)。OS负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。<strong>一条机器指令只执行一个非常基本的操作，如将寄存器中两个数字相加，在存储器和寄存器间传送数据，或是条件分支转移到新的指令地址。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -S hello.s</span><br></pre></td></tr></table></figure></p>
<p>将产生一个hello.s的汇编语言文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -c hello.c</span><br></pre></td></tr></table></figure></p>
<p>将生成二进制源文件。</p>
<h4 id="3-2-访问信息"><a href="#3-2-访问信息" class="headerlink" title="3.2 访问信息"></a>3.2 访问信息</h4><p>一个x86-64的中央处理单元CPU包含一组16个存储64位值得通用目的寄存器。这些寄存器用来存储整数数据和指针。</p>
<h5 id="3-2-1-操作数指示符"><a href="#3-2-1-操作数指示符" class="headerlink" title="3.2.1 操作数指示符"></a>3.2.1 操作数指示符</h5><p>大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置，源数据值可以是常数值、或寄存器、内存中读出；</p>
<ul>
<li>立即数，表示常数值，通常用 $后跟一个标准C表示的整数</li>
<li>寄存器。表示某个寄存器的内容，比如16个寄存器低1b、2b、4b、8b中的一个作为一个操作数，形如<code>$R[r_{a}]$</code>，<code>$r_a$</code>表示任意寄存器a，<code>$R[r_{a}]$</code>表示其值；</li>
<li>内存引用。根据计算出来的地址访问某个内存为止，因为将内存看成一个很大的字节数组，用符号<code>$M_b[Addr]$</code>表示对存储在内存中从地址Addr开始的b字节值得引用；</li>
</ul>
<p>有不同寻址模式，允许不同内存引用，<code>$Imm(r_b,r_i,s)$</code>表示最常用形式，立即数偏移<code>$Imm$</code>，基址寄存器<code>$r_b$</code>，变址寄存器<code>$r_i$</code>，比例因子s，s必须是1、2、4或者8.基址和变址寄存器必须是64位寄存器。有效地址：<code>$Imm+R[r_b]+R[r_i]*s$</code>。引用数组元素会用这种通用形式。</p>
<h4 id="3-2-2-数据传送指令"><a href="#3-2-2-数据传送指令" class="headerlink" title="3.2.2 数据传送指令"></a>3.2.2 数据传送指令</h4><ul>
<li>mov 将数据从一个位置复制到另一个位置的指令；</li>
<li>ret 函数返回指令</li>
</ul>
<p>C语言中所谓的指针其实就是地址，间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器，其次局部变量通常保存在寄存器中，而不是内存中，访问寄存器要比内存快的多；</p>
<h4 id="3-2-3-算术和逻辑操作"><a href="#3-2-3-算术和逻辑操作" class="headerlink" title="3.2.3 算术和逻辑操作"></a>3.2.3 算术和逻辑操作</h4><ul>
<li>leap实际是mvoq指令的变形，指令形式是从内存读数据到寄存器，实际上根本没有引用内存。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leap 7(%rdx,%rdx,4),%rax 设置寄存器%rax = 5x+7</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>leaq指令能执行加法和有限形式的乘法。<br>存储乘积需要两个movq指令，一个存储低8个字节，一个存储高8字节；出发中，需要将商和余数存储在不同寄存器中。</p>
<h4 id="3-3-控制"><a href="#3-3-控制" class="headerlink" title="3.3 控制"></a>3.3 控制</h4><h5 id="3-3-1-条件码"><a href="#3-3-1-条件码" class="headerlink" title="3.3.1 条件码"></a>3.3.1 条件码</h5><p>除了整数寄存器，CPU维护着一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。</p>
<ul>
<li>CF:进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出,(unsigned)t&lt;(unsigned)a；</li>
<li>ZF：零标志。最近的操作得出的结果为0,(t==0)</li>
<li>SF：符号标志。最近的操作得到的结果为负数,(t&lt;0)；</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出-正溢出、负溢出,(a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0!=a&lt;0)</li>
</ul>
<h5 id="3-3-2-访问条件码"><a href="#3-3-2-访问条件码" class="headerlink" title="3.3.2 访问条件码"></a>3.3.2 访问条件码</h5><p>条件码通常不会直接读取，常用的使用方法三种：</p>
<ul>
<li>根据条件码的某种组合，讲一个字节设置为0或1，</li>
<li>可以条件跳转到程序某个其他地方；</li>
<li>可以有条件传送数据</li>
</ul>
<h5 id="3-3-3-访问条件码"><a href="#3-3-3-访问条件码" class="headerlink" title="3.3.3 访问条件码"></a>3.3.3 访问条件码</h5><p>jmp指令会导致执行切换到一个全新的位置，jmp是无条件跳转，可以是直接跳转，即目标是作为指令的一部分编码，也可以是间接跳转，目标是从寄存器或内存位置读出；</p>
<h5 id="3-3-4-用条件传送来实现条件分支"><a href="#3-3-4-用条件传送来实现条件分支" class="headerlink" title="3.3.4 用条件传送来实现条件分支"></a>3.3.4 用条件传送来实现条件分支</h5><p>实现条件操作的传统方法是通过使用控制的条件转移，这种机制简单通用，但是在现代处理器上可能非常低效。<strong>一种替代的策略是使用数据的条件转移，这种方法计算第一个条件操作的两种结果，然后根绝条件是否满足选取其中一个。如果策略可行，可以用一条简单的条件传送指令来实现，更符合现代处理器性能特征。</strong></p>
<h5 id="为什么基于数据传送的代码比基于条件控制转移的代码性能好"><a href="#为什么基于数据传送的代码比基于条件控制转移的代码性能好" class="headerlink" title="为什么基于数据传送的代码比基于条件控制转移的代码性能好"></a>为什么基于数据传送的代码比基于条件控制转移的代码性能好</h5><p>处理器通过使用流水线pipeline来获得高性能，流水线中一条指令的处理要经过一系列阶段，每个阶段执行所需操作的一小部分（从内存取指令 -&gt; 确定指令类型-&gt;从内存读数据-&gt;执行算术运算-&gt;向内存写数据-&gt;更新程序计数器）。<strong>这种方法通过重叠连续指令的步骤来获得高性能，如在取一条指令的同时，执行前面一条指令的算术运算。所以要事先确定要执行的指令序列，这样才能保证流水线充满待执行的指令。</strong></p>
<p>机器遇到条件跳转（分支）时，只有当分支条件求值完成后，才能决定分支往哪走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否执行，只要猜测可靠（<strong>现代微处理器试图达到90%以上成功率</strong>），指令流水线就会冲满着指令。另一方面错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始从正确位置处起始的指令去填充流水线。<strong>错误预测会招致很严重的惩罚，浪费大约15-30个周期，导致程序性鞥严重下降。</strong></p>
<p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long absdiff(long x,long y)</span><br><span class="line">&#123;</span><br><span class="line">    long result;</span><br><span class="line">    if(x&lt;y)</span><br><span class="line">        result = y -x;</span><br><span class="line">    else</span><br><span class="line">        result = x -y;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于数据的条件转移<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long comvdiff(long x,long y)</span><br><span class="line">&#123;</span><br><span class="line">    long rval = y -x;</span><br><span class="line">    long eval = x -y;</span><br><span class="line">    //below line requires single instuction</span><br><span class="line">    if(ntext) rval = eval</span><br><span class="line">    return rval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个典型应用中，<code>$x&lt;y$</code>的结果非常不可预测，使用最精密的分支预测硬件也只有50%概率猜对。两个代码序列中计算执行都只需要一个时钟周期，分支预测错误处罚主导着函数性能，对于包含条件跳转的x86-64代码，<strong>分支行为容易预测时，每次调用函数需要大约8个时钟周期；分支行为是随机的时候，每次调用17.5个时钟周期，推断出分支预测错误的处罚大约是19个时钟周期，意味着函数需要的时间范围大约在8-27个周期间，依赖于分支预测是否正确。</strong></p>
<h6 id="如何确定分支预测错误处罚"><a href="#如何确定分支预测错误处罚" class="headerlink" title="如何确定分支预测错误处罚"></a>如何确定分支预测错误处罚</h6><p>假设预测错误概率为p，没有预测错误的时间为<code>$T_{ok}$</code>，预测错误处罚是<code>$T_{mp}$</code>，作为p的一个函数，执行代码平均时间是<code>$T_{avg}(p)=(1-p)T_{ok}+p(T_{ok}+T_{mp})=T_{ok}+pT_{mp}$</code>。<br>如果已知<code>$T_{ok}$</code>和<code>$T_{ran}$</code>(当p0.5时的平均时间)，即<code>$T_{ran}=T_{avg}(0.5)=T_{ok}+0.5T_{mp}$</code>，所以有<code>$T_{mp}=2(T_{ran}-T_{ok})$</code>,对于<code>$T_{ok}=8$</code>和<code>$T_{ran}=17.5$</code>，有<code>$T_{mp}=19$</code>.</p>
<p><strong>同条件跳转不同</strong>，处理器无需预测测试的结果就可以执行<strong>条件传送</strong>，处理器只是读原值，检查条件码，然后要么更新目的寄存器，要么保持不变。</p>
<p>不是所有的条件表达式都可以用条件传送来编译，比如<code>$xp ? *xp:0$</code>。使用条件传送也不总是提高代码效率，比如不同分支需要大量计算，如果对应条件不满足这些计算就白费了。编译器并不具有足够的信息来做出可靠的决定。对GCC的实验表明，只有两个表达式很容易计算如一条加法指令，才会使用条件传送。即使许多分支预测错误的开销会超过更复杂的计算，GCC还是会使用条件控制转移。</p>
<h6 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h6><p>在处理具有多种可能结果的测试时，这种语句很有用，不仅提高了C的可读性，而且通过<strong>跳转表jump table</strong>，这种数据结构使得实现更加高效；跳转表是一个数组，表项i是一个代码段的地址，当开关索引值等于i时，程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。<strong>和if-else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况数量无关，GCC根据开关情况的数量和开关情况值的稀疏成都来翻译开关语句。当开关情况数量比较多(4个以上)，并且值的范围跨度比较小，就会使用跳转表。</strong></p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>过程是软件中一种很重要的抽象，提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。要提供对过程的机器级支持，必须要处理许多不同属性，假设过程P调用Q，Q执行后返回到P，这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制。进入过程Q时，PC必须被设置为Q的起始地址，然后返回时，要把PC设置为P中调用Q后面那条指令的地址；</li>
<li>传递数据：P必须能够像Q提供一个或多个参数，Q必须能够向P返回一个值；</li>
<li>分配和释放内存：开始时Q可能需要为局部变量分配空间，返回前又必须释放这些存储空间。</li>
</ul>
<p>x86-64的过程实现包括一组特殊的指令和一些对机器资源（寄存器和内存）使用的约定规则，要尽量减少过程调用的开销，所以遵循了被认为是最低要求策略的方法。一步步构建不同机制。</p>
<h6 id="3-4-1-运行时栈"><a href="#3-4-1-运行时栈" class="headerlink" title="3.4.1 运行时栈"></a>3.4.1 运行时栈</h6><p>C语言过程调用一个关键特性：使用了栈数据结构提供后进先出的内存管理原则。当过程调用需要的存储空间超出寄存器能够存放的大小时，就会在<strong>栈上分配空间，这个部分称为过程的栈帧。</strong>P调用Q，Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间，这个空间中，可以保存寄存器的值，分配局部变量空间，为其调用过程设置参数，大多数过程的栈帧都是定长的，过程开始就分配好了，有些过程需要变长的诊。<strong>通过寄存器，过程P可以传递最多6个整数值，如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储这些参数。</strong></p>
<p>为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分，许多过程有6个或者更少的参数，那么所有参数都可以通过寄存器传递。实际许多函数甚至不需要栈帧，当所有局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，就可以这样处理。</p>
<h6 id="3-4-2-转移控制"><a href="#3-4-2-转移控制" class="headerlink" title="3.4.2 转移控制"></a>3.4.2 转移控制</h6><p>将控制从函数P转移到函数Q，只需要简单把程序计数器PC设置为Q的代码起始位置，稍后从Q返回时候，处理器必须记录好它需要继续P的执行的位置。使用call和ret指令。</p>
<h6 id="3-4-3-数据传送"><a href="#3-4-3-数据传送" class="headerlink" title="3.4.3 数据传送"></a>3.4.3 数据传送</h6><p>当调用一个过程，除了要传递控制，还要在过程调用中把数据作为参数传递，而从过程返回还有可能包括返回一个值。大部分过程间的数据传送是通过寄存器实现的。x86-64最多传递6个整型参数，多出来的参数要存在栈上。</p>
<h6 id="3-4-4-数据传送"><a href="#3-4-4-数据传送" class="headerlink" title="3.4.4 数据传送"></a>3.4.4 数据传送</h6><p>有些情况局部数据必须放在内存中，常见情况：</p>
<ul>
<li>寄存器不足够存放所有本地数据</li>
<li>对一个局部变量使用地址运算符&amp;,因此必须能够为其产生一个地址；</li>
<li>某些局部变量是数组或结构，因此必须能通过数组或结构引用被访问到；</li>
</ul>
<p>一般来说过程通过减小栈指针在栈上分配空间，分配的结果作为栈帧一部分，标号为局部变量。</p>
<h6 id="3-4-5-寄存器中的局部存储空间"><a href="#3-4-5-寄存器中的局部存储空间" class="headerlink" title="3.4.5 寄存器中的局部存储空间"></a>3.4.5 寄存器中的局部存储空间</h6><p>寄存器是唯一被所有过程共享的资源，虽然在给定时刻只有一个过程是活动的，必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。</p>
<h6 id="3-4-6-递归过程"><a href="#3-4-6-递归过程" class="headerlink" title="3.4.6 递归过程"></a>3.4.6 递归过程</h6><p>每个过程调用在栈中都有自己的私有空间，因此多个未完成调用的局部变量不会相互影响，此外栈的原则很自然的提供了适当的策略，当过程被调用时分配局部存储，返回时就释放存储。</p>
<p>递归调用一个函数本身与调用其它函数一样，栈规则提供一种机制，每次函数调用都有它自己私有的状态信息(保存的返回位置和被调用者保存寄存器的值)存储空间，还可以提供局部变量的存储。</p>
<h5 id="3-5-数组分配和访问"><a href="#3-5-数组分配和访问" class="headerlink" title="3.5 数组分配和访问"></a>3.5 数组分配和访问</h5><p>c语言中的数组是一种将标量数据聚集成更大数据类型的方式。优化编译器非常善于简化数组索引所使用的地址计算。</p>
<h5 id="3-6-异质的数据结构"><a href="#3-6-异质的数据结构" class="headerlink" title="3.6 异质的数据结构"></a>3.6 异质的数据结构</h5><p>C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制，结构structure，用struct声明，将多个对象集合到一个单位中；联合union，用关键字union声明，允许集中不同的类型来引用一个对象。</p>
<ul>
<li>C语言的struct声明创建一个数据类型，将不同类型的对象聚合到一个对象中，用名字引用结构的各个组成部分，类似于数组的实现，结构所有组成部分都存放在内存中一段连续的区域内，指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。</li>
<li>联合。联合提供一种方式，可以规避C语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，语义相差比较大，用不同字段来引用相同的内存块。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct S3&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i[2];</span><br><span class="line">    double v;</span><br><span class="line">&#125;</span><br><span class="line">union U3&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i[2];</span><br><span class="line">    double v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在x86-64 linux机器上编译时，字段的偏移量、数据类型S3和U3的完整大小如下：<br>|类型|c|i|v|大小|<br>|—|—|—|—|—|<br>|S3|0|4|16|24|<br>|U3|0|0|0|8|<br>为什么S3中i的偏移量不是1，v的偏移量不是9或12；对于union U3 <strong>的指针p、p-&gt;c、p-&gt;i[0]引用的都是起始位置，一个联合的总大小等于最大字段的大小</strong>【存在数据对齐的规则】** 。在一些情况下，联合十分有用，也可能引起一些错误，绕过了C语言类型系统提供的安全措施，如果知道一个数据结构中两个不同字段的使用是互斥的，可以将这两个字段声明为联合一部分，会减小分配空间的总量。</p>
<h6 id="3-6-2-数据对齐"><a href="#3-6-2-数据对齐" class="headerlink" title="3.6.2 数据对齐"></a>3.6.2 数据对齐</h6><p>许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K(2、4、8)的倍数，这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。</p>
<h5 id="3-7-机器级程序中将控制与数据结合起来"><a href="#3-7-机器级程序中将控制与数据结合起来" class="headerlink" title="3.7 机器级程序中将控制与数据结合起来"></a>3.7 机器级程序中将控制与数据结合起来</h5><h6 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h6><p>C对于数组引用不进行任何边界检查，而且局部变量和状态信息（保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界数组元素的写操作会破坏存储在栈中的状态信息，当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现严重错误。</p>
<p>一种特别常见的状态破坏被称为缓冲区溢出，在栈中分配某个字符数组来保存某个字符串，但是字符串长度超出了为数组分配的空间。</p>
<p>缓冲区溢出一个更加致命的错误就是让程序执行本来不会执行的函数，这是一种最常见的通过计算机网络供给系统安全的方法，通常输入程序给程序一个字符串，这个字符串包含一些可执行代码的字节编码，攻击代码，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址，那么执行ret指令的效果就是跳转到攻击代码。另一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组OS函数。</p>
<h5 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h5><ul>
<li>栈随机化。为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分，产生这个指针需要知道这个字符串放置的栈地址。过去程序的栈地址很容易预测，栈地址相当固定。<strong>栈随机化的思想使得栈的位置在程序每次运行时都有变化，实现方式：程序开始时，在栈上分配一段0~n字节之间的随即大小空间，ASLR：每次运行程序不同部分(程序代码 库代码 栈 全局变量 堆数据 都会被加载到内存不同区域).</strong>也可以用蛮力克服随机化，在实际的攻击代码前插入很长一段nop指令。</li>
<li>栈破坏检测。破坏通常发生在当超越局部缓冲区的边界时。GCC正在产生代码中加入了一种栈保护者机制来检测缓冲区越界。思想是在栈帧中任何局部缓冲区与栈状态之间存储了一个特殊的金丝雀值，程序每次运行随机产生，在恢复寄存器状态、从函数返回前，程序检查这个金丝雀是否被该函数的某个操作或者函数调用的某个函数的某个操作改变了，如果是程序就异常中止。</li>
<li>限制可执行代码区域。限制哪些内存区域能够存放可执行代码。只有保存编译器产生的代码的那部分内存才需要是可执行的，其他部分只允许读和写。虚拟内存在逻辑上被分成了页，硬件支持多种形式的内存保护，能够指明用户程序和OS内核所允许的访问形式。许多系统允许控制三种访问形式，读、写、执行。有些类型的程序要求动态产生和执行代码的能力，如即时编译just-in-time为解释语言编写的程序动态产生代码，来提高性能。</li>
</ul>
<h5 id="支持边长栈帧"><a href="#支持边长栈帧" class="headerlink" title="支持边长栈帧"></a>支持边长栈帧</h5><p>为了管理边长栈帧，使用寄存器作为栈指针（基指针）。较早版本的x86代码每个函数调用都使用了栈指针，现在只有栈帧长可变的情况下才使用。</p>
<h4 id="4-处理器体系结构"><a href="#4-处理器体系结构" class="headerlink" title="4 处理器体系结构"></a>4 处理器体系结构</h4><p>一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构ISA。ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层。</p>
<h5 id="4-1-逻辑设计和硬件控制语言HCL"><a href="#4-1-逻辑设计和硬件控制语言HCL" class="headerlink" title="4.1 逻辑设计和硬件控制语言HCL"></a>4.1 逻辑设计和硬件控制语言HCL</h5><p>硬件设计中，用电子电路来对位进行运算，以及在各种存储器单元中存储位。大多数现代电路技术都使用信号线上的高电压、低电压表示不同的位值。逻辑1用高电压表示，逻辑0用0伏特左右的低电压表示。实现一个数字系统需要三个组成部分：<strong>计算对位进行操作的函数的组合、存储位的存储单元以及控制存储器单元的更新的时钟单元。</strong> HCL硬件控制语言，来描述不同处理器设计的控制逻辑。</p>
<p>现代逻辑设计：HDL是一种文本表示，看上去和编程语言类似，用来描述硬件结构而不是程序行为，常用语言有verilog、VHDL，用来表示数字电路的模拟模型。</p>
<h6 id="4-1-1-逻辑门"><a href="#4-1-1-逻辑门" class="headerlink" title="4.1.1 逻辑门"></a>4.1.1 逻辑门</h6><p>逻辑门是数字电路的基本计算单元，产生的输出等于它们输入位值的某个布尔函数。逻辑门是活动的，一旦一个门输入变化，很短时间内，输出也会相应变化。</p>
<h6 id="4-1-2-组合电路和HCL布尔表达式"><a href="#4-1-2-组合电路和HCL布尔表达式" class="headerlink" title="4.1.2 组合电路和HCL布尔表达式"></a>4.1.2 组合电路和HCL布尔表达式</h6><p>将很多的逻辑门组合成一个网就能构建计算块，称为组合电路。如何构建这些网有几个限制</p>
<ul>
<li>每个逻辑门输入必须连接到下述选项之一：1）一个系统输入2）某个存储器单元的输出3）某个逻辑门输出</li>
<li>两个或多个逻辑门的输出不能连接到一起，否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障；</li>
<li>这个电路必须是无环的。网中不能有路径经过一系列的门而形成一个回路。</li>
</ul>
<h6 id="4-1-3-字级的组合电路和HCL整数表达式"><a href="#4-1-3-字级的组合电路和HCL整数表达式" class="headerlink" title="4.1.3 字级的组合电路和HCL整数表达式"></a>4.1.3 字级的组合电路和HCL整数表达式</h6><p>通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常设计能对数据字word进行操作的电路.组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。算术/逻辑单元ALU是一种很重要的组合电路。</p>
<h6 id="4-1-3-存储器和时钟"><a href="#4-1-3-存储器和时钟" class="headerlink" title="4.1.3 存储器和时钟"></a>4.1.3 存储器和时钟</h6><p>组合电路本质上讲，不存储任何信息，只是简单响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，即有状态且在这个状态上进行计算的系统，必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性的信号，决定什么时候将新值加载到设备中。考虑两类存储设备：</p>
<ul>
<li>时钟寄存器。存储单个位或字，时钟信号控制寄存器加载输入值；</li>
<li><p>随机访问存储器，存储多个字，用地址选择该读、写哪些字。随机访问存储器包括1）处理器的虚拟内存系统；2）寄存器文件</p>
<p>说道硬件和机器级编程，“寄存器”这个词有细微的差别。硬件中寄存器直接将它的输入和输出连接到电路其他部分，机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里指寄存器ID，这些字通常都存在寄存器文件中。通常分别称为“硬件寄存器”和“程序寄存器”。</p>
<p>寄存器文件都两个读端口、一个写端口，这样一个多端口随机访问存储器允许同时进行多个读和写操作。虽然寄存器文件不是组合电路，因为它有内部存储。实现中，从寄存器文件读数据好像它是一个以地址输入、数据为输出的一个组合逻辑块。向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valW上的值就会被写入输入dstW上的寄存器ID指示的程序寄存器。</p>
</li>
</ul>
<h5 id="4-2-指令的顺序实现"><a href="#4-2-指令的顺序实现" class="headerlink" title="4.2 指令的顺序实现"></a>4.2 指令的顺序实现</h5><p>顺序处理的处理器SEQ，每个时钟周期上SEQ执行处理一条完整指令所需的所有步骤。需要很长的时钟周期，因此时钟周期频率会低到不可接受。开发SEQ的目标是提供实现最终目的的第一步，实现一个高效、流水线化的处理器。</p>
<h6 id="4-2-1-将处理组织成阶段"><a href="#4-2-1-将处理组织成阶段" class="headerlink" title="4.2.1 将处理组织成阶段"></a>4.2.1 将处理组织成阶段</h6><p>通常一条指令包括很多操作，将其组织成某个特殊的阶段序列，即使指令动作差异很大，所有指令都遵循统一序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，以便能充分利用硬件。</p>
<ul>
<li>取指fetch：从内存读取指令字节，地址为程序计数器的值。从指令抽取出两个四位部分：icode(指令代码)和ifun(指令功能).</li>
<li>译码decode：译码阶段从寄存器文件读入最多两个操作数。得到valA和valB，读入指令rA和rB字段指明的寄存器。</li>
<li>执行execute：执行阶段，算术/逻辑单元ALU要么执行指令指明的操作(根据ifun的值)，计算内存引用的有效地址，要么增加或减少栈指针。</li>
<li>访存memory：访存阶段可以将数据写入内存或者从内存读出数据；</li>
<li>写回write back：写回阶段最多可以写两个结果到寄存器文件</li>
<li>更新pc：将pc设置为下一条指令的地址</li>
</ul>
<p>处理器无限循环执行这些阶段，发生任何异常，处理器就会停止，执行halt指令或非法指令，处理器会进入异常处理模式。 </p>
<h6 id="4-2-2-SEQ的时序"><a href="#4-2-2-SEQ的时序" class="headerlink" title="4.2.2 SEQ的时序"></a>4.2.2 SEQ的时序</h6><p>一个时钟变化会引发一个经过组合逻辑的流，来执行整个指令。</p>
<p>SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器(程序计数器和条件码寄存器)、随机访问存储器(寄存器文件、指令内存和数据内存)。组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播。将随机访问存储器看成和组合逻辑一样的操作，根据地址输入产生输出字。</p>
<p>程序计数器、条件码寄存器、数据内存和寄存器文件需要通过一个时钟信号来控制，触发新值装载到寄存器以及将值写到随机访问存储器。只有在执行整数运算指令时，才会装载条件码寄存器。</p>
<p><strong>要控制处理器中活动的时序，只需要寄存器和内存的时钟控制。从不回读：处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</strong><br>比如对pushq指令实现先是将%rsp减8，再将更新后的%rsp值作为写操作的地址，这种方法同前面所说的那个原则相违背。真正的实现：实现产生出减后的栈指针值，作为信号valE，然后再用这个信号既作为寄存器写的数据，也作为内存写的地址。因此在时钟上升开始下一个周期时，处理器就可以同时执行寄存器写和内存写。</p>
<h5 id="4-3-流水线通用原理"><a href="#4-3-流水线通用原理" class="headerlink" title="4.3 流水线通用原理"></a>4.3 流水线通用原理</h5><p><strong>流水线化的一个重要特征就是提高了系统吞吐量，轻微的增加延迟。</strong></p>
<p>流水线的局限性？<br></p>
<ul>
<li>不一致的划分。比如将计算划分为三个阶段，这些阶段延迟从50ps到150ps不等，但是运行时钟的速率是由最慢的阶段的延迟限制的。通常处理器中某些硬件单元，如ALU和内存是不能划分成多个延迟较小的单元的。</li>
<li>流水线过深，收益反而下降。比如将计算分为6个阶段，流水线阶段数加倍，性能提高1.71倍，虽然将每个计算时钟时间缩短两倍，但是由于通过流水线寄存器的延迟，吞吐量没有加倍。</li>
</ul>
<p>为了提高时钟频率，现代处理器用了很深的流水线（15或更多阶段）。</p>
<h6 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h6><p>流水线化设计的目的就是每个时钟周期都发射一条新指令，每个时钟周期都有一条新指令进入执行阶段并最终完成。如果取出当前指令，确定的下一条指令是条件分支指令，则要在几个周期后，才能知道是否选择分支。猜测分支方向并根据猜测开始取指的技术成为分支预测。</p>
<h5 id="4-4-流水线冒险"><a href="#4-4-流水线冒险" class="headerlink" title="4.4 流水线冒险"></a>4.4 流水线冒险</h5><p>将流水线技术引入一个带反馈的系统，当相邻间存在相关时会导致出现问题，在完成设计前，要解决这个问题。</p>
<ul>
<li>数据相关。下条指令会用到这条指令计算出的结果</li>
<li>控制相关。一条指令要确定下一条指令的位置，例如在执行跳转。</li>
</ul>
<p>如何处理数据冒险？<br></p>
<ul>
<li>暂停stalling。暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足；</li>
<li>用转发避免数据冒险。将要写的值传到流水线寄存器作为源操作数。这种将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发(旁路)。</li>
<li>加载/使用数据冒险。有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚。可以使用暂停来处理加载/使用冒险，通过将某些指令暂停第一个周期，这种方法称为加载互锁。</li>
<li>避免控制冒险。当处理器无法根据处于取指阶段的当前指令确定下一条指令的地址时，就会出现控制冒险。控制冒险只会发生ret指令和跳转指令。</li>
</ul>
<p>异常处理：处理器中很多事情都会导致异常控制流，指令集体系结构包括三种不同内部产生的异常：1）halt指令2）有非法指令和功能码组合的指令；3）取指或数据读写试图访问一个非法地址；</p>
<p>流水线必须处理下面4种控制情况：</p>
<ul>
<li>加载/使用冒险：在一条从内存中读出一个值得指令和一条使用该值的指令之间，流水线必须暂停一个周期；</li>
<li>处理ret：流水线必须暂停直到ret指令达到写会指令；</li>
<li>预测错误的分支：在分支逻辑发现不应该选择分支前，分支目标处的几条指令已经进入流水线了，必须取消这些指令，并从跳转指令后面那条指令开始取指；</li>
<li>异常：当一条指令异常异常，想要禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段，停止执行；</li>
</ul>
<h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6><p>所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能实现每个时钟周期发射一条新指令的目标。可以通过确定往流水线出入气泡的频率，来衡量这种损失。目标是设计每个周期发射一条指令的流水线，即CPI为1.0。</p>
<p>此外还需要：</p>
<ul>
<li>多周期指令。还需要一些更复杂操作的指令，六整数乘法和除法、以及浮点运算。这些操作的典型执行时间从浮点加法的3或4个周期到整数除法的64个周期，既需要额外的硬件来执行这些计算还需要一种机制来协调这些指令的处理与流水线其他部分之间的关系。一种简单的方法就是简单的扩展执行阶段逻辑的功能，添加一些整数和浮点算术运算单元，一条指令在执行阶段逗留所需要的多个时钟周期，导致取指、译码阶段暂停，影响性能；采用独立于主流水线的特殊硬件功能来处理较为复杂的操作，可以得到更好的性能；通常有一个功能单元来执行整数乘法和除法，还有一个来执行浮点操作，浮点单元也是流水线化得，多条指令可以在主流水线和各个单元并发执行；</li>
<li>与存储系统的接口。假设取指单元和数据内存都可以在一个时钟周期内读或是写内存中任意位置。自我修改代码中，以存储器位置的虚拟地址来引用它们，要求在执行实际的读或写操作之前，要将虚拟地址翻译成物理地址，可能所需要的值位于磁盘上，会需要上百万个时钟周期才能把数据读入到处理器内存中。<strong>典型的处理器有两个第一层高速缓存，一个用于读指令，一个用于读和写数据。另一种类型的高速缓存存储器，称为后备缓冲器TLB，提供了从虚拟地址到物理地址的快速翻译。</strong> 将TLB和高速缓存结合起来使用，大多数时候确实可能在一个时钟周期内读指令并读、或写数据。</li>
<li>虽然高速缓存保存最常引用的存储器位置，但有时还会出现不命中情况，最好情况中，可以从较高层高速缓存或处理器主存找到不命中的数据，需要3~20个时钟周期，流水线简单暂停，将指令保存在取指或访存阶段，知道高速缓存能够执行读或写操作。有些情况，被引用的存储器位置实际上是存储在磁盘存储器上。硬件会产生一个缺页page fault异常信号。访问磁盘需要几百万个时钟周期，OS缺页中断需要几百个时钟周期。</li>
</ul>
<p><strong>从处理器角度来看，将用暂停来处理短时间的高速缓存不命中和用异常处理来处理长时间缺页结合起来，能够顾及到存储器访问时由于存储器层次结构引起的所有不可预测性。</strong></p>
<h4 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5 优化程序性能"></a>5 优化程序性能</h4><p>编写高效程序需要做到：</p>
<ul>
<li>选择适当的算法和数据结构</li>
<li>编写出编译器能够有效优化以转换成高效可执行代码的源代码(理解优化编译器的能力和局限性是很重要的)</li>
<li>针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行的计算。</li>
</ul>
<h5 id="5-1-优化编译器的能力和局限性"><a href="#5-1-优化编译器的能力和局限性" class="headerlink" title="5.1 优化编译器的能力和局限性"></a>5.1 优化编译器的能力和局限性</h5><p>现代编译器用复杂精细的算法来确定一个程序中计算的是什么值，以及被如何使用的。<strong>利用一些机会简化表达式，在几个地方使用同一个计算，降低一个给定的计算必须被执行的次数。</strong> 最简单的控制就是指定优化级别，以命令行选项”-Og”调用gcc，”-O1”、”-O2”、”-O3”使用不同级别的优化。确保优化后的程序和未优化的版本有一样的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void handle1(long *xp,long *yp)</span><br><span class="line">&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line">void handle2(long *xp,long *yp)</span><br><span class="line">&#123;</span><br><span class="line">    *xp += 2* *yp</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个过程似乎有相同的行为，将存储在由指针yp指示的位置处的值两次加到指针xp指示的位置处的值。handle2更加高效，3次内存引用(读<code>*xp</code> 读<code>*yp</code> 写<code>*xp</code>),而handle1需要6次(2次读<code>*xp</code> 2次读<code>*yp</code> 2次写<code>*xp</code>)</p>
<p>但是考虑到xp等于yp的情况，handle1会将xp的值增加4倍，而handle2增加3倍。</p>
<p>这两个指针可能指向同一个内存位置的情况称为内存别名使用，在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中同一位置。</p>
<h6 id="用内联函数替换优化函数调用"><a href="#用内联函数替换优化函数调用" class="headerlink" title="用内联函数替换优化函数调用"></a>用内联函数替换优化函数调用</h6><p>包含函数调用的代码可以用一个称为内联函数替换(inline substitution)的过程进行优化。此时将函数调用替换为函数体。例如可以通过替换掉对函数f的四次调用，展开func1的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">long func1in()&#123;</span><br><span class="line">    long t = counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">替换掉</span><br><span class="line">long func()&#123;</span><br><span class="line">    return counter++</span><br><span class="line">&#125;</span><br><span class="line">long func2()&#123;</span><br><span class="line">    return func()+func()+func()+func)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的转换既减少了函数调用的开销，也允许对展开的代码做进一步优化，比如编译器可以统一func1in中对全局变量couter更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long func1opt()&#123;</span><br><span class="line">    long t = 4*coutner + 6;</span><br><span class="line">    couter+=4</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>gcc最近版本会尝试进行这种形式的优化，要么是备用命令行选项”-finline”，要么使用优化等级-O1或更高等级。gcc只尝试在单个文件中定义的函数内联，无法应用于常见情况，即一组库函数在一个文件中被定义，却被其他文件内的函数所调用。</strong></p>
<p><strong>某些情况下，最好能阻止编译器执行内联替换。一种情况是用符号调试器如GDB来评估代码，如果一个函数已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败。另一种情况是用代码剖析的方式来评估程序性能。</strong></p>
<h5 id="5-2-表示程序性能"><a href="#5-2-表示程序性能" class="headerlink" title="5.2 表示程序性能"></a>5.2 表示程序性能</h5><p>引入度量标准每个元素的周期数(cycles per element，CPE),作为一种表示程序性能并指导改进代码的方法。CPE这种度量标准能够在更细节的级别上理解迭代程序的循环性能。如处理图像中的像素、计算矩阵乘积。</p>
<p>处理器活动的顺序是由时钟控制的，时钟提供某个频率的规律信号，通常用千兆赫兹GHz，即十亿周期每秒。循环展开，每次迭代计算多个元素，有更多好处。</p>
<h5 id="5-3-消除循环的低效率"><a href="#5-3-消除循环的低效率" class="headerlink" title="5.3 消除循环的低效率"></a>5.3 消除循环的低效率</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void lower1(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    for(i=0;i&lt;strlen(s);i++)&#123;</span><br><span class="line">        toLowerCase(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lower2(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    long len = strlen(s)</span><br><span class="line">    for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">        toLowerCase(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在字符串很长的情况下，方法2的性能是方法1的50w倍。</p>
<h5 id="5-4-减少过程调用"><a href="#5-4-减少过程调用" class="headerlink" title="5.4 减少过程调用"></a>5.4 减少过程调用</h5><p>过程调用会带来开销，妨碍大多数形式的程序优化。比如循环中，每次都会调用get_vec_element来获取下一个向量元素，对每个向量引用，这个函数要把向量索引i与循环边界作比较，很明显很低效。将其改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void combine3(vec_ptr v,data_t *dest)&#123;</span><br><span class="line">    long i;</span><br><span class="line">    long length=get_vec_start(v);</span><br><span class="line">    *dest=IDENT;</span><br><span class="line">    for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">        *dest=*dest op data[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>性能没有明显提升，整数求和性能还略有下降，显然内循环中其他操作形成了瓶颈，限制性能超过调用get_vec_element。为什么反复的边界检查反而不会让性能更差。</p>
<h5 id="5-5-消除不必要的内存引用"><a href="#5-5-消除不必要的内存引用" class="headerlink" title="5.5 消除不必要的内存引用"></a>5.5 消除不必要的内存引用</h5><p>在combine3的代码块中，指针dest的地址存放在寄存器中，将低i个数据元素的指针保存在寄存器中，每次迭代这个指针加8.循环终止操作通过比较这个指针与保存在寄存器中的数值来判断。<strong>每次迭代，累积变量的数值都要从内存读出再写入到内存。这样的读写很浪费，每次迭代开始开始时要从内存读出再写到内存。因为每次迭代开始时从dest读出的值就是上次迭代最后写入的值。</strong></p>
<p>可以消除这种不必要的内存读写，按照下面方式重写代码，引入一个临时变量acc，在循环中用来累计计算出来的值。循环完才存放在dest中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void combine4(vec_ptr v,data_t *dest)&#123;</span><br><span class="line">    long i;</span><br><span class="line">    long length =vec_length(v);</span><br><span class="line">    data_t *data = get_vect_start(v);</span><br><span class="line">    data_t acc=IDENT;</span><br><span class="line">    for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">        acc=acc op data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest=acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么编译器不会自动将combine3优化为combine4那种呢，因为可能存在内存别名这种情况。</p>
<h5 id="5-6-理解现代处理器"><a href="#5-6-理解现代处理器" class="headerlink" title="5.6 理解现代处理器"></a>5.6 理解现代处理器</h5><p>当一系列操作必须按照严格顺序执行时，会遇到延迟界限latency bound。还有吞吐量界限。</p>
<h5 id="5-6-1-整体操作"><a href="#5-6-1-整体操作" class="headerlink" title="5.6.1 整体操作"></a>5.6.1 整体操作</h5><p>超标量CPU架构是指在一颗处理器内核实行了指令级并行的一类并行运算，每个时钟周期执行多个操作，而且是乱序的，指令的执行顺序不一定与它们在机器级程序中的顺序一致，在相同的CPU主频下实现更高的CPU吞吐率。</p>
<p>整个设计有两个主要部分：指令控制单元ICU和执行单元EU。前者负责从内存读出指令序列，并根据这些指令序列生成一组针对数据的基本操作；后者执行这些操作。</p>
<p><strong>乱序处理器需要更大、更复杂的硬件，但是能更好的达到更高的指令级并行度。</strong></p>
<p>ICU从高速缓存读取指令，指令高速缓存是一个特殊的高速存储器，包含最近访问的指令。通常ICU会在当前正在执行的指令很早之前取指，这样才有足够时间对指令译码，并把操作发给EU。当程序遇到分支，处理器采用一种分支预测branch prediction的技术，处理器会猜测是否选择分支，同时还预测分支的目的地址，使用投机执行speculative execution技术。</p>
<p>指令译码接收实际的程序指令，将其转换成一组基本操作(微操作)，每个这样的操作都完成某个简单的计算任务(两个数相加，从内存读数据或是想内存写数据)。EU接收来自取指单元的操作，每个时钟周期会接收多个操作。这些操作会被分派到一组功能单元中，会执行实际的操作，这些功能单元专门用来处理不同类型的操作。</p>
<p>读写内存由加载和存储单元实现的，这个单元有一个加法器来完成地址计算。类似存储单元处理器写数据到内存的操作。加载和存储单元通过数据高速缓存data cache来访问内存，数据高速缓存是一个高速存储器，存放着最近访问的数据值。</p>
<h5 id="5-7-循环展开"><a href="#5-7-循环展开" class="headerlink" title="5.7 循环展开"></a>5.7 循环展开</h5><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量。减少了操作数量，如循环索引计算和条件分支；第二提供了一些方法，进一步变化代码，减少整个计算中关键路径上操作数量。</p>
<h5 id="5-8-提高并行性"><a href="#5-8-提高并行性" class="headerlink" title="5.8 提高并行性"></a>5.8 提高并行性</h5><p>程序的性能是受运算单元的延迟限制的，执行加法和乘法的功能单元是完全流水线化的，每个时钟周期开始一个新操作，并且有些操作可以被多个功能单元执行。<strong>硬件具有以更高速率执行乘法和加法的潜力，但是代码不能利用这种能力，即使是使用循环展开也不能。</strong></p>
<h5 id="5-9-1-多个累积变量"><a href="#5-9-1-多个累积变量" class="headerlink" title="5.9.1 多个累积变量"></a>5.9.1 多个累积变量</h5><p>对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。例如：<br><code>$P_n$</code>表示元素<code>$a_0,a_1,...,a_{n-1}$</code>的乘积:<code>$P_n=\prod_{i=0}^{n-1}a_i$</code>假设n为偶数，还可以将其写为<code>$P_n=PE_n*PO_n$</code>，这里<code>$PE_n$</code>是索引值为偶数的元素的积，<code>$PO_n$</code>是奇数的元素的乘积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;limit;i+=2)&#123;</span><br><span class="line">    acc0=acco op data[i];</span><br><span class="line">    acc1=acc1 op data[i+1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既使用了两次循环展开，也使用了两路并行，将其称为2x2循环展开。可以将多个累积变量变换归纳为展开k次，以及并行累积k个值，得到kxk循环展开。</p>
<h5 id="5-9-2-重新结合变换"><a href="#5-9-2-重新结合变换" class="headerlink" title="5.9.2 重新结合变换"></a>5.9.2 重新结合变换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acc = (acc op data[i]) op data[i+1];</span><br><span class="line">acc = acc op (data[i] op data[i+1])</span><br></pre></td></tr></table></figure>
<p>下面这条更加高效，在执行重新结合变换时，又一次改变向量元素合并顺序，但是浮点数可能会出问题。总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好的利用功能单元的流水线能力获得更好的性能，大多数编译器不会尝试对浮点运算做重新结合，因为这些运算不保证是可结合的。<strong>每次迭代的第一个乘法都不需要等待前一次迭代的累计值就可以执行，最小可能的CPE减少了2倍。</strong></p>
<h6 id="用向量指令达到更高的并行度"><a href="#用向量指令达到更高的并行度" class="headerlink" title="用向量指令达到更高的并行度"></a>用向量指令达到更高的并行度</h6><p>intel99年引入SSE指令(streaming SIMD Extensions)流SIMD扩展。SSE功能经历几代，最新的版本为高级向量扩展advanced vector extension或AVX。SIMD执行模型是用单条指令对整个向量数据进行操作。这些向量保存在一组特殊的向量寄存器中，目前AVX向量寄存器长为32字节，因此每一个都可以存放8个32位数或4个64位数，AVX可以并行执行8组数值或4组数值的加法或乘法。</p>
<h5 id="5-10-优化合并代码的结果小结"><a href="#5-10-优化合并代码的结果小结" class="headerlink" title="5.10 优化合并代码的结果小结"></a>5.10 优化合并代码的结果小结</h5><p>使用多项优化技术，CPE已经接近于0.5和1.0吞吐量界限，只受限于功能单元的容量，重写代码利用较新的SIMD指令得到了将近4倍或8倍的性能，比如单精度乘法，CPE从11.14降到了0.06，整体性能提升超过180倍。</p>
<h5 id="5-11-一些限制因素"><a href="#5-11-一些限制因素" class="headerlink" title="5.11 一些限制因素"></a>5.11 一些限制因素</h5><ul>
<li>寄存器溢出。循环并行性的好处手汇编代码描述计算能力限制，如果并行度p超过了可用寄存器数量，那么编译器会溢出，将某些值放到内存中，通常是在运行时堆栈上分配空间。</li>
<li>分支预测和预测错误处罚。分支预测错误会丢弃掉所有投机执行的结果，预测错误处罚是19个时钟周期。不要过分关心可预测分支；写适合用条件传送实现的代码。程序中许多测试是完全不可预测的，依赖数据的任意特性，例如一个数是负数还是正数，对于这些测试，分支预测逻辑会处理的很糟糕。如果编译器能产生使用条件数据传送而不是条件控制转移，可以极大提高程序性能。</li>
</ul>
<h5 id="5-12-理解内存性能"><a href="#5-12-理解内存性能" class="headerlink" title="5.12 理解内存性能"></a>5.12 理解内存性能</h5><h5 id="5-12-1-加载的性能"><a href="#5-12-1-加载的性能" class="headerlink" title="5.12.1 加载的性能"></a>5.12.1 加载的性能</h5><p>一个包含加载操作的程序性能既依赖于流水线能力，也依赖于加载单元的延迟。<strong>除了使用SIMD操作时以外，对任何数据类型组合和合并操作来说，CPE没有到过0.5以下。一个制约示例的CPE因素是，对于每个被计算的元素，所有示例都需要从内存读一个值，所以CPE不可能小于0.5。对于每个被计算的元素必须加载k个值的应用，不可能获得低于k/2的CPE。</strong></p>
<h5 id="5-12-2-存储的性能"><a href="#5-12-2-存储的性能" class="headerlink" title="5.12.2 存储的性能"></a>5.12.2 存储的性能</h5><p>目前分析了大部分内存引用都是加载操作数的函数，即从内存位置读到寄存器中，与之对应是存储操作，将一个寄存器值写到内存。与加载操作一样，大多情况存储操作能够在完全流水线化的模式中工作，每个周期开始一条新的存储。</p>
<p>存储操作并不影响任何寄存器值，因此一系列存储操作不会产生数据相关。只有加载操作会受存储操作结果的影响，只有加载操作从存储操作写到那个位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void write_read(long *src,long *dst,long n)&#123;</span><br><span class="line">    long cnt =n;</span><br><span class="line">    long val =0;</span><br><span class="line">    while(cnt)&#123;</span><br><span class="line">        *dst=val;</span><br><span class="line">        val=(*src)+1;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用write_read(&amp;a[0],&amp;a[0],3)参数src和dest都指向数组元素a[0]的指针，这种情况指针引用<em>src每次加载都会得到指针引用</em>dest的前次执行存储的值。这种现象就是写/读相关，一个内存读的结果依赖最近的内存写。</p>
<p>会发现这种方法比调用write_read(&amp;a[0],&amp;a[1],3)慢6个时钟周期。</p>
<p>存储单元包含一个存储缓冲区，包含已经被发射到存储单元而又还没有完成的存储操作的地址和数据，<strong>包括更新数据高速缓存。提供这样一个缓冲区，使得一系列存储操作不必等待每个操作都更新高速缓存就能执行。当一个加载操作发生，必须检查存储缓冲区中的条目，看有没有地址匹配</strong>。如果有地址匹配，就取出相应的数据条目作为加载操作结果。<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/95E079DB5923452283675415CA1A9691/29061" alt="image"></p>
<h5 id="5-13-性能提高技术"><a href="#5-13-性能提高技术" class="headerlink" title="5.13 性能提高技术"></a>5.13 性能提高技术</h5><ul>
<li>高级设计。为问题选择合适的算法和数据结构，避免那些会渐进产生糟糕性能的算法或编码技术；</li>
<li>基本编码原则。消除连续函数调用：将计算移到循环外；消除不必要内存引用：引入临时变量保存中间结果，只有在最后的值计算出来，才将结果存放到数组或全局变量中；</li>
<li>低级优化。结构化代码利用硬件性能。展开循环，降低开销，使进一步优化成为可能；通过使用多个累积变量、重新结合等技术提供指令级并行；用功能性风格重写条件操作，使得编译采用条件数据传送；</li>
</ul>
<h5 id="5-14-确认和消除性能瓶颈"><a href="#5-14-确认和消除性能瓶颈" class="headerlink" title="5.14 确认和消除性能瓶颈"></a>5.14 确认和消除性能瓶颈</h5><h5 id="5-14-1-程序剖析"><a href="#5-14-1-程序剖析" class="headerlink" title="5.14.1 程序剖析"></a>5.14.1 程序剖析</h5><p>unix系统提供一个剖析程序GPROF，产生两种形式信息，确定程序每个函数花费多少CPU时间，计算每个函数调用次数。</p>
<p>GPROF值得注意的几个点：</p>
<ul>
<li>计时不是很准确。计时基于一个简单的间隔计数机制，编译过的程序为每个函数维护一个计数器。</li>
<li>假设没有执行内联替换，则调用信息相当可靠；</li>
<li>默认情况，不会显示对库函数的计时，相反库函数的时间都被计算到调用它们的函数时间中；</li>
</ul>
<h4 id="6、存储器层次结构"><a href="#6、存储器层次结构" class="headerlink" title="6、存储器层次结构"></a>6、存储器层次结构</h4><p>访问CPU寄存器中的数据，在0个周期内就能访问；存储在高速缓存中，需要4-75个周期；存储在主存中，需要上百个周期；存储在磁盘上，需要几千万个周期。围绕着计算机程序<strong>局部性</strong>进行讨论。基本存储技术-SRAM存储器、DRAM存储器、ROM存储器以及旋转和固态的硬盘，如何被组织成层次结构。高速缓存存储器，作为CPU和主存之间的缓存区域，对应用程序性能影响最大。一种描绘某台机器上存储器层次结构的性能的有趣方法：<strong>存储器山</strong>，展示出读访问时间是局部性的一个函数。</p>
<h5 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h5><h5 id="6-1-1-随机访问存储器"><a href="#6-1-1-随机访问存储器" class="headerlink" title="6.1.1 随机访问存储器"></a>6.1.1 随机访问存储器</h5><p>随机访问存储器RAM分为两类，静态、动态。静态RAM(SRAM)比DRAM快，更贵，SRAM用作高速缓存存储器，既可以在cpu芯片上，也在芯片外。DRAM用来作为主存以及图形系统的帧缓冲区。SRAM只要保持通电，里面储存的数据就可以恒常保持，DRAM存储的数据需要周期性更新。<br>内存模块：DRAM封装在内存模块中，插到主板的扩展槽上。通过将多个内存模块连接到内存控制器，能够聚合成主存。</p>
<h6 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h6><p>断电DRAM和SRAM会丢失信息，非易失性存储器断电后仍能保持信息。ROM(read-only memory)可以读写，但是整体上都被称为只读存储器，以它们能够被重变成(写)的次数和它们进行重变成所用的机制来区分的。</p>
<h6 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h6><p>数据流通过称为总线bus的共享电子电路在处理器和DRAM主存之间传递。每次CPU和主存间的数据传递都是通过一系列步骤完成，这些步骤称为<strong>总线事务</strong>。读事务read transaction从主存传送数据到CPU，写事务write transaction从CPU传送数据到主存。</p>
<p>总线是一组并行的导线，能携带地址、数据和控制信号，取决于总线设计，数据和地址信号可以共享同一组导线，也可以使用不同的导线。</p>
<p>同时两个以上设备也能共享同一总线，控制线携带的信号会同步事务，并标识当前正在被执行的事务的类型，并标识出当前正在被执行的事务类型。如当前关注的这个事务是到主存的么，还是到磁盘控制器这样的I/O设备，这个事务是读还是写，总线上是地址还是数据。</p>
<p>读事务：1）CPU将地址A放到系统总线上，I/O桥将信号传递到内存总线。I/O桥将信号传递到内存总线；2）主存拿到内存总线信号，从内存读取地址，从DRAM取出数字，将数据写到内存总线，IO桥将内存总线信号翻译成系统总线信号，然后沿着系统总线传递3）cpu拿到总线数据，复制到寄存器</p>
<h6 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h6><p>从磁盘访问数据是毫秒级，比DRAM慢10万倍，比SRAM慢100万倍。磁盘也成为旋转磁盘，使之区别与基于闪存的固定硬件SSD(没有移动部分)。</p>
<p>CPU使用一种称为内存映射I/O的技术向I/O设备发射命令，在使用内存映射I/O系统中，地址空间中有一块地址是为与I/O设备通信保留的。</p>
<p>CPU发出请求后，在磁盘执行读的时候，通常还会做其他事情。设备可以自己执行读或写总线事务不需要CPU干涉过程，称为直接内存访问DMA。DMA传送完成后，磁盘扇区的内容被安全存储在主存中，磁盘控制器通过给CPU发送一个中断信号来通知CPU。</p>
<h6 id="固定硬盘"><a href="#固定硬盘" class="headerlink" title="固定硬盘"></a>固定硬盘</h6><p>固态硬盘是一种基于闪存的存储技术，读SSD比写要快，随机读和写的性能差别是由底层闪存基本属性决定的。随机写很慢的原因：</p>
<ul>
<li>擦除块需要相对较长时间，1ms级的，比访问页高一个数量级。</li>
<li>写操作试图修改一个包含已经有数据的页p，那么这个块中所有带有用数据的页都必须被复制到一个新块，然后才能进行对页p的写。</li>
</ul>
<p>SSD优点：由半导体存储器构成，没有移动部件，因而随机访问时间比旋转磁盘块，能耗低。缺点：反复写之后，闪存块会磨损。</p>
<p>21世纪初计算机制造商遇上能量墙power wall，无法迅速增加cpu频率，否则芯片功耗太大，解决方法用多个小处理器核取代单个大处理器。每个完整处理器能够独立、与其他核并行执行程序。这种多核方法部分有效，因为一个处理器功耗正比于<code>$P=fCv^2$</code>，f是时钟频率，C是电容，v是电压。计算机越来越快，不是因为时钟频率增加，而是因为每个处理器核数增加。</p>
<h6 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h6><p>局部性包括时间局部性和空间局部性。硬件层局部性原理允许计算机设计者通过引入称为高速缓存存储器的小而快的存储器来保存最近被引用的指令和数据项，从而提高对主存访问速度。</p>
<h6 id="6-2-1-对程序数据引用的局部性"><a href="#6-2-1-对程序数据引用的局部性" class="headerlink" title="6.2.1 对程序数据引用的局部性"></a>6.2.1 对程序数据引用的局部性</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sumvec(int v[N])&#123;</span><br><span class="line">   int i,sum = 0;</span><br><span class="line">   for(i=0;i&lt;N;i++)&#123;</span><br><span class="line">       sum+=v[i];</span><br><span class="line">   &#125;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum每次循环迭代中被引用一次，sum有很好局部性，因为sum是标量，没有空间局部性。v有很好空间局部性，没有好的时间局部性。</p>
<h6 id="6-2-2-取指令的局部性"><a href="#6-2-2-取指令的局部性" class="headerlink" title="6.2.2 取指令的局部性"></a>6.2.2 取指令的局部性</h6><p>程序指令存放在内存中，CPU必须取出这些指令。for循环体里的指令按连续的内存顺序执行，具有良好空间局部性，循环体会被执行多次，具有很好时间局部性。</p>
<p>代码区别于程序数据一个重要属性是运行时不能被修改，程序正在执行时，cpu只从内存中读出指令，cpu很少重写这些指令。</p>
<p>局部性原则：</p>
<ul>
<li>重复引用相同变量的程序有良好的时间局部性；</li>
<li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好；</li>
<li>对于取指令，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多局部性越好；</li>
</ul>
<h6 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h6><h6 id="6-3-1-存储器层次结构中的缓存"><a href="#6-3-1-存储器层次结构中的缓存" class="headerlink" title="6.3.1 存储器层次结构中的缓存"></a>6.3.1 存储器层次结构中的缓存</h6><p>高速缓存cache是一个快速存储设备，作为存储在更大更慢的设备中的数据对象缓冲区域。存储器中心思想：<strong>对于每个k，位于k层的更快更小的存储设备作为位于k+1层更大更慢的存储设备的缓存。</strong> 数据总是以块大小为传送单元在k层和第k+1层来回复制。L1和L0传送通常使用1个字大小的块，L2和L1之间几十字节。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存什么</th>
<th>缓存在何处</th>
<th>延迟</th>
<th>由谁管理</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td>4字节或8字节</td>
<td>芯片cpu寄存器</td>
<td>0</td>
<td>编译器</td>
</tr>
<tr>
<td>TLB</td>
<td>地址翻译</td>
<td>芯片上TLB</td>
<td>0</td>
<td>硬件MMU</td>
</tr>
<tr>
<td>L1高速缓存</td>
<td>64字节块</td>
<td>芯片上L1高速缓存</td>
<td>4</td>
<td>硬件</td>
</tr>
<tr>
<td>L2高速缓存</td>
<td>64字节块</td>
<td>芯片上L1高速缓存</td>
<td>10</td>
<td>硬件</td>
</tr>
<tr>
<td>L3高速缓存</td>
<td>64字节块</td>
<td>芯片上L1高速缓存</td>
<td>50</td>
<td>硬件</td>
</tr>
<tr>
<td>虚拟内存</td>
<td>4KB页</td>
<td>主存</td>
<td>200</td>
<td>硬件+OS</td>
</tr>
<tr>
<td>缓冲区缓存</td>
<td>部分文件</td>
<td>主存</td>
<td>200</td>
<td>OS</td>
</tr>
<tr>
<td>磁盘缓存</td>
<td>磁盘扇区</td>
<td>磁盘控制器</td>
<td>10 0000</td>
<td>控制器固件</td>
</tr>
<tr>
<td>网络缓存</td>
<td>部分文件</td>
<td>本地磁盘</td>
<td>1000 0000</td>
<td>NFS客户</td>
</tr>
</tbody>
</table>
<h6 id="6-4-1-通用高速缓存存储器结构"><a href="#6-4-1-通用高速缓存存储器结构" class="headerlink" title="6.4.1 通用高速缓存存储器结构"></a>6.4.1 通用高速缓存存储器结构</h6><p>主存由一个个字块组成，每个字块包含N个字，主存的地址包含两部分，一部分用来寻找某个字块，另一部分用来寻找该字块中的字或字节，主存地址高m位表示主存块地址，低b位表示其块内的字或字节,<code>$2^m=M$</code>表示主存总块数，主存向cache迁移数据以line size为单位替换。cache容量远小于主存，不能一一对应，每个存储器地址有m位，形成<code>$M=2^m$</code>个不同的地址，这样一个机器高速缓存被组织成一个有<code>$S=2^s$</code>个高速缓存组,每个组包含E个高速缓存航cache line，每行由一个<code>$B=2^b$</code>字节的数据块组成，一个有效位指明这行是否包含有意义的信息，还有t=m-b-s个标记位，唯一标识存储在这个高速缓存行中的块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址： t位   s位     b位</span><br><span class="line">      标记  组索引  块偏移</span><br></pre></td></tr></table></figure></p>
<p>高速缓存(S,E,B,m)，每个组包含一个或多行，每行包含一个有效位，一些标记位，以及一个数据块。高速缓存将m个地址划分成了t个标记位，s个组索引和b个块偏移。</p>
<h6 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h6><p>根据每个组的高速缓存行数E，高速缓存被分为不同类。每个组只有一行E=1被称为直接映射高速缓存direct-mapped cache，这是最容易实现和理解的。缓存匹配分三步：1）组选择；2）行匹配；3）字抽取</p>
<ul>
<li>直接映射高速缓存中的组选择，高速缓存从w的地址中间抽取s个组索引位，对应于一个组号的无符号整数。如果把高速缓存看成一个关于组的一维数组，那么这些组索引就是一个到这个数组的索引；</li>
<li>直接映射高速缓存中的行匹配；已经选择了某个组i，假如高速缓存中的标记位与地址中的标记位匹配，则命中</li>
<li>直接映射cache中的字选择，知道w在这个块某个地方，最后一步确定所需要的字在块中是从哪里开始的。块偏移提供了所需要的字第一个字节的偏移。cache看成一个行的数组，块看成一个字节的数组，字节偏移就是到这个数组的一个索引。</li>
<li>直接映射cache不命中时的行替换。如果缓存不命中，需要从存储器下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。</li>
<li>运行中的直接映射高速缓存。硬件要在几纳秒内完成。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组号 [有效位 标记位 块0 块1 ...]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为什么用中间的位来做索引？<br><br>如果高位用作索引，那么一些连续内存块就会映射到相同的高速缓存块，导致对局部性支持的不够好。</p>
<h6 id="6-4-2-直接映射"><a href="#6-4-2-直接映射" class="headerlink" title="6.4.2 直接映射"></a>6.4.2 直接映射</h6><p>E=1的情况就是全相连映射，假如cache有8行即8块，主存256行，<code>$i=j mod c$</code>，i为cache块号，j为主存块号，C为cache块号。</p>
<ul>
<li>优点：实现简单，只需要利用主存地址的某些位直接判断，即可确定所需字块是否在cache中；</li>
<li>缺点：1）不够灵活，每个主存块只能固定的对应某个cache块，即使cache内还空着许多位置不能占用，不能充分利用；  2）冲突率高。某个块频繁进行交换。</li>
</ul>
<p>应用场合：适合大容量cache。</p>
<h6 id="6-4-2-全相连映射"><a href="#6-4-2-全相连映射" class="headerlink" title="6.4.2 全相连映射"></a>6.4.2 全相连映射</h6><p>全相连映射允许主存每个字块映射到cache任何一块的位置上。比如主存256个内存块，cache需要8位<code>$2^8=256$</code>来作为标记位。因为直接映射只需要识别组号，只需要5位作为标记位，主存256是cache的32倍，<code>$2^5=32$</code>.</p>
<ul>
<li>优点：1）全相连映射允许主存每一字块映射到cache任何一字块，cache命中率可以提高；2）减少了块的冲突率，提高了cache利用率；</li>
<li>缺点：tag位增加了，访问cache时主存字块标记需要和cache的全部标记进行比较，才能判断所访问的主存地址内容是否在cache内，这种比较通常采用按内容寻址的相连存储器来完成。适用于小容量的cache。</li>
</ul>
<p>全相连高速缓存只适合做小的高速缓存，例如虚拟内存系统中TLB。</p>
<h6 id="6-4-3-组组相连映射"><a href="#6-4-3-组组相连映射" class="headerlink" title="6.4.3 组组相连映射"></a>6.4.3 组组相连映射</h6><p>是对直接映射和全相连映射的一种折中，假设cache分为Q组，每组R块，<code>$i=j mod Q$</code>,i是cache组号，j为主存块号，Q为cache组数，将主存第j块内容复制到cache第i组，至于是第i组哪一块，可以随意放。当cache有4组，主存有256块，256/4=64，需要6位tag区分是哪个组。</p>
<p>组相连只有一组，此时组相连就等同于全相连映射，每组只有一块，此时组相连就等同于直接映射。</p>
<h6 id="6-4-4-写"><a href="#6-4-4-写" class="headerlink" title="6.4.4 写"></a>6.4.4 写</h6><p>高速缓存读操作很简单，在cache中查找所需字w的副本，命中立刻返回cpu。写的情况更复杂一些。</p>
<ul>
<li>直写write-through【全写】。写命中时怎么更新w在层次结构中低一层中的副本，，立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。</li>
<li>写回write back。尽可能会推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。由于局部性，能显著减少总线流量，缺点是增加了复杂性，高速缓存必须为每个高速缓存行维护一个额外的修改位dirty bit，表明这个高速缓存块是否被修改过。</li>
<li>写一次法。仅仅第一次写命中时要同时写回低一层。</li>
</ul>
<h6 id="如何处理写不命中"><a href="#如何处理写不命中" class="headerlink" title="如何处理写不命中"></a>如何处理写不命中</h6><ul>
<li>写分配write-allocate。加载相应的低一层中的块到高速缓存，然后更新这个高速缓存块。写分配利用写的空间局部性，缺点是每次不命中都会导致一个块从低一层传到高速缓存。</li>
<li>非写分配。避开高速缓存，直接把这个字写到低一层，直写高速缓存通常是非写分配的，写回高速缓存通常是写分配的。</li>
</ul>
<p><strong>建议采用一个使用写回和写分配的高速缓存模型。通常由于较长的传送时间，存储器层次结构中较低层的缓存更可能使用写回；例如虚拟存储系统只使用写，由于逻辑电路密度提高，写回的高复杂性不成为阻碍；使用写回写分配试图利用局部性，展示良好的空间和时间局部性，而不试图为某个存储器系统进行优化。</strong></p>
<h6 id="6-4-5-高速缓存层次结构"><a href="#6-4-5-高速缓存层次结构" class="headerlink" title="6.4.5 高速缓存层次结构"></a>6.4.5 高速缓存层次结构</h6><p>只保存指令的高速缓存称为i-cache,只保存程序数据的高速缓存称为d-cache。两者都保存的cache称为统一高速缓存。两个独立高速缓存，能同时读一个指令字和一个数据字。i-cache通常是只读的。通常会针对不同的访问模式来优化这两个高速缓存，可以有不同的块大小、相联度和容量。使用不同的高速缓存也确保数据访问不会与指令访问形成冲突不命中，反过来代价可能会引起容量不命中增加。</p>
<p>intel core i7每个cpu有4个核，每个核有自己私有的L1 i-cache、L1 d-cache和L2统一高速缓存，所有核共享片上L3统一的高速缓存，这个层次结构一个有趣特性是所有SRAM高速缓存存储器都在CPU芯片上。</p>
<table>
<thead>
<tr>
<th>高速缓存类型</th>
<th>访问时间</th>
<th>大小</th>
<th>相联度</th>
<th>块大小B</th>
<th>组数S</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1 i-cache</td>
<td>4</td>
<td>32KB</td>
<td>8</td>
<td>64B</td>
<td>64</td>
</tr>
<tr>
<td>L1 d-cache</td>
<td>4</td>
<td>32KB</td>
<td>8</td>
<td>64B</td>
<td>64</td>
</tr>
<tr>
<td>L2统一高速缓存</td>
<td>10</td>
<td>256KB</td>
<td>8</td>
<td>64B</td>
<td>512</td>
</tr>
<tr>
<td>L3统一高速缓存</td>
<td>40-75</td>
<td>8MB</td>
<td>16</td>
<td>64B</td>
<td>8192</td>
</tr>
</tbody>
</table>
<p>几个影响因素：</p>
<ul>
<li>cache大小。较大可能会提高命中率，但是会增加命中时间。</li>
<li>块大小影响。大的块能利用程序中可能存在的空间局部性，帮助提高命中率。对于给定高速缓存大小，块越大意味高速缓存行数越少，损害时间局部性比空间局部性更好的命中率。较大块对不命中处罚也有负面影响，块越大，传送时间越长；</li>
<li>相联度影响。E是每个组中高速缓存行数。较高相联度优点是降低了cache由于冲突不命中出现抖动的可能性。较高的相联度造成较高的成本，实现起来很昂贵，很难使之速度较快。每行需要记录更多标记位，需要额外的LRU状态位和控制逻辑。增加命中时间。<strong>相联度最终成了命中时间和不命中处罚间的折中，传统上，努力争取时钟频率的高性能系统会为L1cache选择较低的相联度，而在不命中处罚比较高的较低层上使用较小的相联度。i7中l1和l2是8路组相联，L3是16路组相联</strong></li>
<li>写策略。直写cache比较容易实现，能使用独立于cache的写缓冲区write buffer，用来更新内存。读不命中开销没这么大，不会触发内存写。写回高速缓存引起的传送比较少，允许更多的内存的带宽用于执行DMA的IO设备。越往层次结构下层走，传送时间增加，减少传送数量更重要，高速缓存越往下层，越可能使用写回而不是直写。</li>
</ul>
<p>高速缓存行、组、块的区别</p>
<ul>
<li>块是固定大小信息包，在cache和主存之间来回传送</li>
<li>行是cache一个容器，存储快及其他信息(有效位 标记位)</li>
<li>组是一个或多个行的集合，直接映射cache中的组只有一行组成</li>
</ul>
<h6 id="6-5-编写高速缓存友好的代码"><a href="#6-5-编写高速缓存友好的代码" class="headerlink" title="6.5 编写高速缓存友好的代码"></a>6.5 编写高速缓存友好的代码</h6><p>局部性比较好的程序更容易有较高的命中率，更应该试着编写高速缓存友好的代码。</p>
<ul>
<li>注意力集中在核心函数的循环上；</li>
<li>尽量减小每个循环内部的缓存不命中数量。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/02/趣题2/" rel="next" title="数据密集型应用">
                <i class="fa fa-chevron-left"></i> 数据密集型应用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/16/系统上运行程序/" rel="prev" title="计算机系统(2)">
                计算机系统(2) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hecy</p>
              <p class="site-description motion-element" itemprop="description">dreamer</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/hecyxy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hcy_xy@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-gmail"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一部分-了解计算机系统"><span class="nav-number">1.</span> <span class="nav-text">第一部分 了解计算机系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-信息就是位-上下文"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 信息就是位+上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-程序被其他程序翻译成不同格式"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 程序被其他程序翻译成不同格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-了解编译系统"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 了解编译系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-系统的硬件组成"><span class="nav-number">1.4.</span> <span class="nav-text">1.4.1 系统的硬件组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-运行hello程序"><span class="nav-number">1.5.</span> <span class="nav-text">1.4.2 运行hello程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-高速缓存"><span class="nav-number">1.6.</span> <span class="nav-text">1.5 高速缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-存储设备形成层次结构"><span class="nav-number">1.7.</span> <span class="nav-text">1.6 存储设备形成层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-操作系统管理硬件"><span class="nav-number">1.8.</span> <span class="nav-text">1.7 操作系统管理硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-1-进程"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.7.1 进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-2-线程"><span class="nav-number">1.8.2.</span> <span class="nav-text">1.7.2 线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-3-虚拟内存"><span class="nav-number">1.8.3.</span> <span class="nav-text">1.7.3 虚拟内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-4-文件"><span class="nav-number">1.8.4.</span> <span class="nav-text">1.7.4 文件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-系统之间利用网络通信"><span class="nav-number">1.9.</span> <span class="nav-text">1.8 系统之间利用网络通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-重要主题"><span class="nav-number">1.10.</span> <span class="nav-text">1.9 重要主题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-1-Amdahl定律-阿姆达尔定律"><span class="nav-number">1.10.1.</span> <span class="nav-text">1.9.1 Amdahl定律 阿姆达尔定律</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-2-并发和并行"><span class="nav-number">1.10.2.</span> <span class="nav-text">1.9.2 并发和并行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线程级并发"><span class="nav-number">1.10.3.</span> <span class="nav-text">1.线程级并发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-指令级并行"><span class="nav-number">1.10.4.</span> <span class="nav-text">2.指令级并行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-单指令、多数据并行"><span class="nav-number">1.10.5.</span> <span class="nav-text">3.单指令、多数据并行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-3-计算机系统中的抽象"><span class="nav-number">1.10.6.</span> <span class="nav-text">1.9.3 计算机系统中的抽象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二部分-程序结构和执行"><span class="nav-number">2.</span> <span class="nav-text">第二部分 程序结构和执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-信息的表示和处理"><span class="nav-number">3.</span> <span class="nav-text">2.1 信息的表示和处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-寻址和字节顺序"><span class="nav-number">3.1.</span> <span class="nav-text">2.1.3 寻址和字节顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章-程序的机器级表示"><span class="nav-number">4.</span> <span class="nav-text">第三章 程序的机器级表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-机器级代码"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 机器级代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-访问信息"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 访问信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-操作数指示符"><span class="nav-number">4.2.1.</span> <span class="nav-text">3.2.1 操作数指示符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-数据传送指令"><span class="nav-number">4.3.</span> <span class="nav-text">3.2.2 数据传送指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-算术和逻辑操作"><span class="nav-number">4.4.</span> <span class="nav-text">3.2.3 算术和逻辑操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-控制"><span class="nav-number">4.5.</span> <span class="nav-text">3.3 控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-条件码"><span class="nav-number">4.5.1.</span> <span class="nav-text">3.3.1 条件码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-访问条件码"><span class="nav-number">4.5.2.</span> <span class="nav-text">3.3.2 访问条件码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-访问条件码"><span class="nav-number">4.5.3.</span> <span class="nav-text">3.3.3 访问条件码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-4-用条件传送来实现条件分支"><span class="nav-number">4.5.4.</span> <span class="nav-text">3.3.4 用条件传送来实现条件分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么基于数据传送的代码比基于条件控制转移的代码性能好"><span class="nav-number">4.5.5.</span> <span class="nav-text">为什么基于数据传送的代码比基于条件控制转移的代码性能好</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#如何确定分支预测错误处罚"><span class="nav-number">4.5.5.1.</span> <span class="nav-text">如何确定分支预测错误处罚</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#switch语句"><span class="nav-number">4.5.5.2.</span> <span class="nav-text">switch语句</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#过程"><span class="nav-number">4.5.6.</span> <span class="nav-text">过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-1-运行时栈"><span class="nav-number">4.5.6.1.</span> <span class="nav-text">3.4.1 运行时栈</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-2-转移控制"><span class="nav-number">4.5.6.2.</span> <span class="nav-text">3.4.2 转移控制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-3-数据传送"><span class="nav-number">4.5.6.3.</span> <span class="nav-text">3.4.3 数据传送</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-4-数据传送"><span class="nav-number">4.5.6.4.</span> <span class="nav-text">3.4.4 数据传送</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-5-寄存器中的局部存储空间"><span class="nav-number">4.5.6.5.</span> <span class="nav-text">3.4.5 寄存器中的局部存储空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-6-递归过程"><span class="nav-number">4.5.6.6.</span> <span class="nav-text">3.4.6 递归过程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-数组分配和访问"><span class="nav-number">4.5.7.</span> <span class="nav-text">3.5 数组分配和访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-异质的数据结构"><span class="nav-number">4.5.8.</span> <span class="nav-text">3.6 异质的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#3-6-2-数据对齐"><span class="nav-number">4.5.8.1.</span> <span class="nav-text">3.6.2 数据对齐</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-机器级程序中将控制与数据结合起来"><span class="nav-number">4.5.9.</span> <span class="nav-text">3.7 机器级程序中将控制与数据结合起来</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#内存越界引用和缓冲区溢出"><span class="nav-number">4.5.9.1.</span> <span class="nav-text">内存越界引用和缓冲区溢出</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对抗缓冲区溢出攻击"><span class="nav-number">4.5.10.</span> <span class="nav-text">对抗缓冲区溢出攻击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#支持边长栈帧"><span class="nav-number">4.5.11.</span> <span class="nav-text">支持边长栈帧</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-处理器体系结构"><span class="nav-number">4.6.</span> <span class="nav-text">4 处理器体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-逻辑设计和硬件控制语言HCL"><span class="nav-number">4.6.1.</span> <span class="nav-text">4.1 逻辑设计和硬件控制语言HCL</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#4-1-1-逻辑门"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">4.1.1 逻辑门</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-1-2-组合电路和HCL布尔表达式"><span class="nav-number">4.6.1.2.</span> <span class="nav-text">4.1.2 组合电路和HCL布尔表达式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-1-3-字级的组合电路和HCL整数表达式"><span class="nav-number">4.6.1.3.</span> <span class="nav-text">4.1.3 字级的组合电路和HCL整数表达式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-1-3-存储器和时钟"><span class="nav-number">4.6.1.4.</span> <span class="nav-text">4.1.3 存储器和时钟</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-指令的顺序实现"><span class="nav-number">4.6.2.</span> <span class="nav-text">4.2 指令的顺序实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#4-2-1-将处理组织成阶段"><span class="nav-number">4.6.2.1.</span> <span class="nav-text">4.2.1 将处理组织成阶段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-2-2-SEQ的时序"><span class="nav-number">4.6.2.2.</span> <span class="nav-text">4.2.2 SEQ的时序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-流水线通用原理"><span class="nav-number">4.6.3.</span> <span class="nav-text">4.3 流水线通用原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#预测下一个PC"><span class="nav-number">4.6.3.1.</span> <span class="nav-text">预测下一个PC</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-流水线冒险"><span class="nav-number">4.6.4.</span> <span class="nav-text">4.4 流水线冒险</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#性能分析"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-优化程序性能"><span class="nav-number">4.7.</span> <span class="nav-text">5 优化程序性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-优化编译器的能力和局限性"><span class="nav-number">4.7.1.</span> <span class="nav-text">5.1 优化编译器的能力和局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#用内联函数替换优化函数调用"><span class="nav-number">4.7.1.1.</span> <span class="nav-text">用内联函数替换优化函数调用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-表示程序性能"><span class="nav-number">4.7.2.</span> <span class="nav-text">5.2 表示程序性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-消除循环的低效率"><span class="nav-number">4.7.3.</span> <span class="nav-text">5.3 消除循环的低效率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-减少过程调用"><span class="nav-number">4.7.4.</span> <span class="nav-text">5.4 减少过程调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-消除不必要的内存引用"><span class="nav-number">4.7.5.</span> <span class="nav-text">5.5 消除不必要的内存引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-理解现代处理器"><span class="nav-number">4.7.6.</span> <span class="nav-text">5.6 理解现代处理器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-1-整体操作"><span class="nav-number">4.7.7.</span> <span class="nav-text">5.6.1 整体操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-7-循环展开"><span class="nav-number">4.7.8.</span> <span class="nav-text">5.7 循环展开</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-8-提高并行性"><span class="nav-number">4.7.9.</span> <span class="nav-text">5.8 提高并行性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-9-1-多个累积变量"><span class="nav-number">4.7.10.</span> <span class="nav-text">5.9.1 多个累积变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-9-2-重新结合变换"><span class="nav-number">4.7.11.</span> <span class="nav-text">5.9.2 重新结合变换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#用向量指令达到更高的并行度"><span class="nav-number">4.7.11.1.</span> <span class="nav-text">用向量指令达到更高的并行度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-10-优化合并代码的结果小结"><span class="nav-number">4.7.12.</span> <span class="nav-text">5.10 优化合并代码的结果小结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-11-一些限制因素"><span class="nav-number">4.7.13.</span> <span class="nav-text">5.11 一些限制因素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-12-理解内存性能"><span class="nav-number">4.7.14.</span> <span class="nav-text">5.12 理解内存性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-12-1-加载的性能"><span class="nav-number">4.7.15.</span> <span class="nav-text">5.12.1 加载的性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-12-2-存储的性能"><span class="nav-number">4.7.16.</span> <span class="nav-text">5.12.2 存储的性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-13-性能提高技术"><span class="nav-number">4.7.17.</span> <span class="nav-text">5.13 性能提高技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-14-确认和消除性能瓶颈"><span class="nav-number">4.7.18.</span> <span class="nav-text">5.14 确认和消除性能瓶颈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-14-1-程序剖析"><span class="nav-number">4.7.19.</span> <span class="nav-text">5.14.1 程序剖析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、存储器层次结构"><span class="nav-number">4.8.</span> <span class="nav-text">6、存储器层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-存储技术"><span class="nav-number">4.8.1.</span> <span class="nav-text">6.1 存储技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-1-随机访问存储器"><span class="nav-number">4.8.2.</span> <span class="nav-text">6.1.1 随机访问存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#非易失性存储器"><span class="nav-number">4.8.2.1.</span> <span class="nav-text">非易失性存储器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#访问主存"><span class="nav-number">4.8.2.2.</span> <span class="nav-text">访问主存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#访问磁盘"><span class="nav-number">4.8.2.3.</span> <span class="nav-text">访问磁盘</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#固定硬盘"><span class="nav-number">4.8.2.4.</span> <span class="nav-text">固定硬盘</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-2-局部性"><span class="nav-number">4.8.2.5.</span> <span class="nav-text">6.2 局部性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-2-1-对程序数据引用的局部性"><span class="nav-number">4.8.2.6.</span> <span class="nav-text">6.2.1 对程序数据引用的局部性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-2-2-取指令的局部性"><span class="nav-number">4.8.2.7.</span> <span class="nav-text">6.2.2 取指令的局部性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-3-存储器层次结构"><span class="nav-number">4.8.2.8.</span> <span class="nav-text">6.3 存储器层次结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-3-1-存储器层次结构中的缓存"><span class="nav-number">4.8.2.9.</span> <span class="nav-text">6.3.1 存储器层次结构中的缓存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-4-1-通用高速缓存存储器结构"><span class="nav-number">4.8.2.10.</span> <span class="nav-text">6.4.1 通用高速缓存存储器结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#直接映射高速缓存"><span class="nav-number">4.8.2.11.</span> <span class="nav-text">直接映射高速缓存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-4-2-直接映射"><span class="nav-number">4.8.2.12.</span> <span class="nav-text">6.4.2 直接映射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-4-2-全相连映射"><span class="nav-number">4.8.2.13.</span> <span class="nav-text">6.4.2 全相连映射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-4-3-组组相连映射"><span class="nav-number">4.8.2.14.</span> <span class="nav-text">6.4.3 组组相连映射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-4-4-写"><span class="nav-number">4.8.2.15.</span> <span class="nav-text">6.4.4 写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何处理写不命中"><span class="nav-number">4.8.2.16.</span> <span class="nav-text">如何处理写不命中</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-4-5-高速缓存层次结构"><span class="nav-number">4.8.2.17.</span> <span class="nav-text">6.4.5 高速缓存层次结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-5-编写高速缓存友好的代码"><span class="nav-number">4.8.2.18.</span> <span class="nav-text">6.5 编写高速缓存友好的代码</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hecy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
