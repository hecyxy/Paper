<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="a dreamer">
<meta property="og:type" content="website">
<meta property="og:title" content="万水千山">
<meta property="og:url" content="http://hcyxy.tech/page/5/index.html">
<meta property="og:site_name" content="万水千山">
<meta property="og:description" content="a dreamer">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="万水千山">
<meta name="twitter:description" content="a dreamer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hcyxy.tech/page/5/"/>





  <title>万水千山</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">万水千山</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">hcy && xy</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/02/22/数据密集型应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/数据密集型应用/" itemprop="url">数据密集型应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T22:11:38+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、数据系统基石"><a href="#1、数据系统基石" class="headerlink" title="1、数据系统基石"></a>1、数据系统基石</h3><h4 id="1-1-可靠性reliabiity-可扩展性scalability-可维护性maintainability"><a href="#1-1-可靠性reliabiity-可扩展性scalability-可维护性maintainability" class="headerlink" title="1.1 可靠性reliabiity  可扩展性scalability   可维护性maintainability"></a>1.1 可靠性reliabiity  可扩展性scalability   可维护性maintainability</h4><p>很多应用程序都是数据密集型（data-intensive）而不是计算密集型（compute-intensive）。因此CPU很少称为这类应用瓶颈，<strong>问题主要来自数据量、数据复杂性以及数据变更速度。</strong><br></p>
<ul>
<li>存储数据：database</li>
<li>记住开销昂贵的操作结果，加快读取速度 cache</li>
<li>按关键字搜索，各种方式过滤（es solar）</li>
<li>向其他进程发消息，进行异步处理（stream processing）</li>
<li>定期处理大批量数据（batch processing）</li>
</ul>
<p>数据库、消息队列、缓存表面有一些相似性（存储一段时间的数据），但他们有不同的访问模式，意味着迥异的性能特征和实现手段。</p>
<h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><ul>
<li>应用程序表现出用户期望的功能</li>
<li>允许用户犯错，允许用户以出乎意料的方式使用软件</li>
<li>在预期负载和数据量下，性能满足要求</li>
<li>系统能防止未经授权的访问和滥用</li>
<li>fault-tolerant容错性，有硬件错误、软件错误、人为错误。硬件错误包括硬盘崩溃、内存出错、断电。硬盘平均无故障时间(MTTF mean time to failure)约为10-50年。在拥有1w个磁盘的存储集群上，平均每天就有1个磁盘出故障。应对：磁盘raid，双路电源、热插拔CPU。软件错误：接受特定错误输入，导致所有应用服务器实例崩溃。比如12年6-30的闰秒，linux内核一个错误，许多应用同时挂了。失控进程占用一些共享资源，包括cpu、内存、磁盘空间、网络带宽。系统依赖的服务变慢；级联故障，一个小组件鼓掌触发另一个组件中的故障；解决方法：仔细考虑系统中假设和交互；彻底测试；进程隔离；允许进程崩溃并重启；测量、监控分析系统行为。</li>
</ul>
<h5 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h5><p>性能：</p>
<ul>
<li>增加负载参数并保持系统资源（CPU 内存 网络带宽）不变，系统性能受到什么影响</li>
<li>增加负载参数并保持性能不变，需要增加多少系统资源</li>
</ul>
<p>系统性能：吞吐量（每秒处理请求量 每秒处理数据量）、延迟、响应时间。</p>
<p>百分点通常用于服务级别目标（SLO service level objectives）和服务级别协议（SLA service level agreements），即定义服务预期性和可用性合同。SLA可能会声明：如果服务响应时间中位数小于200ms，且99.9百分位点小于1s，则认为服务工作正常。</p>
<p>实践中的百分位点<br><br>在多重调用的后端服务中，高百分位数十分重要。即使并行调用，只有一个调用变慢，整个请求就会变慢，称为尾部延迟放大效应。如果想将响应时间百分点添加到服务监视仪表板，需要有效的计算。简单的实现是在时间窗口内保存所有请求响应时间列表，每分钟对列表进行排序。<strong>大数据量情况下可能效率太低。有些算法如前向衰减、t-digest、HdrHistogram、hyperLogLog来计算百分位近似值。</strong><br></p>
<p>适应某个级别负载的架构不太可能应付10倍于此的负载。当负载发生数量级增长，需要重新考虑架构。通常有纵向扩展(scaling up)【垂直扩展vertical scaling转向更强大的机器】和横向扩展scaling out【水平扩展 horizontal scaling，将负载分布到多台小机器上】。跨多台机器分配负载也称为无共享架构share-nothing。<br><br>有些系统是弹性的，意味着可以检测到负载增加时自动增加计算资源。跨多台机器部署无状态服务非常简单，将带状态的数据系统从单节点变为分布式配置会引入许多额外复杂度。</p>
<h5 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h5><ul>
<li>可操作性(Operability)便于运维团队平稳运行</li>
<li>简单性（Simplicity）从系统中消除尽可能多的复杂度，使新工程师也能轻松理解系统</li>
<li>可演化性（evolability）也称为可扩展性extensibility </li>
</ul>
<h4 id="1-2数据模型与查询语言"><a href="#1-2数据模型与查询语言" class="headerlink" title="1.2数据模型与查询语言"></a>1.2数据模型与查询语言</h4><p>数据模型层次：</p>
<ul>
<li>观察世界：人、货、行为、资金，我们可以用对象、数据结构以及操控那些数据的API进行建模；</li>
<li>存储这些数据结构可以用json/xml，关系数据库中的表、图来存储；</li>
<li>数据库要选择如何以内存、磁盘或网络上字节表示json/xml/关系/图数据，这类表示形式使数据可能有各种方式来查询、搜索、操纵和处理。</li>
<li>更低层次上，硬件工程师可以使用电流、光脉冲、磁场或其他东西来表示字节。</li>
</ul>
<p><strong>关系模型与文档模型</strong><br></p>
<ul>
<li>关系模型：即传统的关系数据库SQL；</li>
<li>文档模型：NoSQL。</li>
<li>网络模型：是层次模型的推广，每条记录可能有多个父节点。</li>
</ul>
<p><strong>文档模型中的架构灵活性</strong><br><br>文档数据库有时称为无模式(schemaless)，具有误导性，因为读取数据的代码通常假定某种结构，更精确的是<strong>schema-on-read 数据是隐含的，只有在数据被读取时才被解释</strong>。传统关系数据库是schema-on-write写时模式。读时模式类似编程语言中动态（运行时）类型检查，而写时模式类似静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大争议一样。<br></p>
<p><strong>查询的数据局部性</strong><br><br>文档通常以单个连续字符串形式进行存储，如果应用程序经常访问整个文档，那么存储局部性会带来性能优势。局部性仅仅适用于同时需要文档绝大部分内容的情况。即使之访问其中一小部分，数据库通常需要加载整个文档，十分浪费。更新文档需要整个重写。<br><br>为了局部性而分组集合相关数据不局限于文档模型，spanner在关系数据模型中提供了同样的局部性属性，允许模式声明一个表的行应该交错嵌套在附父表内。orable中的多表索引集群表multi-table index cluster tables。bigtable中cassandra、hbase中的列族概念与管理局部性类似。随着时间推移，关系数据库和文档数据库变的越来越相似，模型相互补充。<br></p>
<p><strong>数据查询</strong></p>
<ul>
<li>SQL声明式查询语言（编程语言是命令式的）</li>
<li>MapReduce查询，用于在多台机器上批量处理大规模数据。是一个相当底层的编程模型，用于计算机集群分布式执行。</li>
<li>图数据模型 neo4j cypher</li>
</ul>
<h4 id="1-3-存储与检索"><a href="#1-3-存储与检索" class="headerlink" title="1.3 存储与检索"></a>1.3 存储与检索</h4><p>主要有两种存储引擎：日志结构（log-structured）、面向页面（page-oriented）B树。<br><br>数据存储的诸多问题：文件格式、删除记录、崩溃恢复、部分写入、并发控制。为什么追加日志：追加和分段合并是顺序写入，比随机写快。某种程度上顺序写基于闪存的固态硬盘SSD也是很好的；如果段文件是附加的或不可变得，并发和崩溃恢复就简单了；合并旧段可以避免数据文件随着时间推移分散的问题。<br><br><strong>哈希索引缺点</strong><br></p>
<ul>
<li>散列表必须可以放进内存</li>
<li>范围查询效率不高</li>
</ul>
<h5 id="SSTables和LSM树"><a href="#SSTables和LSM树" class="headerlink" title="SSTables和LSM树"></a>SSTables和LSM树</h5><p>每个日志结构存储段都是一系列键值对。假设要求键值对的序列按键排序，就把这种格式称为排序字符串表（Sorted String Table），简称SSTable。压缩保证每个键只在每个合并段文件出现一次。优点：</p>
<ul>
<li>合并简单高效。类似归并排序</li>
<li>为了在文件中找到一个特定的键，不需要保存内存中所有键的索引。</li>
</ul>
<p>在磁盘上维护有序结构是可能的（B树），但是内存中更容易。比如红黑树、AVL树。那么构建存储引擎的思路：</p>
<ol>
<li>写入时，添加到内存中的AVL树，这个内存树被称为内存表（memtable）</li>
<li>当内存表大于某个阈值（几兆），将其作为SSTable写入磁盘。写入后，继续写入到一个新的内存表；</li>
<li>为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，在下一个较旧的段中找到该关键字；</li>
<li>有时在后台运行合并、压缩过程以组合段文件并丢弃覆盖或删除的值。<br>如果数据库崩溃，则最近写入的内存表则会丢失，所以在写入日志时，日记追加到磁盘上，以便崩溃后恢复。</li>
</ol>
<p>用SSTable制作LSM树：算法本质上是LevelDB、RocksDB中使用关键值存储引擎库，被设计嵌入到其他应用程序中。Cassandra、HBase使用了类似存储引擎，都是受到SSTable、memtable启发。<br><br>lucene是ES、Solr使用的一种全文搜索引擎，使用类似方法它的词典。全文索引比键值索引复杂，基于类似想法：在搜索查询中给出一个单词，找到提及的单词的所有文档。通过键值结构实现，键是单词（term），值包含单词（文章列表）的所有文档的ID列表。</p>
<p><strong>性能优化</strong><br><br>当查找数据库中不存在的键时，LSM树算法可能很慢：必须检查内存表，可能会从磁盘读取每一个，才能确定键是否存在。为了优化这种访问，存储引擎通常使用额外的<strong>bloom过滤器</strong>。不同策略确定SSTable如何被压缩、合并顺序时间。分层压缩、平坦压缩，比如levelDB使用平坦压缩，HBase使用大小分层，cassandra同时支持。规模级别的调整中，更新和更小的SSTable先后被合并到更老、更大的SSTable中。水平压缩，关键范围被拆分成更小的SSTable，较旧的数据被移动到单独的水平上，使得压缩能够递增进行，使用更少的磁盘空间。</p>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>像SSTable一样，B树保持按键排序的键值对，允许高效的键值查找和范围查询。日志结构索引将数据库分解为可变大小的段，总是按顺序编写段。相比B树将数据库分解为固定大小的块或页，传统上为4kb（有时更大），并且一次只能读取或写入一个页面。这种设计更接近底层硬件，因为磁盘也被安排在固定大小的块中。<br><br><strong>让B树更可靠</strong><br><br>B树基本底层写操作是用新数据覆盖磁盘上页面，假定覆盖不改变页面位置。这与日志结构索引LSM形成对比，LSM只附加到文件，删除过时文件。硬盘上发生的操作：磁头移到正确位置，转到正确位置后，用新的数据覆盖适当扇区。固态硬盘上，SSD必须一次擦除和重写相当大的存储芯片块。为了防止数据库崩溃数据丢失，B树也实现了一个额外的磁盘数据结构：预写式日志（WAL write-ahead-log redo log）。仅追加的文件，多个线程修改的时候，需要进行并发控制。</p>
<h5 id="比较B树和LSM树"><a href="#比较B树和LSM树" class="headerlink" title="比较B树和LSM树"></a>比较B树和LSM树</h5><p>LSM树写入速度更快，B树读取速度更快。读取LSM需要压缩不同阶段检查几个不同数据结构和SSTable。<br><br><strong>LSM树优点</strong></p>
<ul>
<li>B树索引至少两次写入每一段数据：一次写入预先写入日志，一次写入树页面本身。即使页面几个字节发生变化，也需要一次编写整个页面。</li>
<li>由于反复压缩、合并SSTable，日志结构也会重写数据。在数据库的生命周期中写入数据库导致对磁盘的多次写入，被称为写放大write amplification。</li>
<li>LSM树通常能够比B树支持更高的写入吞吐量，具有较低的写放大，因为顺序写入紧凑的SSTable不是覆盖树中几个页面。</li>
<li>LSM树可以被压缩的更好，比B树在磁盘上产生更小的文件。B树存储引擎会由于分割留下一些未使用的磁盘空间：当页面被拆分或某行不能放入现有页面，页面中某些空间仍未被使用。由于LSM树不是面向页的，并且定期重写SSTable去除碎片，所以有较小存储开销，特别是使用平坦压缩。</li>
</ul>
<p><strong>LSM缺点</strong></p>
<ul>
<li>压缩过程有时会干扰正在进行的读写操作。尽管存储引擎尝试逐步执行压缩而不影响并发访问，但是磁盘资源有限，很容易发生请求需要等待磁盘完成昂贵压缩操作。对吞吐量和平均响应时间影响通常很小。</li>
<li>压缩另一个问题出现在高写入吞吐量：磁盘的有限写入带宽需要在初始写入（记录和刷新内存表到磁盘）和后台运行的压缩线程间共享。数据库越大，压缩所需的磁盘带宽就越多。</li>
<li>如果写入吞吐量很高，并且压缩没有仔细配置，压缩跟不上写入速度。这种情况下，磁盘上未合并段数量不断增加，直到磁盘空间用完，读取速度也会减慢。通常情况，即使压缩无法跟上，基于SSTable的存储引擎也不会限制写入速度，需要进行监控。</li>
</ul>
<p>B树一个优点是：每个键只存在于索引一个位置，而日志结构化存储引擎可能在不同段中有相同键多个副本，B树可以更容易实现事务。</p>
<ul>
<li>主键索引 二级索引</li>
<li>多列索引 将多个字段组合成一个键</li>
<li>全文搜索和模糊索引 Lucene为其词典使用了一个类似SSTable的结构，这个结构需要一个小的内存索引，告诉查询在排序文件中哪个偏移量查找关键字。Lucene中内存中索引是键中字符的有限状态自动机，类似于Trie，支持在给定编辑距离内有效搜索单词。</li>
<li>缓存 内存数据库。内存数据库重启需要从磁盘、网络从副本加载状态。</li>
<li>列存储 不要讲所有来自一行的值存储在一起，将来自每列的值存储在一起。还可以进一步通过压缩数据来进一步降低对磁盘吞吐量的需求，面向列存储很适合压缩，使用位图。cassandra和Hbase有列族的概念，从BigTable继承，面向列存储是有误导性的，因为在每个列族中，将一行中的所有列与行键一起存储，并且不适用列压缩，因此BigTable模型仍然主要面向行的。</li>
</ul>
<p>内存带宽和向量处理<br></p>
<ul>
<li>需要扫描数百万行的数据仓库查询，巨大的瓶颈是从磁盘获取数据到内存的带宽。另一个地方是：如何有效利用主存储器带宽到CPU缓存的带宽，避免CPU指令处理流水线中的分值错误预测和泡沫，以及现代中使用单指令多数据（SIMD）指定CPU。</li>
<li>除了减少从磁盘加载的数据量外，面向列存储也可以有效利用CPU周期。比如查询引擎可以将大量压缩的列数据放在L1缓存中，然后在紧密的循环中循环（没有函数调用）。前面描述的按位“与”和“或”运算可以被设计为直接在这样的压缩列数据块上操作。这种技术被称为<strong>矢量化处理</strong>。</li>
</ul>
<h3 id="2-分布式数据"><a href="#2-分布式数据" class="headerlink" title="2 分布式数据"></a>2 分布式数据</h3><h5 id="共享内存架构"><a href="#共享内存架构" class="headerlink" title="共享内存架构"></a>共享内存架构</h5><p>许多处理器，内存和磁盘可以在同一个OS下相互连接，快速的相互连接允许任意处理器访问内存、磁盘的任意部分。在这种共享内存架构（share-memory），所有组件都可以看作一台单独的机器。（大型机中，尽管任意处理器可以访问内存任意部分，但总有一些区域与一些处理器更接近，称为非均匀内存访问NUMA，为了更有效利用这种架构特性，需要对处理进行细分，以便每个处理器主要访问临近内存，分区partitioning仍是必要的）<br><br>共享内存问题：成本增长速度快于线性增长。双倍处理器、双倍内存不足以处理双倍载荷。共享内存架构提供有限的容错能力，尽管高端机器可以使用热插拔组件（不更换磁盘、内存、甚至处理器）</p>
<h5 id="共享磁盘shared-disk"><a href="#共享磁盘shared-disk" class="headerlink" title="共享磁盘shared-disk"></a>共享磁盘shared-disk</h5><p>使用多台具有独立处理器和内存的机器，但将数据存储在机器之间的共享磁盘整列上，磁盘通过网络连接，这种架构用于某些数据仓库，但竞争和锁定的开销限制了共享磁盘方法的可扩展性。</p>
<h5 id="无共享架构shared-nothing"><a href="#无共享架构shared-nothing" class="headerlink" title="无共享架构shared-nothing"></a>无共享架构shared-nothing</h5><p>有时称为水平扩展scale out。每个节点只使用各自处理器、内存、磁盘。节点间的任何协调，都是在软件层面使用传统网络实现。无共享架构不需要使用特殊硬件，可以使用任意机器。</p>
<h5 id="复制replication-VS-分区partitioning"><a href="#复制replication-VS-分区partitioning" class="headerlink" title="复制replication VS 分区partitioning"></a>复制replication VS 分区partitioning</h5><p>数据分布在多个节点上有两种常见方式：复制，在几个不同节点保存相同副本，复制提供冗余。分区：将一个大型数据库拆分成较小子集，从而不同分区指派给不同节点node，也称为分片shard。</p>
<h5 id="为什么数据需要复制"><a href="#为什么数据需要复制" class="headerlink" title="为什么数据需要复制"></a>为什么数据需要复制</h5><ul>
<li>使得数据与用户在地理上接近（从而减少延迟）</li>
<li>系统一部分出现故障，系统也能继续工作（提高可用性）</li>
<li>扩展可以接受请求的机器数量（提高读吞吐量）</li>
</ul>
<p>复制困难之处在于处理复制数据的变更，主要有三种流行的复制算法：单领导者(single leader) 多领导者(multi leader) 无领导者(leaderless)。复制时需要考虑，同步复制还是异步复制，如何处理失败的副本。</p>
<p>处理异常：</p>
<ul>
<li>从库失效：追赶恢复</li>
<li>主库失效：故障切换。将其中一个从库提升为新的主库，以将他们的写操作发送给新主库，这个过程称为failover。</li>
</ul>
<h5 id="复制日志的实现"><a href="#复制日志的实现" class="headerlink" title="复制日志的实现"></a>复制日志的实现</h5><p><strong>基于语句的复制</strong><br><br>主库记录执行的每个请求（语句statement），并将该语句日志发送给其从库。对于关系数据库来说，就是每个insert update delete语句。但是也有一些问题：</p>
<ul>
<li>任何调用非确定性函数(nondeterministic)语句，可能会在每个副本上生成不同的值，比如Now()，rand()。</li>
<li>如果语句使用了自增列(auto increment)，或者依赖现有数据，则必须在每个副本按照完全相同的顺序执行，否则会产生不同的效果。当有多个并发执行事务时，可能成为一个限制。</li>
<li>有副作用语句（触发器、存储过程）可能会在每个副本产生不同副作用。</li>
<li>解决方法：主库可以用固定返回值替代确定的函数调用，以便从库获得相同的值。</li>
</ul>
<p><strong>传输预写式日志</strong><br></p>
<ul>
<li>对于日志结构存储引擎，日志段在后台压缩，并进行垃圾回收</li>
<li>对于覆写单个磁盘块的B树，每次修改都会写入预写式日志（WAL）</li>
</ul>
<p>任何情况日志都包含所有数据库写入的仅追加字节序列，可以使用完全相同的日志在另一个节点上构建副本。除了将日志写入磁盘，主库还可以通过网络将其发给从库。</p>
<p>Postgre和Oracle使用这种复制方法，缺点是：日志记录非常底层，WAL包含哪些磁盘块中，哪些字节发生更改。这使复制与存储引擎紧密耦合。</p>
<p><strong>逻辑日志复制（基于行）</strong><br><br>复制和存储引擎使用不同的日志格式，可以使复制日志从存储引擎内部分离出来。这种复制日志称为逻辑日志，以将其与存储引擎（物理）的数据表区分开。</p>
<ul>
<li>对于插入的行，日志包含所有列的新值</li>
<li>对于删除的行，日志包含足够的信息标识已删除的行</li>
<li>对于更新的行，日志包含更新的行，以及更新的新值。</li>
</ul>
<p><strong>基于触发器复制</strong><br><br>相比其他复制具有更高的开销，更容易出错，也有很多限制，但更灵活。</p>
<p><strong>多主复制</strong><br><br>应用场景：数据库的副本分布在不同数据中心，常规基于领导者复制，主库必须位于其中一个数据中心，所有写入都要经过该数据中心。要解决不同数据中心同时修改相同数据，需处理冲突。另一种场景：应用程序在断网后仍需要继续工作。协同编辑场景。避免冲突：通过一些手段指定固定的leader。或者通过唯一ID、时间戳。自定义冲突解决逻辑，写时执行或读时执行，让应用自己选择解决。复制拓扑有环形拓扑、星型拓扑、雪花拓扑。</p>
<p><strong>无主复制</strong><br><br>单主复制、多主复制都是基于这样想法：客户端向一个主库发送写请求，数据库系统负责将写入复制到其他副本，主库决定写入的顺序，从库按相同顺序应用主库写入。最早一些复制系统是无领导的leaderless，现在又开始流行起来。</p>
<p><strong>读修复和反熵</strong><br><br>读修复：客户端并行读取多个节点，可以检测到任何陈旧响应，判定新值，写会复制品。<br><br>反熵过程：数据存储的后台不断查找副本间数据差异，将任何缺少的数据从一个副本复制到另一个副本。</p>
<h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>数据在不同节点上的副本，对于非常大的数据集成本很高（吞吐量很大），仅仅复制是不够的。还需要将数据进行分区partitions，也成为分片sharding。【与网络分区不是同一个概念】<br></p>
<p>分区概念在MongoDB、ES、Solor中称为分片shard，HBase中称为region，Bigtable中是tablet，Cassandra是vnode虚节点。</p>
<p>分区主要是为了<strong>扩展性</strong>，不同分区可以放在不共享集群中不同节点上，因此大数据集可以分布在多个磁盘上。分区通常与复制结合使用，使得每个分区副本存储在多个节点上，意味着每条记录属于一个分去，仍然可以存储在多个不同节点上获得容错能力。</p>
<p>键值数据如何分区，哪些节点存储哪些数据，如果分区不公平，会导致形成高负载的分区，也成为热点hot spot。</p>
<h5 id="根据键的范围分区"><a href="#根据键的范围分区" class="headerlink" title="根据键的范围分区"></a>根据键的范围分区</h5><p>为每个分区指定一块连续的键范围，如果知道范围边界，则可以轻松确定哪个分区包含某个值。key range分区缺点是某些特定模式会导致热点。</p>
<h5 id="根据键的散列分区"><a href="#根据键的散列分区" class="headerlink" title="根据键的散列分区"></a>根据键的散列分区</h5><p>根据散列函数、哈希、加密算法，在分区之间分配键，分区边界可以是均匀间隔的，也可以是伪随机选择的，有时也可以称之为<strong>一致性哈希</strong>。</p>
<p>通过使用Key散列进行分区，失去了键范围分区的一个很好的属性：<strong>高效执行范围查询的能力</strong>。组合索引为一对多关系提供了一个优雅的数据模型，比如主键（userId,updateTime）。</p>
<h5 id="负载倾斜与消除热点"><a href="#负载倾斜与消除热点" class="headerlink" title="负载倾斜与消除热点"></a>负载倾斜与消除热点</h5><p>极端情况，所有读写可能是针对同一个键的，所有请求都会被路由到同一分区。大数据系统无法自动补偿这种高度偏斜的负载，应用程序有责任减少偏斜。比如在火爆ID的前后加一些数字，保证其分布在不同分区。</p>
<h4 id="分片与次级索引"><a href="#分片与次级索引" class="headerlink" title="分片与次级索引"></a>分片与次级索引</h4><p>前面的分区方案依赖键值数据模型，如果只通过主键访问记录，可以确定键分区。如果涉及次级索引，会更加复杂。通常辅助索引不能唯一标识记录。次级索引是关系数据库基础，在文档数据库也很普遍。次级索引不能整齐映射到分区，有两种用二级索引对数据库进行分区的方法：<strong>基于文档的分区document-based 基于关键词term-based</strong></p>
<h5 id="按文档的二级索引"><a href="#按文档的二级索引" class="headerlink" title="按文档的二级索引"></a>按文档的二级索引</h5><p>假如有一个汽车列表，每个列表有一个唯一ID（文档ID），利用ID对数据库进行分区，可以通过颜色、厂商过滤，所以需要在颜色、厂商建次级索引（文档数据库中是字段field，关系数据库中是列column）。比如有俩分区</p>
<ul>
<li>partition0：191 -&gt; {color:”red”,make:”Honda”} 214 -&gt;{color:”black”,make:”Dodge”} 306 -&gt;{color:”red”,make:”Ford”}</li>
</ul>
<ol>
<li>次级索引： color:black -&gt; [214]  color:red -&gt; [191,306]  color:yellow -&gt; []</li>
</ol>
<ul>
<li>Partition1：515 -&gt; {color:”silver”} 768 -&gt; {color:”red”} 893 -&gt; {color:”silver”}</li>
</ul>
<ol start="2">
<li>color:black -&gt; [] color:red -&gt; [768]  color:siler -&gt; [515,893]</li>
</ol>
<p>这种索引方法每个分区独立，分区维护自己的二级索引。文档分区索引也被称为本地索引local index。查询的时候需要发送到所有分区，这种查询称为分散/聚集(scatter gather)，并且可能会使二级索引上读取查询很昂贵，即时并行查询分区，分散/聚集也容易导致尾部延迟放大。cassandra、es、solor中广泛使用。</p>
<h5 id="根据关键词（Term）的二级索引"><a href="#根据关键词（Term）的二级索引" class="headerlink" title="根据关键词（Term）的二级索引"></a>根据关键词（Term）的二级索引</h5><p>也可以构建一个覆盖所有分区数据的全局索引，而不是给每个分区创建自己的次级索引。但是不能只把这个索引存储在一个节点上，可能会成为瓶颈，违背分区目的。全局索引也必须进行分区，可以采用与主键不同分区方式。</p>
<ul>
<li>partition0: color:black -&gt; [214]  color:red -&gt; [191,306,768]</li>
<li>partition1: color:silver -&gt; [515,893] color:yellow -&gt; []</li>
</ul>
<p>可以通过关键词本身或散列进行索引分区，根据其本身对范围扫描非常有用（数字，汽车报价），而对关键词的哈希分区提供了负载均衡能力。</p>
<h4 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h4><p>随着时间推移，数据库的变化：</p>
<ul>
<li>查询吞吐量增加，增加更多CPU</li>
<li>数据集大小增加，增加磁盘 RAM</li>
<li>机器故障，其他机器来接管</li>
</ul>
<p>这些更改都需要将数据和请求从一个节点移动到另一个节点，将负载从集群一个节点移向另一个节点称为再平衡reblancing。</p>
<p>再平衡需要满足：</p>
<ul>
<li>负载在集群节点间公平共享</li>
<li>再平衡发生时 数据库继续接受读取写入</li>
<li>节点之间只移动必须的数据，以便快速再平衡，减少网络和磁盘IO</li>
</ul>
<h5 id="平衡策略"><a href="#平衡策略" class="headerlink" title="平衡策略"></a>平衡策略</h5><ul>
<li>固定数量分区：创建比节点更多的分区，每个节点分配多个分区。如运行在10个节点的集群可能被拆为1000个分区，大约有100个分区分配给每个节点。如果一个节点添加到集群中，则可以从旧节点分配一些区给新节点。分区数量不变，还可以解决硬件不匹配问题：为更强大的节点分配更多区，承受更多负载，如ES couchHbase</li>
<li>动态分区 对于使用键范围分区的数据库，具有固定边界的固定数量的分区将非常不便。按键范围进行分区的数据库（如HBase）会动态创建分区，分区增长超过配置大小，会被分成两个分区。数据量小的分区可以合并。</li>
<li>按节点比例分区。以上两种策略中，分区的数量与节点数量无关。cassandra使用的是分区数与节点数成正比，每个节点具有固定数量分区。一个新节点加入集群，随机选择固定数量现有分区进行拆分，然后占有这些拆分分区中每个分区一半。可能产生不公平分割。</li>
</ul>
<h5 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h5><p>客户发出请求如何知道连接哪个节点，概括为服务发现service discovery。</p>
<ol>
<li>允许客户连接任何节点（如Round-Robin load balancer）。如果该节点恰巧拥有请求的分区，则处理返回；否则将请求转发到适当节点；</li>
<li>将客户端请求转发到路由层，决定怎么转发，负责负载均衡</li>
<li>客户端知道分区和节点分配。HBase、Solor、Kafka使用zk跟踪分区分配，mongoDB依赖自身配置服务config server，cassandra使用gossip协议。</li>
</ol>
<h5 id="索引和快照隔离"><a href="#索引和快照隔离" class="headerlink" title="索引和快照隔离"></a>索引和快照隔离</h5><p>索引如何在多版本数据库工作，一种是使索引简单指向对象所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本。当垃圾手机删除任何事务，相应索引条目也可以被删除。实践中许多实现细节决定了多版本并发控制的性能。<br><br>在CouchDB、LMDB，使用的是B树，但是使用的是仅追加/写时拷贝，更新时不覆盖树的页面，而是创建一个副本。从父页面直到树根级联更新。仅追加B树，每个写入事务都会创建一棵新的B树。当创建时，从该特定树根生长的树就是数据库一个一致性快照。没必要根据事务ID过滤对象，因为不能修改现有的B树。这种方法也需要一个负责压缩和垃圾收集的后台进程。</p>
<h4 id="分布式系统的麻烦"><a href="#分布式系统的麻烦" class="headerlink" title="分布式系统的麻烦"></a>分布式系统的麻烦</h4><h5 id="云计算与超级计算机"><a href="#云计算与超级计算机" class="headerlink" title="云计算与超级计算机"></a>云计算与超级计算机</h5><ul>
<li>一种是一端是高性能计算（HPC）。具有数千个CPU的超级计算机，通常用于计算密集型科学计算任务，如天气预报、分子动力学。</li>
<li>另一个极端是云计算，通常与多租户数据中心，连接IP网络的商品计算机，弹性/按需资源分配以及计量计费相关联；</li>
<li>传统企业数据中心位于两个极端之间</li>
</ul>
<p>不同哲学会有不同故障处理方式。超级计算机通常会将计算状态持久化到磁盘，一个节点故障简单的停止整个集群工作。故障修复后，从上一个检查点重新开始。互联网服务系统有很大不同：</p>
<ul>
<li>互联网应用程序都是在线的，需要能够随时以低延迟服务用户。</li>
<li>超级计算机通常由专用硬件构成，每个节点相当可靠，节点通过共享内存、远程直接内存RDMA进行通信。云服务节点是由商品机器构建而成，较低成本提供相同性能，具有较高故障率。</li>
<li>大型数据中心网络通常基于IP和以太网，以闭合拓扑排列，提供更高的二等分带宽。超级计算机通常使用专门的网络拓扑结构，例如多维网格和环面，这为已知通信模式的hPC工作负载提供更好的性能</li>
</ul>
<p><strong>不可靠网络</strong><br><br>分布式系统是无共享系统，通过网络连接一堆机器，一台机器不能访问另一台机器内存或磁盘。无共享并不是构建系统的唯一方式，但是已成为主要方式。相对便宜、不需要特殊的硬件、利用商品化的云计算服务、通过跨多个地理分布的数据中心进行冗余可以实现高可用。</p>
<p>互联网和数据中心中大多数内部网络都是<strong>异步分组网络</strong>，不保证消息可靠送达。</p>
<p>同步网络：即使数据经过多个路由器，也不会受到排队影响，因为呼叫的16位空间已经在网络的下一挑中保留了下来。而且由于没有排队，网络的最大端到端延迟是固定的。电话网络中的电路与TCP连接有很大不同：电路是固定数量预留带宽，电路建立时没有其他人可以使用，而TCP连接的数据包机会性的使用任何网络带宽。可以给TCP一个可变大小的数据块（网页 电子邮件），尽可能在最短的时间内传输，TCP连接空间时，不使用任何带宽（除了keepalive包）。</p>
<p>为什么数据中心和互联网使用分组交换？针对突发流量，进行优化。一个电路适用于音频或视频通话，通话期间传送相当数量的比特；请求网页没有特定的带宽要求，只需要尽快完成即可。<strong>如果想通过电路传输文件，不得不猜测一个带宽分配。太高电路无法建立，太低，会有电路浪费网络容量。相比TCP动态调整数据传输速率以适应可用的网络容量</strong></p>
<p>延迟和资源利用：一般来讲可以将延迟变化为动态资源分区的结果。如果资源是静态分区的，则在某些环境中可以实现延迟保证，但是以降低利用率为代价的。<strong>网络中的可变延迟不是一种自然规律，而只是成本/收益权衡的结果。</strong></p>
<p><strong>不可靠的时钟</strong><br><br>分布式系统中，时间很棘手，因为通信不是即时的，很难确定在涉及多台机器时发生事情的顺序。而且网络上每台机器都有自己的时钟，这是一个硬件设备，通常是石英晶体振荡器。而且是不完全准确的，每台机器都有自己的时间概念。<strong>可以在一定程度上同步时钟，最常用的机制是网络时间协议NTP，允许根据一组服务器报告的时间来调整计算机时钟，更精确的可以使用时间源，如GPS机获取时间</strong></p>
<p><strong>单调钟与时钟</strong><br></p>
<ul>
<li>时钟 根据某个日历（也称为挂钟时间wall-clock time）返回当前日期和时间，如linux上clock_gettime。java中system.currentTImeMills返回自epoch。虽然时钟被称为实时时钟，但它与OS无关。时钟通常与NTP同步，意味着一台机器时间戳与另一台机器时间戳相同。当本地时钟比NTP服务器跑的快，可能会被强制重置，好像跳回了先前的时间点。这些跳跃以及经常忽略闰秒的事实，使时钟不能用于测量经过的时间。</li>
<li>单调钟适用于测量持续时间（时间间隔），如超时或服务响应时间，java中system.nanoTime。具有多个CPU插槽的服务器，每个cpu可能有一个单独计时器，不一定与其他cpu同步。os会补偿所有差异，明智做法不要太信任单调性保证。NTP协议检测到计算机本地石英钟比NTP服务器更快、更慢，可以调整单调钟向前走的频率。NTP允许时钟速率增加或减慢最高至0.05%。NTP不能使单调使用向前向后跳转。</li>
</ul>
<p><strong>时钟同步与准确性</strong><br><br>单调钟不需要同步，始终需要根据NTP服务器或其他外部时间源来设置才有用。硬件时钟和NTP可能变幻莫测，计算机中石英钟不够精确，会漂移drifts。漂移取决与机器温度。google假设其服务器每30s与服务器重新同步一次的时钟漂移为6ms，或者每天重新同步的时钟漂移为17s。</p>
<ul>
<li>如果计算机时钟与NTP服务器时钟差别太大，可能拒绝同步或者本地时钟将被强制重置。</li>
<li>NTP服务器意外阻塞，可能在一段时间内忽略错误配置</li>
<li>NTP同步只能和网络延迟一样。通过互联网同步，35ms的最小误差是可以实现的。较大的网络延迟会导致NTP客户端完全放弃。</li>
<li>闰秒导致59分钟或许有61s。闰秒已经使许多大型系统崩溃说明关于时钟的假设是多么容易溜进系统，处理闰秒的最佳方法是通过在一天中逐渐执行闰秒调整。</li>
<li>虚拟机中，硬件时钟会被虚拟化。当一个cpu核心在虚拟机间共享，每个虚拟机都会暂停几十毫秒，而另一个虚拟机正在运行。从应用角度看，这种停顿表现为时钟突然向前跳跃。</li>
<li>如果在未完全控制的设备上运行软件（移动、嵌入式设备），坑完全不信任该设备硬件时钟。一些用户估计将其硬件时钟设置为不正确日期和时间，例如为了规避游戏中时间限制，时钟可能会被设置到很远的过去或将来。</li>
</ul>
<p>欧洲金融机构要求所有高频交易基金在UTC在时间100微秒内同步时钟，以便调试闪崩等市场异常现象，帮助检测市场操纵。很多东西都会导致时钟同步错误，如果NTP守护进程配置错误，或者防火墙阻止了NTP通信，由漂移引起的时钟误差可能很快就变大。</p>
<h6 id="有序事件的时间戳"><a href="#有序事件的时间戳" class="headerlink" title="有序事件的时间戳"></a>有序事件的时间戳</h6><p>有的分布式系统会依赖时钟，多个节点存在时钟误差的情况下，会发生冲突。有一种解决冲突的策略：最后写入为准LWW。在多领导者、无领导者数据库如cassandra中被广泛使用。有些是在客户端生成时间戳，但是不能改变LWW基本问题：</p>
<ul>
<li>数据库写入神秘消失：具有滞后时钟的节点无法用快速时钟覆盖之前由节点写入的值，直到节点之间的时钟偏差过去</li>
<li>LWW无法区分高频顺序写入（客户端B的增量操作一定发生在客户端A写入滞后）和真正并发写如。需要额外因果关系跟踪机制（版本向量），以防止因果关系冲突。</li>
</ul>
<p>所谓逻辑时钟是基于递增计数器而不是震荡石英晶体，对于排序事件是更安全的选择。逻辑时钟不测量一天中的时间或经过的秒数，而仅测量事件相对顺序。相反用来测量实际经过时间的时钟和单调钟被称为物理时钟。</p>
<p>spanner的trueTime API会报告本地时钟的置信区间，当询问当前时间，会得到【最早，最晚】</p>
<h6 id="全局快照的同步时钟"><a href="#全局快照的同步时钟" class="headerlink" title="全局快照的同步时钟"></a>全局快照的同步时钟</h6><p>当数据库分布在许多机器上，由于需要协调全局单调递增的事务ID可能很难生成，事务ID必须反映因果关系。在有大量小规模、高频率的事务情景下，分布式系统中创建事务ID成为一个瓶颈。Twitter的snowflake，通过将ID空间的块分配给不同节点近似单调的增加唯一ID。但是无法保证与因果关系一致的排序。</p>
<p>可以使用同步时钟的时间戳作为事务ID，如果能够获得足够好的同步性，这种方法具有很合适的属性，更晚的事务具有更大的时间戳。<strong>spanner以这种方式实现快照隔离，使用TrueTime APi报告时钟置信区间，如果有两个置信区间，每个区间包含最早、最晚时间戳。nodeA=[a,b],nodeb=[c,e]。如果两个区间不重合，肯定有先后顺序。如果重叠，在提交事务时故意等待置信区间长度的时间。</strong>为了保持尽可能短的等待时间，spanner需要保持尽可能小的时钟不确定性。为此google在每个数据中心都部署的一个GPS接收器或原子钟，允许时钟在大约7ms内同步。</p>
<p><strong>暂停进程</strong><br><br>假设一个数据库，每个分区只有一个领导者，只有领导允许接受写入，一个节点如何知道它仍是领导者，并且可以安全的接受写入。</p>
<ul>
<li>一种选择是领导者从其他节点获得一个租约lease，类似一个带超时的锁。任一时刻只有一个节点可以持有该租约。租约类就是leader，到期后节点必须周期性续约；<strong>这样的设计会依赖同步时钟：租约到期时间由另一台机器设置（如当前时间加上30s，计算到期时间）。并将其与本地系统时钟进行比较，如果时钟超过几秒不同步，就开始做奇怪的事情。</strong> 如果颁发者的时钟比接收者的时钟慢，则当接收者认为 lease 已经过期的时候，颁发者依旧认为 lease 有效。接收者可以用在 lease 到期前申请新的 lease 的方式解决这个问题。<br>如果颁发者的时钟比接收者的时钟快，则当颁发者认为 lease 已经过期的时候，接收者依旧认为 lease 有效，颁发者可能将 lease颁发给其他节点，造成承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是将颁发者的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对 lease 的有效性的影响</li>
<li>即使协议改为使用本地单调时钟，存在的问题：代码假定在执行剩余时间检查currentTimeMills和实际执行请求process中时间间隔非常短，10s足够确保租约在请求处理到一半不会过期，但是程序执行中出现意外停顿，假如lease.isValid周围停止15s，然后终止。这种情况下，在请求被处理的时候，租约可能已经过期，另一个节点已经接管了leader。直到循环到下一个迭代，可能已经做了一些不安全处理请求。引起线程暂停的原因：gc、虚拟化环境中可以挂起虚拟机并恢复，这个暂停可以在进程执行的任何时候发生，可以持续任意长时间，这个功能可用于虚拟机从一个主机写到另一个主机的实时迁移，不需重启。暂停长度取决于进程写入内存的速率；笔记本关盖子；OS上下文切换；程序同步访问磁盘，等待IO完成；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    request=getRequest()</span><br><span class="line">    if(lease.expireTIme-currentTImeMills&lt;10000)</span><br><span class="line">&#123;</span><br><span class="line">    lease.renew()</span><br><span class="line">&#125;</span><br><span class="line">    if(lease.isValid())&#123;</span><br><span class="line">        process(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="响应时间保证"><a href="#响应时间保证" class="headerlink" title="响应时间保证"></a>响应时间保证</h6><p>某些软件运行环境要求很高，如飞机主控计算机，火箭、机器人。在这些系统中，软件必须有一个特定截止时间，如果截止时间不满足，可能导致整个系统故障，这就是所谓的硬实时。实时操作系统允许在指定时间间隔内保证cpu时间分配，库函数必须记录最坏情况下的执行时间；动态内存分配可能受到限制或完全不允许（实时垃圾收集器存在，但是应用程序仍然必须确保它不会给GC太多负担），必须进行大量测试和测量；这些都需要大量额外的工作，严重限制了可以使用的编程语言、库和工具范围。</p>
<p>限制垃圾收集的影响<br><br>语言运行在计算垃圾回收时有一定灵活性，可以跟踪对象分配的速度和随着时间的推移剩余的空闲内存。新型的想法是将GC暂停视为一个节点的短暂计划中断，并让其他节点处理来自客户端的请求，同时一个节点正在收集垃圾。一些对延迟敏感的金融交易系统使用这种方法。</p>
<h6 id="知识、真相与谎言"><a href="#知识、真相与谎言" class="headerlink" title="知识、真相与谎言"></a>知识、真相与谎言</h6><p>分布式系统与单机不同：没有共享内存，只能通过不可靠网络传递消息，系统可能遭受部分失效，不可靠的时钟和处理暂停。</p>
<p>网络中一个节点无法确切的知道任何事情，只能根据网络接收到的消息进行猜测。节点只能通过交换消息来找出另一个节点所处的状态（存储了哪些数据、是否正确运行）。</p>
<p>这些系统的讨论与哲学有关：系统中什么是真什么是假？如果感知和测量的机制都不可靠，那么关于这些知识又能有多少确定。软件系统应该遵循对物理世界所期望的法则、因果关系么</p>
<p>分布式系统中，可以陈诉关于行为的假设，并以满足这些假设的方式设计实际系统。算法可以被证明在某个系统模型中正确运行。意味底层系统模型提供很少保证也可以实现可靠行为。</p>
<p>分布式算法要具有安全性和活性。唯一性、单调序列就是安全属性，可用性就是活性。安全性和活性对于推理分布式算法的正确性非常有用。</p>
<h6 id="兰伯特时间戳"><a href="#兰伯特时间戳" class="headerlink" title="兰伯特时间戳"></a>兰伯特时间戳</h6><p>这种方法可以产生因果关系一致的时间戳。基本思想：每个节点和客户端都跟踪迄今为止见到的最大计数器的值，并在每个请求中包含这个最大计数器的值。一个节点收到最大计数器值大于自身计数器值得请求或响应时，它立即将自己的计数器设置为这个最大值。</p>
<p>光有时间戳排序还不够，比如两个人不能建相同的账户，但是确保全局唯一，还得知道全序何时落地。正确的全序广播算法必须始终保证可靠性、有序性，即使节点或网络出现故障，网络中断，消息无法传递，但是算法可以重试，或者网络修复时，消息能及时送达。</p>
<p>etcd和zk这样的共识服务实现了全序广播，这正是数据库复制所需的，每个消息都代表一次数据库写入，每个副本按相同顺序处理相同写入，副本间保持一致。这个原理是状态机复制。</p>
<h3 id="3、-衍生数据"><a href="#3、-衍生数据" class="headerlink" title="3、 衍生数据"></a>3、 衍生数据</h3><p>从高层次看，存储和处理数据的系统可以分为两大类：</p>
<ul>
<li>记录系统（System of record）。也被称为source of truth，持有数据的权威版本。当新的数据进入首先会记录在这里。</li>
<li>衍生数据系统derived data system。通常是另一个系统中现有数据以某种方式进行转换或处理的结果。如果丢失衍生数据，可以从原始源重新创建。</li>
</ul>
<p>从技术上讲，衍生数据是冗余的，因为重复了已有信息。但是衍生数据对于获得良好的只读性能通常很重要。大多数数据库、存储引擎和查询语言，本质上既不是记录系统也不是衍生系统。数据库只是一个工具，如何使用取决于个人；记录系统和衍生系统之间区别不在于工具，而在于应用程序的使用方式。</p>
<h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p>有三种不同系统：</p>
<ul>
<li>服务（在线系统）。服务等待客户请求或指令到达，每收到一个，服务会试图尽快处理，并发回一个响应。响应时间通常是服务性能的主要衡量指标，可用性非常重要。</li>
<li>批处理系统（离线系统）。一个批处理系统有大量输入数据，跑一个作业job来处理，并生成一些输出数据，往往需要一段时间。批量作业通常会定期运行。批处理作业的主要性能衡量标准通常是吞吐量。</li>
<li>流处理系统（准实时系统）。像批处理系统一样，流处理消费输入并产生输出，但是流式作业在事件发生后不久就会对事件进行操作，而批处理作业则需要等待固定一组输入数据。</li>
</ul>
<p>批处理是一种很古老的计算方式，早在可编程数字计算机出现前，打孔卡制表机实现了半机械化的批处理形式。MapReduce和其他一些批处理算法和框架，并探索在现代数据系统中的作用。Unix的思想和经验教训可以迁移到大规模、异构的分布式数据库系统中。</p>
<p>Unix中cat、awk、head等工具能在积分中内处理几GB日志文件。另一方面如果作业工作集大于可用内存，则排序方法的优点是可以高效使用磁盘。与在SSTable和LSM树种讨论的原理一样；数据块可以在内存中排序作为段文件写入磁盘，灾后合并为一个更大的排序文件。归并排序具有在磁盘上运行酿好的顺序访问模式。linux中sort通过溢出至磁盘的方式来自动应对大于内存的数据集，并同时使用多个CPU核进行并行排序。意味着unix命令很容易扩展到大数据集，且不会耗尽内存。瓶颈可能是从磁盘读取输入文件的速度。</p>
<h6 id="Unix哲学"><a href="#Unix哲学" class="headerlink" title="Unix哲学"></a>Unix哲学</h6><p>Unix管道的发明者描述：当需要将消息从一个程序传递到另一个程序时，需要一种类似水管的拼接程序的方式。I/O也应该按照这种方式进行。Unix哲学：</p>
<ul>
<li>每个程序做好一件事。要做一件新的工作，写一个新程序，而不是通过添加功能让老程序复杂化；</li>
<li>期待每个程序的输出称为另一个程序的输入。不要将无关信息混入输出，避免使用严格的列数据或二进制输入格式，不要坚持交互式输入；</li>
<li>设计和构建软件、OS，要尽早尝试，最好几周内完成。扔掉笨拙的部分。</li>
<li>优先使用工具来减轻编程任务。即使必须曲线救国编写工具。</li>
</ul>
<p>这种自动化、快速原型设计、增量式迭代、对试验友好，将大型项目分解成可管理的块，很像现在的敏捷开发、DevOps。</p>
<h6 id="统一的接口"><a href="#统一的接口" class="headerlink" title="统一的接口"></a>统一的接口</h6><p>如果想要一个程序的输出称为另一个程序的输入，意味这些程序必须使用相同的数据格式–一个兼容的接口。如果想要将任何程序的输出连接到任何程序的输入，意味所有程序都必须使用相同IO接口。Unix中这种接口是一个文件file（一个文件描述符）。一个文件只是一串有序的字节序列。统一接口的另一个例子是URL和HTTP。</p>
<h6 id="MapReduce和分布式文件系统"><a href="#MapReduce和分布式文件系统" class="headerlink" title="MapReduce和分布式文件系统"></a>MapReduce和分布式文件系统</h6><p>和大多数Unix工具一样，运行MapReduce作业通常不会修改输入，除了生成输出外没有任何副作用。虽然unix使用stdin和stout作为输入、输出，但是MR在HDFS上读写文件，一个google文件系统GFS的开源实现。<strong>与网络连接存储NAS和存储区域网络SAN架构等的共享磁盘方案相比，HDFS基于无共享原则。共享磁盘存储由集中式存储设备实现，通常使用定制硬件和专用网络基础设施(光纤通信到)，而无共享不需要特殊硬件</strong></p>
<p><strong>处理倾斜</strong><br><br>如果存在与单个键关联的大量数据，在单个reducer中收集与某个名流相关的所有活动可能导致严重倾斜，也称为热点hot spot。由于MR作业只有在所有Mapper和Reducer都完成时才完成，所以后续作业必须等待最慢的Reducer才能进行。</p>
<ul>
<li>Pig中首先运行一个抽样作业来确定哪些是热键。Mapper会将热键关联记录随机到几个reducer之一，与热键相关的记录需要被复制到所有处理该键的reducer上。这样可以更好的并行化，代价是需要连接另一侧的输入记录复制到多个reducer上。</li>
<li>Hive采用另一个方法，在表格元数据中显示指定热键，并将与这些键相关的记录单独存放，与其他文件分开，对于热键，使用Map端连接。</li>
</ul>
<h6 id="Map端连接"><a href="#Map端连接" class="headerlink" title="Map端连接"></a>Map端连接</h6><p>Mapper扮演着预处理输入数据的角色：从每个输入记录中提取键值，将键值对分配给reducer分区，按键值排序。Reduce端的优点是不需要对输入数据做任何假设，无论其属性如何，mapper都可以对其预处理以备连接。不利的是，排序、复制至reducer以及合并reducer输入，开销巨大。</p>
<p>如果能对输入数据做出某些假设，通过使用所谓的map端连接加快连接速度是可行的，这种方法使用了一个阉掉reduce与排序Mapreduce作业，每个mapper只是简单从分布式文件系统读取一个输入文件快，然后将输出文件写入文件系统。</p>
<h6 id="广播散列连接"><a href="#广播散列连接" class="headerlink" title="广播散列连接"></a>广播散列连接</h6><p>适用于Map端连接的最简单的场景是最大数据集与小数据集连接的情况。小数据集需要足够小，可以将其全部加载到每个Mapper的内存中。参与连接的较大输入的每个文件各有一个Mapper。这种简单有效的连接叫做广播散列连接：每个连接较大输入端分区的Mapper都会将较小输入端数据集整个读入内存。Pig中是复制链接，hive中叫MapJoin。也被Impala的数据仓库查询引擎使用。<strong>另一种方法是将较小输入存储在本地磁盘上的只读索引中，索引中经常使用的部分保留在OS的页面缓存中，几乎可以提供与内存散列表几乎一样的随机查找性能</strong></p>
<h6 id="广播散列连接-1"><a href="#广播散列连接-1" class="headerlink" title="广播散列连接"></a>广播散列连接</h6><p>如果map端连接的输入以相同的方式进行区分，则散列连接方法可以独立应用于每个分区。比如可以用根据用户ID最后一位十进制数字来对活动事件和用户数据库进行分区，如Mapper3首先将所有具有3结尾的ID的用户加载到散列表中，然后扫描ID为3的每个用户活动事件。如果分区无误，可能需要连接的记录都落在同一个编号的分区中。因此每个Mapper只需要从输入两端各读取一个分区就足够，好处是每个Mapper都可以在内存散列表中少放点数据。这种方法只有连接两端输入有相同的分区树，且两侧记录使用相同的键和相同哈希函数才使用。</p>
<h6 id="Map端合并连接"><a href="#Map端合并连接" class="headerlink" title="Map端合并连接"></a>Map端合并连接</h6><p>如果输入数据集不仅以相同的方式进行分区，而且还基于相同的键进行排序，还可以使用另一种map端连接的变体。这种情况下，输入是否小到能放入内存并不重要，因为这时候Mapper同样可以执行归并操作：按键递增的顺序依次读取两个输入文件，将具有相同键的记录配对。如果能进行Map端合并连接，通常意味着前一个MR作业可能一开始已经把输入数据做了分区并进行排序。</p>
<h6 id="MR工作流与Map端连接"><a href="#MR工作流与Map端连接" class="headerlink" title="MR工作流与Map端连接"></a>MR工作流与Map端连接</h6><p>当下游作业使用MR连接的输出时，选择map端连接或reduce端连接会影响输出的结构，reduce端连接的输出是按照连接键进行分区和排序的，而map端连接的输出则按照与较大输入相同的方式进行分区和排序。（无论是使用分区连接还是广播连接，连接较大输入端的每个文件块都会启动一个map任务）</p>
<p><strong>Map端连接也对输入集的大小、有序性和分区做出了很多假设。在优化连接策略时，了解分布式文件系统中数据集的物理布局很重要，仅仅知道编码格式和数据存储目录是不够的，还必须知道数据是按哪些键做的分区和排序、以及分区的数量。</strong></p>
<h5 id="批处理工作流的输出"><a href="#批处理工作流的输出" class="headerlink" title="批处理工作流的输出"></a>批处理工作流的输出</h5><p>批处理不属于事务处理，也不是分析，批处理通常会扫过输入数据集绝大部分，输出的通常不是报表而是一些其他类型的结构。</p>
<ul>
<li>建立搜索引擎。google最初使用MR为其搜索引擎建索引，至今MR仍是为Lucene/Solr构建索引的好方法。如果索引文档集合发生改变，一种选择是定期重跑整个索引工作流，并在完成后用新的索引文件批量替换以前的索引文件。优点：文档进、索引出。另一种选择，增量建立索引，如果在索引中添加、删除、更新文档，lucene会写新的段文件，并在后台异步合并压缩段文件。</li>
<li>键值存储作为批处理输出。另一个用途是构建机器学习系统，比如分类器（垃圾邮件过滤、异常检测、图像识别）与推荐系统。</li>
</ul>
<h6 id="批处理输出的哲学"><a href="#批处理输出的哲学" class="headerlink" title="批处理输出的哲学"></a>批处理输出的哲学</h6><p>Unix哲学中鼓励以显示指明数据流的方式进行试验，程序读取输入并写入输出。这一过程中，输入保持不变，任何先前的输出都被新输出完全替换，没有其他副作用。</p>
<p>MR作业输出处理遵循同样的原理，通过将输入视为不可变且避免副作用，批处理作业不仅实现良好的性能，而且更容易维护：</p>
<ul>
<li>代码中引入了错误，输出错误，简单回滚到先前版本重新运行该作业即可。</li>
<li>由于回滚容易，这种最小化不可逆性的原则有利于敏捷软件开发。</li>
<li>如果Map或Reduce任务失败，MR框架会自动重新调度，并在同样的输入上再次运行。如果是代码错误，会在几次重试后失败。</li>
<li>同一组文件可用作各种不同作业的输入，包括计算指标的监控作业可以评估作业的输出。</li>
<li>与Unix类似，MR作业将逻辑与布线（配置输入和输出目录）分离，使得关注点分离，可以重用代码。</li>
</ul>
<h6 id="存储多样性"><a href="#存储多样性" class="headerlink" title="存储多样性"></a>存储多样性</h6><p>数据库要求根据特定的模型（关系或文档）来构造数据，而分布式文件系统中文件只是字节序列，可以使用任何数据模型和编码来编写，可以使记录的集合、文本、图像、视频、稀疏矩阵、特征向量。</p>
<p>Hadoop开放了将数据不加区分的存储到HDFS的可能性，允许后续进一步处理，相比将数据导入数据库专有存储格式前，MPP数据库通常需要对数据和查询模式进行仔细的前期建模。</p>
<p>Hadoop这种方式与数据仓库类似，将大型组织各个部分的数据集中在一起是很有价值的，可以跨越以前分离的数据集进行连接，mapp数据库要求的谨慎模式设计拖慢了集中式数据收集速度。以原始形式收集数据，再操心模式的设计，能使数据收集速度加快，有时也被称为数据湖data lake或企业数据中心。</p>
<h6 id="处理模型多样性"><a href="#处理模型多样性" class="headerlink" title="处理模型多样性"></a>处理模型多样性</h6><p>MPP数据库是单体的、紧密集成的软件，负责磁盘上的存储布局、查询计划、调度和执行。</p>
<p>另一方面，并非所有类型的处理都可以合理的表达为SQL查询，比如要构建机器学习、推荐系统或者使用相关性排名模型的全文搜索索引、或者图像分析，很可能需要更一般的数据处理模型。</p>
<p>针对直接使用MR的困难，MR上有很多高级编程模型被创造出来如Pig、Hive、Cascading、Crunch。但是MR执行模型本身也有一些问题，这些问题并没有通过增加另一个抽象层次而解决，对于某些类型的处理，表现的很差经。</p>
<ul>
<li>一方面，MR非常稳健，可以使用它在任务会频繁终止的多租户系统上处理几乎任意大量级的数据。</li>
<li>另外对于某些类型的处理而言1，其他工具有时会快几个数量级</li>
</ul>
<p>很多情况下，知道一个作业的输出只能用作另一个作业的输入，这些作业由一个团队维护，这种情况下，HDFS上的文件只是中间状态：一种将数据从一个作业传递到下一个作业的方式，一个构建推荐系统的作业可能由50-100个MR作业组成的复杂工作流，存在很多中间状态。将这个中间状态写入文件的过程称为物化，<strong>意味着对某个操作结果立即求职并写出来，而不是请求时按需计算。</strong>Unix管道讲一个命令的输出与另一个命令输入连接起来，管道并没有完全物化中间状态，而只是使用一个小的内存缓冲区，将输出增量地流向输出。</p>
<p>与Unix管道相比，MR完全物化中间状态的不足之处：</p>
<ul>
<li>MR只有在前驱作业所有任务完成才能启动，而unix管道连接的进行会同时启动，输出一旦生成就会被消费。不同机器上的数据倾斜会拖慢整个工作流的执行</li>
<li>Mapper通常是多余的，仅仅是读取刚刚由reducer写入的同样的文件，为下一个阶段的分区和排序做准备。许多情况下，Mapper可能是前驱reducer一部分，如果reducer和mapper输出有着相同的分区和排序方式，那么reducer就可以直接串在一起，而不用与mapper相互交织。</li>
<li>中间状态存储在HDFS中，意味着要复制到多个节点，完全没必要</li>
</ul>
<h6 id="数据流引擎"><a href="#数据流引擎" class="headerlink" title="数据流引擎"></a>数据流引擎</h6><p>为了解决MR这些问题，几种用于分布式批处理的新执行引擎被开发出来，spark、Tez、Flink，设计方式有很多区别，但是有一个共同点：把整个工作流作为单个作业来处理，而不是把它分解为独立子作业。</p>
<p>由于它们将工作流显示建模为数据从几个处理阶段穿过，所以这些系统被称为数据流引擎，<strong>像MR它们在一条线上通过反复调用用户定义的函数来处理记录，通过分区来并行化载荷，通过网络将一个函数的输出复制到另一个函数的输入。</strong></p>
<p>与MR不同，这些功能不需要严格扮演交织的Map与Reduce的角色，而是可以用更灵活的方式进行组合。<strong>称这些函数为算子operators，数据流引擎提供了几种不同的选项来将一个算子的输出连接到另一个算子的输入：</strong></p>
<ul>
<li>一种选项是对记录按键重新分区并排序，就像在MR的混洗阶段一样，这种功能可用于实现排序合并连接和分组，就像在MR中一样</li>
<li>另一种是接受多个输入，以相同方式进行分区，但跳过排序。当记录的分区重要但顺序无关紧要时，省去了分区散列连接的工作，因为构建散列表会把顺序随机打乱；</li>
<li>对于广播散列连接，可以将一个算子的输出发送到连接算子的所有分区；</li>
</ul>
<p>这种类型的处理引擎与MR模型相比，有几个优点：</p>
<ul>
<li>排序等昂贵的工作只需要在实际需要的地方执行，而不是默认在每个map和reduce阶段之间出现</li>
<li>没有不必要的map任务，因为Mapper所做的工作通常可以合并到前面的reduce算子中（因为Mapper不会更改数据集的分区）</li>
<li>由于工作流中所有连接和数据依赖都是显示声明的，因此调度程序能够纵览全局，知道哪里需要哪些数据，因而能够利用局部性进行优化。例如可以尝试将消费某些数据的任务放在与生成这些数据的任务的相同机器上，从而数据可以通过共享内存缓冲区传输，不必通过网络复制；</li>
<li>算子的中间状态足以保存在内存或写入本地磁盘，比写入HDFS需要更少的IO（复制到多台机器）。MR已经对Mapper的输出做了这种优化，但是数据流引擎将这种思想推广至所有的中间状态；</li>
<li>算子可以在输入就绪后立即开始执行；后续阶段无需等待前驱阶段整个完成再开始；</li>
<li>与MR（为每个任务启动一个新的jvm）相比，现有jvm进程可以重用来运行新算子，减少启动开销；</li>
</ul>
<p>可以使用数据流引擎执行与MR工作流同样的计算，由于所做的优化速度也会快很多；既然算子是Map和reduce的泛化，那么相同的处理代码可以在任一执行引擎上运行。</p>
<h6 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h6><p>完全物化中间状态是分布式文件系统的一个优点：具有持久性，使得MR的容错很容易，一个任务失败，可以在另一台机器上重启，并从文件系统重新读取相同的输入。spark、flink、tez避免将中间状态写入HDFS，采取了不同策略容错，如果一台机器发生故障，会从其他可用的数据重新计算。</p>
<p>为了实现这种重新计算，框架必须跟踪一个给定的数据是如何计算的–使用了哪些分区、应用哪些算子。spark使用弹性分布式数据集RDD的抽象来跟踪数据的谱系，flink对算子的状态存档，允许恢复运行在执行过程中遇到的错误算子。</p>
<p>在重新计算数据时，重要的是要知道计算是否是确定性的：<strong>给定相同的输入数据，算子是否始终产生相同的输出，如果一些丢失的数据已经发送给下游算子，这个问题就很重要。如果算子重新启动，重新计算的数据与原有的丢失数据不一致，下游算子很难解决新旧数据之间的矛盾。对于不确定的算子，解决方法：通常是杀死下游算子，再重跑新数据。</strong></p>
<p>为了避免这种级联故障，最好让算子具有确定性，非确定性行为如：迭代哈希表的元素时不能对顺序做出保证、许多概率和统计算法显示依赖于使用随机数，以及用到系统时钟或外部数据源，这些都是不确定行为。为了能可靠的从故障中恢复，需要消除这种不确定因素，比如使用固定种子生成伪随机数。</p>
<p>通过重计算数据来从故障中恢复并不总是正确的答案：如果中间状态数据比源数据小得多或者计算量非常大，那么中间数据物化为文件可能要比重新计算廉价的多。</p>
<h6 id="关于物化的讨论"><a href="#关于物化的讨论" class="headerlink" title="关于物化的讨论"></a>关于物化的讨论</h6><p>MR就像是将每个命令的输出写入临时文件，而数据流引擎更像是Unix管道，尤其Flink是基于管道执行的思想而建立的，即将算子的输出增量的传递给其他算子，不待输入完成就开始处理。</p>
<p>排序算子需要消费全部输入后才能生成任何输入，因为输入中最后一条输入记录可能具有最小的键，因此需要作为第一条记录输出。因此任何需要排序的算子都需要至少暂时的累计状态，工作流的许多其他部分都可以以流水线方式执行。</p>
<h6 id="图与迭代处理"><a href="#图与迭代处理" class="headerlink" title="图与迭代处理"></a>图与迭代处理</h6><p>批处理上下文的图很有趣，目标是在整个图上执行某种离线处理或分析。这种需求经常出现在机器学习应用或排序系统中。如最著名的图形分析算法之一的PageRank，试图根据链接到某个网页的其他网页来估计该网页的流行度，作为配方的一部分，用于确定网络搜索引擎呈现结果的排序。</p>
<p>像Spark、Flink、Tez这样的数据流引擎通常将算子作为有向无环图DAG的一部分安排在作业中，与图处理不一样：在数据流引擎中，从一个算子到另一个算子的数据流被构造成一个图，而数据本身通常由关系型元祖构成，在图处理中，数据本身具有图的形式。</p>
<p>许多图算法是通过一次遍历一条边来表示，将一个顶点与近邻的顶点连接起来，以传播一些信息不断重复，直到满足一些条件为止，如直到没有更多的边要跟进或直到一些指标收敛。比如重复跟进标明地点归属关系的边，生成数据库中北美包含的所有地点列表。（这种算法也被称为闭包传递）</p>
<p>可以在分布式文件系统中存储图（包含顶点和边的列表的文件），但是这种重复至完成的想法不能用MR表示，因为只扫过一趟数据，通常以迭代风格实现：</p>
<ul>
<li>外部调度程序运行批处理来计算算法的一个步骤</li>
<li>当批处理过程完成时，调度器检查它是否完成（基于完成条件，如没有更多的边要跟进，或与上次迭代相比的变化低于某个阈值）</li>
<li>如果尚未完成，则调度程序返回到步骤1运行另一轮批处理</li>
</ul>
<p>这种方法有效但是MR实现往往很低效，因为MR没考虑迭代性质：它总是读取整个输入数据集，即使与上次迭代相比改变的仅仅是图中一小部分。</p>
<h6 id="Pregel处理模型"><a href="#Pregel处理模型" class="headerlink" title="Pregel处理模型"></a>Pregel处理模型</h6><p>针对图批处理的优化—批量同步并行BSP计算模型已经开始流行起来，其中Apache Giraph、Spark的Graph X和Flink的Gelly API实现了它，也被称为Pregel模型，因为google的pregel论文推广了这种处理图的方法。</p>
<p>MR中，mapper在概念上向reducer的特定调用发送消息，因为框架将所有具有相同键的mapper输出集中在一起，Pregel后面有一个类似想法：<strong>一个顶点可以向另一个顶点发送消息，通常这些消息是沿着图的边发送的</strong></p>
<p>每次迭代中，为买个顶点调用一个函数，将所有发送给它的消息传递给它，就像调用reducer一样，与MR不同之处在于，在Pregel模型中，顶点在一次迭代到下一次迭代过程中会记住它的状态，所以这个函数只需要处理新的传入消息。如果图的某个部分没有被发送消息，那里就不需要做任何工作。</p>
<p>与Actor模型有些相似，除了顶点状态和顶点之间的消息具有容错性和耐久性，且通信以固定的方式进行：在每次迭代中，框架递送上次迭代中发送的所有消息，actor通常没有这样的时间保证。</p>
<h6 id="容错-1"><a href="#容错-1" class="headerlink" title="容错"></a>容错</h6><p>顶点只能通过消息传递有助于提高pregel作业的性能，因为消息可以批处理。唯一的等待是在迭代之间：由于pregel模型保证所有在一轮迭代中发送的消息都在下轮迭代中送达，所以在下一轮迭代开始前，先前的迭代必须完全完成，而所有消息必须在网络上完成复制。即使底层网络可能丢失、重复或任意延迟消息，pregel的实现能保证在后续迭代中，消息在其目标顶点恰好处理一次。即使底层网络可能丢失、重复、任意延迟，也能保证在后续迭代中消息在其目标顶点恰好处理一次。像MR一样，框架能从故障中透明的恢复，以简化在pregel上实现算法的编程模型。</p>
<p>这种容错通过在迭代结束，定期存档所有顶点状态实现，即将其全部状态写入持久化存储。如果某个节点发生故障且其内存中状态丢失，简单的解决方法是将整个图计算回滚到上一个存档点</p>
<h6 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h6><p>顶点不需要知道它在哪台物理机器上执行，当它向其他顶点发送消息时，只是简单将消息发往某个顶点ID。图的分区取决于框架，即哪个顶点运行在哪台机器上，以及如何通过网络路由消息。理想情况需要大量通信，最好能被分区到同一台机器上，实践中经常按照任意分配顶点ID分区，图算法通常会有跨机通信的额外开销，而中间状态往往比原始图大，通过网络发送消息的开销会显著拖慢分布式图算法速度。</p>
<h6 id="声明式查询语言"><a href="#声明式查询语言" class="headerlink" title="声明式查询语言"></a>声明式查询语言</h6><p>与硬写连接代码相比，指定连接关系算子的优点：框架可以分析连接输入的属性，并自动决定哪种上述连接算法最适合当前任务。甚至可以改变连接顺序，最小化中间状态的数量。</p>
<p>MR及其后继者数据流在其他方面与SQL的完全声明式查询模型有很大区别，MR是围绕着回调函数的概念产生的：对于每条记录或一组记录，调用一个用户定义的函数，并且该函数可以自由的调用任意代码来决定输出什么。优点：可以基于大量已有库的生态系统创作：解析、自然语言分析、图像分析以及运行数值算法或统计计算法。</p>
<p><strong>自由运行任意代码长期以来都是传统MR批处理系统与MPP数据库的区别所在。</strong>虽然数据库具有编写用户定义函数的功能，但是使用麻烦，而且与大多数编程语言中广泛使用的程序包管理器和依赖管理系统兼容不佳。（java的mvn js的npm ruby的gems）</p>
<p>数据流引擎支持除连接之外的更多声明特性还有其他优势，如果一个回调函数只包含一个简单过滤条件、或者只是从一条记录选择一些字段，那么在为每条记录调用函数时会有相当大CPU开销。如果以声明式方式表示这些简单的过滤和映射操作，那么查询优化器可以利用面向列的存储布局，只从磁盘读取所需的列。hive、spark dataframes和Impala还使用了向量化执行，在对cpu缓存友好的内部循环中迭代数据，避免函数调用。Spark生成jvm字节码，impala使用LLVM为这些内部循环生成本机代码。<br>通过在高级API引入声明式部分，批处理框架看起来越来越像MPP数据库了；同时通过拥有运行任意代码和以任意格式读取数据的可扩展性，保持了灵活性的优势。</p>
<h4 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h4><p>“流”是指随着时间推移可用的数据，这个概念出现在很多的地方：Unix的stdin、stdout，编程语言的惰性列表、文件系统API（如java的FileInputStream）、Tcp连接，通过互联网传递音频和视频。将事件流event stream视为一种数据管理机制：<strong>无界限 增量处理。</strong></p>
<p>发布/订阅模式中，不同系统采取各种各样方法，并没有针对所有的目的的通用答案：</p>
<ul>
<li>如果生产者发送消息的速度比消费者处理的速度快，有三种选择：系统丢掉消息，将消息放入缓冲队列或使用背压(backpressure)【也称为流量控制flow control】，即阻塞生产者，以免发送更多消息。例如Unix和TCP使用背压：它们有一个固定大小的小缓冲区，如果填满，发送者会被阻塞，直到接收者从缓冲区取出数据。</li>
<li>如果节点崩溃或暂时脱机，是否有消息丢失？与数据库一样，持久性可能需要写入磁盘/或复制的某种组合。如果能接受有时消息会丢失，则可能在同一硬件上获得更高的吞吐量和更低的延迟。</li>
</ul>
<p>直接从生产者传递给消费者（不通过中间节点）：</p>
<ul>
<li>UDP组播广泛用于金融行业，例如股票市场，其中低时延很重要，虽然UDP本身不可靠，但应用层协议可以恢复丢失的数据包</li>
<li>无代理的消息库，如ZeroMQ和nanomsg采取类似的方法，通过TCP或IP多播实现发布/订阅消息传递；</li>
<li>StatsD和Brubeck使用不可靠的UDP消息传递来收集网络中所有机器的指标并对其进行监控。</li>
<li>如果消费者在网络上公开了服务，生产者可以直接发送HTTP或RPC请求。</li>
</ul>
<p>尽管这些直接消息传递在设计它们的环境中运行良好，但是它们通常要求应用代码意识到消息丢失的可能性。容错程度极为有限：即使协议检测到并重传在网络中丢失的数据包，它们通常也只是假设生产者和消费者始终在线。如果消费者处于脱机状态，可能会丢失其不可达时发送的消息。</p>
<h6 id="消息代理"><a href="#消息代理" class="headerlink" title="消息代理"></a>消息代理</h6><p>一种广泛的替代方法是通过消息代理发送消息，消息代理实质上是一种针对处理消息流而优化的数据库。排队的结果是，消费者通常是异步的，会有一定的延迟。</p>
<p>周期性的完整数据转储过于缓慢，有时会使用双写double write，其中应用代码在数据变更时明确写入每个系统，例如先写入数据库，再更新搜索引擎，然后使缓存失效。双写会产生竞争条件。</p>
<h6 id="变更数据捕获"><a href="#变更数据捕获" class="headerlink" title="变更数据捕获"></a>变更数据捕获</h6><p>数十年来，许多数据库根本没有记录在档的，获取变更日志的方式。由于这个原因，捕获数据库中的所有变更，然后将其复制到其他存储引擎中（搜索索引、缓存、数据仓库）。</p>
<p>处理流以产生其它衍生流，处理这样的流的代码片段，被称为算法operator或作业job。数据流的模式是相似的：一个流出器以只读的方式使用输入流，并将其输出已追加的方式写入一个不同的位置。</p>
<p>流处理的应用，一直用于监控目的，如果某个事件发生，单位希望得到警报：</p>
<ul>
<li>欺诈检测</li>
<li>交易系统的价格变化</li>
<li>制造系统需要监控工厂机器的状态</li>
<li>军事和情报系统需要跟踪潜在的侵略者活动</li>
</ul>
<h6 id="流分析"><a href="#流分析" class="headerlink" title="流分析"></a>流分析</h6><p>使用流处理的另一个领域是对流进行分析，CEP(complex event and processing)符合事件处理与流分析的边界是模糊的，分析往往对找出特定事件序列并不关心，而更关注大量事件上的聚合和统计指标：</p>
<ul>
<li>测量某种类型事件的速率</li>
<li>滚动计算一段时间窗口内某个值得平均值</li>
<li>将当前统计值与先前的时间区间的值对比（如检测趋势 当指标与上周同比异常偏离或偏低时报警）</li>
</ul>
<p>这些统计值通常是在固定时间区间内进行计算的，如过去5min内服务每秒查询次数的均值，以及此时间段内响应时间的第99百分位点，<strong>有时系统会使用概率算法，如Bloom filter、HyperLogLog用于基数估计以及各种百分比估计算法。</strong>概率算法产出近似值的结果，比起精确算法的优点是内存使用要少得多。</p>
<h6 id="窗口的类型"><a href="#窗口的类型" class="headerlink" title="窗口的类型"></a>窗口的类型</h6><ul>
<li>滚动窗口Tumbling window。滚动窗口有着固定长度，比如10:00和10:05都会被分组到一个窗口</li>
<li>跳动窗口(Hopping Window)。跳动窗口也有着固定的长度，但允许窗口重叠以提供一些平滑。窗口之间有交叉。</li>
<li>滑动窗口。并不断从窗口移除过期的旧事件。</li>
<li>会话窗口。将同一用户出现时间相近的所有时间分组在一起。</li>
</ul>
<p>流式连接（窗口连接）：在流中搜索结果。<br>流表连接，如用户活动事件和用户档案数据库。表表连接。</p>
<h4 id="数据系统的未来"><a href="#数据系统的未来" class="headerlink" title="数据系统的未来"></a>数据系统的未来</h4><p>数据集成的目标，确保数据最终能在所有正确的地方表现出正确的形式。需要消费输入、转换、连接、过滤、聚合、训练模型、评估。批处理和流处理的输出是衍生数据集，例如搜索索引、物化视图，向用户显示的建议，聚合指标等等；</p>
<p>spark在批处理引擎上执行流处理，将流分解为微批次，flink则在流处理引擎上执行批处理。原则上一种类型的处理可以用另一种类型来模拟，但是性能特征会有所不同。</p>
<h5 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h5><p>Lambda架构的核心思想是通过将不可变事件附加到不断增长的数据集来记录传入数据，这类似于时间溯源。为了从这些事件中衍生出读取优化的视图，Lambda架构建议并行运行两个不同系统：批处理系统和独立的流处理系统。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/01/18/kotlin协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/kotlin协程/" itemprop="url">kotlin协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T22:18:36+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-协程基础"><a href="#1-协程基础" class="headerlink" title="1. 协程基础"></a>1. 协程基础</h4><h5 id="1-1-第一个coroutine程序"><a href="#1-1-第一个coroutine程序" class="headerlink" title="1.1 第一个coroutine程序"></a>1.1 第一个coroutine程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    GLobalScope.launch&#123;</span><br><span class="line">        delay(1000L) //后台建一个全局协程</span><br><span class="line">        println(&quot;world,&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)//主线程不会被delay阻塞</span><br><span class="line">    Thread.sleep(2000L)//阻塞主线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,</span><br><span class="line">world</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-将阻塞和非阻塞桥接起来"><a href="#1-2-将阻塞和非阻塞桥接起来" class="headerlink" title="1.2 将阻塞和非阻塞桥接起来"></a>1.2 将阻塞和非阻塞桥接起来</h5><p>上面一个示例将非阻塞方法(non-blocking)和阻塞方法Thread.sleep写在一个方法块中，很容易混淆哪一部分是阻塞，哪一部分不是阻塞。可以利用runblocking这种协程的builder使阻塞更加明确。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(vararg args: String) &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)//主线程立即执行</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        delay(2000L)//延迟2s，使jvm保持活跃</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果相同，但是这块代码只使用了非阻塞delay。主线程执行runBlocking，内部阻塞了协程，直到runblocking完成。<br>也可以使用更加符合语言习惯的写法，利用runBlocking包括主函数的执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt;&#123; //启动main协程</span><br><span class="line">    GLobalScope.launch&#123; //新建一个协程</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;) //主协程立即执行</span><br><span class="line">    delay(2000L) //延迟2s，使jvm保持活跃</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-3-等待一个job"><a href="#1-3-等待一个job" class="headerlink" title="1.3 等待一个job"></a>1.3 等待一个job</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch &#123; //新建一个协程</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)</span><br><span class="line">    job.join() //等到子协程完成 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-4-结构化并发"><a href="#1-4-结构化并发" class="headerlink" title="1.4 结构化并发"></a>1.4 结构化并发</h5><p>GlobalScope.launch是一个top-level协程，虽然是一个轻量级的，但是运行时仍然会消耗内存。如果创建太多，仍然会很消耗性能。<br>有一个更好的方法，就是在代码中结构化并发的代码。不在GlobalScope范围内新建协程，可以在一个明确范围内启动一个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; //CoroutineScope</span><br><span class="line">    launch &#123; //在runBlocking范围内新建一个协程</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-5-Scope-builder"><a href="#1-5-Scope-builder" class="headerlink" title="1.5 Scope builder"></a>1.5 Scope builder</h5><p>除了不同的builder已经提供的协程范围，我们自己定义coroutineScope也是可以的。创建一个新的携程范围，直到所有子协程执行完毕，它才会结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; // this CoroutineScope</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;first&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineScope &#123; //新建一个coroutine范围</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(500)</span><br><span class="line">            println(&quot;second&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(100)</span><br><span class="line">        println(&quot;third&quot;) //嵌套的执行完，这一行才会输出</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;over&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-6-抽取阻塞的代码块"><a href="#1-6-抽取阻塞的代码块" class="headerlink" title="1.6 抽取阻塞的代码块"></a>1.6 抽取阻塞的代码块</h5><p>我们可以将launch{}代码块放进独立的方法，当你使用这种方式时，需要在重构的方法前面加上suspend，这种方法可以在协程内部调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doWorld() &#123;</span><br><span class="line">    delay(1000L)</span><br><span class="line">    println(&quot;World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>coroutine是更加轻量的，一个线程可以轻而易举创建上百万协程。速度比线程更快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&#123;</span><br><span class="line">    repeat(100_000)&#123;</span><br><span class="line">        launch&#123;</span><br><span class="line">            delay(1000)</span><br><span class="line">            print(.)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-7-global-coroutines就像是守护线程"><a href="#1-7-global-coroutines就像是守护线程" class="headerlink" title="1.7 global coroutines就像是守护线程"></a>1.7 global coroutines就像是守护线程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 回退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-协程的取消和超时"><a href="#2-协程的取消和超时" class="headerlink" title="2. 协程的取消和超时"></a>2. 协程的取消和超时</h4><h5 id="2-1-取消协程的执行"><a href="#2-1-取消协程的执行" class="headerlink" title="2.1 取消协程的执行"></a>2.1 取消协程的执行</h5><p>在一个运行时间很长的应用中，在运行完后，需要将任务取消掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        repeat(1000) &#123;</span><br><span class="line">            println(&quot;sleep $it&quot;)</span><br><span class="line">            delay(500)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(2300)</span><br><span class="line">    job.cancel() //将任务取消</span><br><span class="line">    job.join() //等待任务完毕</span><br><span class="line">    println(&quot;quit now&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-协程的取消应该是协作式的"><a href="#2-2-协程的取消应该是协作式的" class="headerlink" title="2.2 协程的取消应该是协作式的"></a>2.2 协程的取消应该是协作式的</h5><p>协程的取消应该是协作式的。所有suspend方法都是可以取消的。如果一个还在工作的协程被取消，那么它是不会被取消的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    //任务开始</span><br><span class="line">    val startTime = System.currentTimeMillis()</span><br><span class="line">    val job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        var nextPrintTime = startTime</span><br><span class="line">        var i = 0</span><br><span class="line">        while (i &lt; 5) &#123; // 执行一个计算逻辑</span><br><span class="line">            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;)</span><br><span class="line">                nextPrintTime += 500L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 延迟一会</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() //等待任务完成</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3-内置的isActive判断协程执行状态"><a href="#2-3-内置的isActive判断协程执行状态" class="headerlink" title="2.3 内置的isActive判断协程执行状态"></a>2.3 内置的isActive判断协程执行状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val startTime = System.currentTimeMillis()</span><br><span class="line">    val job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        var nextPrintTime = startTime</span><br><span class="line">        var i = 0</span><br><span class="line">        while (isActive) &#123; // cancellable computation loop</span><br><span class="line">            // print a message twice a second</span><br><span class="line">            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;)</span><br><span class="line">                nextPrintTime += 500L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4-finally取消任务"><a href="#2-4-finally取消任务" class="headerlink" title="2.4 finally取消任务"></a>2.4 finally取消任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">                delay(500L)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;I&apos;m running finally&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-NonCancellable使任务变为不可取消"><a href="#2-5-NonCancellable使任务变为不可取消" class="headerlink" title="2.5 NonCancellable使任务变为不可取消"></a>2.5 NonCancellable使任务变为不可取消</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">                delay(500L)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(&quot;I&apos;m running finally&quot;)</span><br><span class="line">                delay(1000L)</span><br><span class="line">                println(&quot;And I&apos;ve just delayed for 1 sec because I&apos;m non-cancellable&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-6-超时"><a href="#2-6-超时" class="headerlink" title="2.6 超时"></a>2.6 超时</h5><p>给一个协程任务设置超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    withTimeout(1300L) &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会发现withTimeout会抛出timeoutCancellationException。我们可以使用try catch或者使用withTimeoutOrNull返回一个空值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val result = withTimeoutOrNull(1300L) &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;Done&quot; // will get cancelled before it produces this result</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Result is $result&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-编写suspend函数"><a href="#3-编写suspend函数" class="headerlink" title="3. 编写suspend函数"></a>3. 编写suspend函数</h4><h5 id="3-1-串行执行"><a href="#3-1-串行执行" class="headerlink" title="3.1 串行执行"></a>3.1 串行执行</h5><p>假设我们有两个suspend函数，需要两个协程按顺序执行。想要获得A函数和B函数的和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val time = measureTimeMillis&#123;</span><br><span class="line">        val sum1 = sum1()</span><br><span class="line">        val sum2 = sum2()</span><br><span class="line">        println(&quot;sum is $&#123;sum1+sum2&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;time cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun sum1():Int&#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 12</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum2():Int&#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-并发使用async"><a href="#2-2-并发使用async" class="headerlink" title="2.2 并发使用async"></a>2.2 并发使用async</h5><p>有些方法间是没有相关性的，想要更快的得到结果，可以使用async提高性能。async类似launch，也是一个轻量级的线程。不同点是launch返回一个job，async返回一个非阻塞的future。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val sum1 = async &#123; sum1() &#125;</span><br><span class="line">        val sum2 = async &#123; sum2() &#125;</span><br><span class="line">        println(&quot;sum is $&#123;sum1.await() + sum2.await()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;time cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum1(): Int &#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 12</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum2(): Int &#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3-延迟启动async"><a href="#2-3-延迟启动async" class="headerlink" title="2.3 延迟启动async"></a>2.3 延迟启动async</h5><p>可以设置async在调用start或async的时候，才执行async中的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        // some computation</span><br><span class="line">        one.start() // start the first one</span><br><span class="line">        two.start() // start the second one</span><br><span class="line">        println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here, too</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不调用start，和串行执行等价。</p>
<h5 id="2-4-异步执行的方法"><a href="#2-4-异步执行的方法" class="headerlink" title="2.4 异步执行的方法"></a>2.4 异步执行的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun somethingUsefulOneAsync() = GlobalScope.async &#123;</span><br><span class="line">    doSomethingUsefulOne()</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-用async结构化并发"><a href="#2-5-用async结构化并发" class="headerlink" title="2.5 用async结构化并发"></a>2.5 用async结构化并发</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        println(&quot;The answer is $&#123;concurrentSum()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br><span class="line">suspend fun concurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    val two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">     one.await() + two.await()</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here, too</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的方法和exception结合在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        failedConcurrentSum()</span><br><span class="line">    &#125; catch(e: ArithmeticException) &#123;</span><br><span class="line">        println(&quot;Computation failed with ArithmeticException&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">suspend fun failedConcurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            delay(Long.MAX_VALUE) // Emulates very long computation</span><br><span class="line">            42</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;First child was cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val two = async&lt;Int&gt; &#123;</span><br><span class="line">        println(&quot;Second child throws an exception&quot;)</span><br><span class="line">        throw ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-协程的上下文和调度器"><a href="#3-协程的上下文和调度器" class="headerlink" title="3. 协程的上下文和调度器"></a>3. 协程的上下文和调度器</h4><h5 id="3-1-调度器和线程"><a href="#3-1-调度器和线程" class="headerlink" title="3.1 调度器和线程"></a>3.1 调度器和线程</h5><p>协程上下文包括了协程调度器，其决定了用哪个线程去执行。协程调度器限制了了指定线程去执行，由某个线程、线程池或无限制。<br>所有的协程builder像launch、async都会接受一个CoroutineContext的参数，这个参数可以明确的指定这个调度器为这个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch &#123; // context of the parent, main runBlocking coroutine</span><br><span class="line">        println(&quot;main runBlocking      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread</span><br><span class="line">        println(&quot;Unconfined            : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; // will get dispatched to DefaultDispatcher</span><br><span class="line">        println(&quot;Default               : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) &#123; // will get its own new thread</span><br><span class="line">        println(&quot;newSingleThreadContext: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>launch{…}</strong> 这种无参使用，默认集成启动的CoroutineScope的上下文，或者main函数的runBlocking。</p>
<p><strong>Dispatcher.Unconfined</strong> 是一个特殊的调度器，也会出现在main线程中。</p>
<p>默认的调度器<strong>default</strong>，当协程以GlobalScope方式启时， 而且以Dispatchers.Default表示，用的是共享的后台线程池，因此<strong>launch(Dispatchers.Default){…}</strong>用的是和GlobalScope.launch{…}的方式。</p>
<h5 id="3-2-约束性和非约束的调度"><a href="#3-2-约束性和非约束的调度" class="headerlink" title="3.2 约束性和非约束的调度"></a>3.2 约束性和非约束的调度</h5><p>非约束性调度器适合不消耗CPU、也不会更新共享数据的协程，这种协程会指定给特定的线程。约束性调度器在遇到第一个暂停点(suspend)之前，执行的都是调用者线程。遇到suspend函数后，用的是suspend方法决定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread</span><br><span class="line">        println(&quot;Unconfined      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;Unconfined      : After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123; // context of the parent, main runBlocking coroutine</span><br><span class="line">        println(&quot;main runBlocking: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;main runBlocking: After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unconfined      : I&apos;m working in thread main [遇到delay前]</span><br><span class="line">main runBlocking: I&apos;m working in thread main</span><br><span class="line">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor [遇到delay后]</span><br><span class="line">main runBlocking: After delay in thread main</span><br></pre></td></tr></table></figure></p>
<h5 id="3-3-协程和线程的调试"><a href="#3-3-协程和线程的调试" class="headerlink" title="3.3 协程和线程的调试"></a>3.3 协程和线程的调试</h5><p>协程可以在一个线程中挂起，或者在另一线程中恢复。即使使用单线程调度程序，也很难确定协程何时、何地做了什么。<br>启动程序的时候加上：<strong>-Dkotlinx.coroutines.debug</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val a = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing a piece of the answer&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    val b = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing another piece of the answer&quot;)</span><br><span class="line">        7</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer is $&#123;a.await() * b.await()&#125;&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#2] I&apos;m computing a piece of the answer</span><br><span class="line">[main @coroutine#3] I&apos;m computing another piece of the answer</span><br><span class="line">[main @coroutine#1] The answer is 42</span><br></pre></td></tr></table></figure></p>
<p>可以看出日志会输出线程名称、协程名称。</p>
<h5 id="3-4-在线程间跳跃"><a href="#3-4-在线程间跳跃" class="headerlink" title="3.4 在线程间跳跃"></a>3.4 在线程间跳跃</h5><p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    newSingleThreadContext(&quot;Ctx1&quot;).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(&quot;Ctx2&quot;).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(&quot;Started in ctx1&quot;)</span><br><span class="line">                withContext(ctx2) &#123;</span><br><span class="line">                    log(&quot;Working in ctx2&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;Back to ctx1&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>展示了两种技术，一个是使用runBlocking给其指定上下文，另外一个就是使用withContext，改变一个协程的上下文，但是仍然在一个协程内。</p>
<h5 id="3-5-上下文中的job"><a href="#3-5-上下文中的job" class="headerlink" title="3.5 上下文中的job"></a>3.5 上下文中的job</h5><p>协程的job是上下文的一部分，协程可以使用coroutineContext。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    println(&quot;My job is $&#123;coroutineContext[Job]&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-6-协程的子协程"><a href="#3-6-协程的子协程" class="headerlink" title="3.6 协程的子协程"></a>3.6 协程的子协程</h5><p>当在另一个协程中的CoroutineScope中启动一个协程，它继承了其coroutineContext。当父协程取消，子协程也会被递归的取消。<br>当GlobalScope被用来启动一个协程，这种启动方式时独立启动,不被父协程影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    // launch a coroutine to process some kind of incoming request</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        // it spawns two other jobs, one with GlobalScope</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(&quot;job1: I run in GlobalScope and execute independently!&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job1: I am not affected by cancellation of the request&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        // and the other inherits the parent context</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            println(&quot;job2: I am a child of the request coroutine&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(500)</span><br><span class="line">    request.cancel() // cancel processing of the request</span><br><span class="line">    delay(1000) // delay a second to see what happens</span><br><span class="line">    println(&quot;main: Who has survived request cancellation?&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-7-父协程等待子协程"><a href="#3-7-父协程等待子协程" class="headerlink" title="3.7 父协程等待子协程"></a>3.7 父协程等待子协程</h5><p>父协程会等待所有子协程执行完毕，父协程不用显示的追踪子协程，也不用使用job.join，如果想要保证在job完成后执行某个逻辑，可以使用job.join。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // launch a coroutine to process some kind of incoming request</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        repeat(3) &#123; i -&gt; // launch a few children jobs</span><br><span class="line">            launch  &#123;</span><br><span class="line">                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;request: I&apos;m done and I don&apos;t explicitly join my children that are still active&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    request.join() // wait for completion of the request, including all its children</span><br><span class="line">    println(&quot;Now processing of the request is complete&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-8-协程的命名"><a href="#3-8-协程的命名" class="headerlink" title="3.8 协程的命名"></a>3.8 协程的命名</h5><p>为了方便协程的追踪，也可以给协程命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking(CoroutineName(&quot;main&quot;)) &#123;</span><br><span class="line">    log(&quot;Started main coroutine&quot;)</span><br><span class="line">    // run two background value computations</span><br><span class="line">    val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) &#123;</span><br><span class="line">        delay(500)</span><br><span class="line">        log(&quot;Computing v1&quot;)</span><br><span class="line">        252</span><br><span class="line">    &#125;</span><br><span class="line">    val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        log(&quot;Computing v2&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer for v1 / v2 = $&#123;v1.await() / v2.await()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-9-将上下文连起来"><a href="#3-9-将上下文连起来" class="headerlink" title="3.9 将上下文连起来"></a>3.9 将上下文连起来</h5><p>有时我们需要为协程的上线定义很多成分，我们可以使用+符号。例如我们用一个显示指定的调度器和一个显示指定的名启动一个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Default + CoroutineName(&quot;test&quot;)) &#123;</span><br><span class="line">        println(&quot;I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-10-显示job的取消"><a href="#3-10-显示job的取消" class="headerlink" title="3.10 显示job的取消"></a>3.10 显示job的取消</h5><p>将上下文、子协程、任务综合在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Activity : CoroutineScope &#123;</span><br><span class="line">    lateinit var job: Job</span><br><span class="line"></span><br><span class="line">    fun create() &#123;</span><br><span class="line">        job = Job()</span><br><span class="line">    &#125;</span><br><span class="line">    fun destroy() &#123;</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    // to be continued ...</span><br><span class="line"></span><br><span class="line">    // class Activity continues</span><br><span class="line">    override val coroutineContext: CoroutineContext</span><br><span class="line">        get() = Dispatchers.Default + job</span><br><span class="line">    // to be continued ...</span><br><span class="line">    // class Activity continues</span><br><span class="line">    fun doSomething() &#123;</span><br><span class="line">        // launch ten coroutines for a demo, each working for a different time</span><br><span class="line">        repeat(10) &#123; i -&gt;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // class Activity ends</span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val activity = Activity()</span><br><span class="line">    activity.create() // create an activity</span><br><span class="line">    activity.doSomething() // run test function</span><br><span class="line">    println(&quot;Launched coroutines&quot;)</span><br><span class="line">    delay(500L) // delay for half a second</span><br><span class="line">    println(&quot;Destroying activity!&quot;)</span><br><span class="line">    activity.destroy() // cancels all coroutines</span><br><span class="line">    delay(1000) // visually confirm that they don&apos;t work</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Launched coroutines</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Destroying activity!</span><br></pre></td></tr></table></figure></p>
<h5 id="3-11-Thread-local"><a href="#3-11-Thread-local" class="headerlink" title="3.11 Thread-local"></a>3.11 Thread-local</h5><p>多线程中有thread-local，但是对协程而言，并不和特定的线程绑定。<br>对于ThreadLocal，扩展方法asContextElement就是来解决这种问题的。它创建一个额外的上下文环境组件，每次协程切换上下文，将会恢复它的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val threadLocal = ThreadLocal&lt;String?&gt;() // declare thread-local variable</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    threadLocal.set(&quot;main&quot;)</span><br><span class="line">    println(&quot;Pre-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = &quot;launch&quot;)) &#123;</span><br><span class="line">       println(&quot;Launch start, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">        yield()</span><br><span class="line">        println(&quot;After yield, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    println(&quot;Post-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，使用Dispatchers.Default新启动了一个协程，因此它在一个线程池里不同的线程中工作。使用了threadLocal.asContextElement(value=”launch”)不管协程怎么切换线程，输出结果都是不变的。<br>其中有一个关键的限制：当threadlocal是发生突变，一个新的值并不会传播到协程调用者，因为上下文不能跟踪所有的threadLocal对象访问，并且更新的值将会在下一个暂停点丢失，使用withContext去更新协程中的threadLocal.</p>
<h4 id="4-处理异常与监控"><a href="#4-处理异常与监控" class="headerlink" title="4. 处理异常与监控"></a>4. 处理异常与监控</h4><h5 id="4-1-异常的继承"><a href="#4-1-异常的继承" class="headerlink" title="4.1 异常的继承"></a>4.1 异常的继承</h5><p>协程构建有两种风格，自动继承（launch actor）或者将其暴露给用户（async produce）。前者将异常视为未处理，类似java中Thread.uncaughtExceptionHandler，后者依赖用户执行报错，比如去消费、调用。通过await或者receive的方式。</p>
<h5 id="4-2-取消和异常"><a href="#4-2-取消和异常" class="headerlink" title="4.2 取消和异常"></a>4.2 取消和异常</h5><p>取消和异常严格绑定在一起的，协程中使用cancellationException处理cancellation。这些异常可以被handler忽略。可以通过catch块捕获。</p>
<h5 id="4-3-异常聚合"><a href="#4-3-异常聚合" class="headerlink" title="4.3 异常聚合"></a>4.3 异常聚合</h5><p>多个子协程都抛错，第一个异常将会被捕获。这样可能会导致丢失一些异常，例如一个协程在finally中抛异常，但是额外的异常被抑制了。</p>
<h5 id="4-4-监控"><a href="#4-4-监控" class="headerlink" title="4.4 监控"></a>4.4 监控</h5><p>取消是协程层次结构传播的双向关系，如果需要单向取消，该如何处理。<br>很好的示例是一个服务器进程，生成多个子作业，并且需要监视他们的执行、跟踪故障，并重新启动已经失败的子作业。</p>
<h5 id="4-5-监控范围"><a href="#4-5-监控范围" class="headerlink" title="4.5 监控范围"></a>4.5 监控范围</h5><p>对于作用域的并发，可以使用supervisorScope代替coroutineScope。只是单向传播取消，只有主进程失败，所有子协程才会被取消。</p>
<h4 id="5-channel"><a href="#5-channel" class="headerlink" title="5. channel"></a>5. channel</h4><p>deferred values（延迟值）提供了一种方便的方式在协程间传递单个的值。channels提供一种传输流的方法。</p>
<h5 id="5-1-channel基础概念"><a href="#5-1-channel基础概念" class="headerlink" title="5.1 channel基础概念"></a>5.1 channel基础概念</h5><p>channel和blockingQueue非常像，一个关键的不同点是：suspend -&gt; put，suspend receive -&gt; take</p>
<h5 id="5-2-channel的关闭和迭代"><a href="#5-2-channel的关闭和迭代" class="headerlink" title="5.2 channel的关闭和迭代"></a>5.2 channel的关闭和迭代</h5><p>和队列不同，通道的关闭表明没有更多的元素。receiver端，可以使用for循环从channel中取元素。<br>channel的关闭就像是给channel发送一个特殊的token，表示channel已经关闭了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;Int&gt;()</span><br><span class="line">    launch &#123;</span><br><span class="line">        for (x in 1..5) channel.send(x * x)</span><br><span class="line">        channel.close() // we&apos;re done sending</span><br><span class="line">    &#125;</span><br><span class="line">    // here we print received values using `for` loop (until the channel is closed)</span><br><span class="line">    for (y in channel) println(y)</span><br><span class="line">    println(&quot;Done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-3-build一个channel的producer"><a href="#5-3-build一个channel的producer" class="headerlink" title="5.3 build一个channel的producer"></a>5.3 build一个channel的producer</h5><p>并发场景中的生产/消费模式，下面就抽象出一个producer模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.produceSquares(): ReceiveChannel&lt;Int&gt; = produce &#123;</span><br><span class="line">    for (x in 1..5) send(x * x)</span><br><span class="line">&#125;</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val squares = produceSquares()</span><br><span class="line">    squares.consumeEach &#123; println(it) &#125;</span><br><span class="line">    println(&quot;Done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-4-pipelines"><a href="#5-4-pipelines" class="headerlink" title="5.4 pipelines"></a>5.4 pipelines</h5><p>pipeline是一种协程生产的模式，可能是无限的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val numbers = produceNumbers() // produces integers from 1 and on</span><br><span class="line">    val squares = square(numbers) // squares integers</span><br><span class="line">    for (i in 1..5) println(squares.receive()) // print first five</span><br><span class="line">    println(&quot;Done!&quot;) // we are done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; &#123;</span><br><span class="line">    var x = 1</span><br><span class="line">    while (true) send(x++) // infinite stream of integers starting from 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.square(numbers: ReceiveChannel&lt;Int&gt;): ReceiveChannel&lt;Int&gt; = produce &#123;</span><br><span class="line">    for (x in numbers) send(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如有一个流水线过滤器，对生产的数字进行一系列处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ...</span><br></pre></td></tr></table></figure></p>
<p>比如有一个过滤器的流水线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    var cur = numbersFrom(2)</span><br><span class="line">    for (i in 1..10) &#123;</span><br><span class="line">        val prime = cur.receive()</span><br><span class="line">        println(prime)</span><br><span class="line">        cur = filter(cur, prime)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel all children to let main finish</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.numbersFrom(start: Int) = produce &#123;</span><br><span class="line">    var x = start</span><br><span class="line">    while (true) send(x++) // infinite stream of integers from start</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.filter(numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce &#123;</span><br><span class="line">    for (x in numbers) if (x % prime != 0) send(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流水线也可以使用标准库中的buildIterator，yield代替send，next代替receive，Iterator代替ReceiveChannel，去掉coroutine scope，不需要使用runBlocking。</p>
<h5 id="5-5-fan-out-单生产-gt-多消费模式"><a href="#5-5-fan-out-单生产-gt-多消费模式" class="headerlink" title="5.5 fan-out 单生产-&gt;多消费模式"></a>5.5 fan-out 单生产-&gt;多消费模式</h5><p>代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val producer = produceNumbers()</span><br><span class="line">    repeat(5) &#123; launchProcessor(it, producer) &#125;</span><br><span class="line">    delay(950)</span><br><span class="line">    producer.cancel() // cancel producer coroutine and thus kill them all</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.produceNumbers() = produce &#123;</span><br><span class="line">    var x = 1 // start from 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        send(x++) // produce next</span><br><span class="line">        delay(100) // wait 0.1s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch &#123;</span><br><span class="line">    for (msg in channel) &#123;</span><br><span class="line">        println(&quot;Processor #$id received $msg&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种模式下不像<strong>consumeEach</strong>，这种for循环的使用完全是线程安全的。如果其中一个processor失败，其他的协程会继续处理。然而通过consumeEach编写的的处理器在正常、异常完成时总是消费底层channel。</p>
<h5 id="5-6-多生产-gt-单消费"><a href="#5-6-多生产-gt-单消费" class="headerlink" title="5.6 多生产-&gt;单消费"></a>5.6 多生产-&gt;单消费</h5><p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;String&gt;()</span><br><span class="line">    launch &#123; sendString(channel, &quot;foo&quot;, 200L) &#125;</span><br><span class="line">    launch &#123; sendString(channel, &quot;BAR!&quot;, 500L) &#125;</span><br><span class="line">    repeat(6) &#123; // receive first six</span><br><span class="line">        println(channel.receive())</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel all children to let main finish</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        delay(time)</span><br><span class="line">        channel.send(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-7-缓冲通道-buffered-channel"><a href="#5-7-缓冲通道-buffered-channel" class="headerlink" title="5.7 缓冲通道[buffered channel]"></a>5.7 缓冲通道[buffered channel]</h5><p>上面介绍的channel都没有缓冲区，发送方、接收方相遇时，未缓冲通道会传输元素。如果先调用send，则会挂起，直到receive执行；如果先调用receive，则其也会挂起，直到调用send。</p>
<p>channel facotry和producer都可以选择一个参数来指定缓冲区大小。缓冲区允许发送方挂起前发送多个元素，类似指定容量的BlockingQueue，缓冲区满的时候会被阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;Int&gt;(10) // create buffered channel</span><br><span class="line">    val sender = launch &#123; // launch sender coroutine</span><br><span class="line">        repeat(10) &#123;</span><br><span class="line">            println(&quot;Sending $it&quot;) // print before sending each element</span><br><span class="line">            channel.send(it) // will suspend when buffer is full</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // don&apos;t receive anything... just wait....</span><br><span class="line">    delay(1000)</span><br><span class="line">    sender.cancel() // cancel sender coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-8-channels是公平的"><a href="#5-8-channels是公平的" class="headerlink" title="5.8 channels是公平的"></a>5.8 channels是公平的</h5><p>对通道的send和receive操作对于多个协程调用顺序是公平的,以先进先出的顺序提供。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val table = Channel&lt;Ball&gt;() // a shared table</span><br><span class="line">    launch &#123; player(&quot;ping&quot;, table) &#125;</span><br><span class="line">    launch &#123; player(&quot;pong&quot;, table) &#125;</span><br><span class="line">    table.send(Ball(0)) // serve the ball</span><br><span class="line">    delay(1000) // delay 1 second</span><br><span class="line">    coroutineContext.cancelChildren() // game over, cancel them</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun player(name: String, table: Channel&lt;Ball&gt;) &#123;</span><br><span class="line">    for (ball in table) &#123; // receive the ball in a loop</span><br><span class="line">        ball.hits++</span><br><span class="line">        println(&quot;$name $ball&quot;)</span><br><span class="line">        delay(300) // wait a bit</span><br><span class="line">        table.send(ball) // send the ball back</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-9-ticker信道"><a href="#5-9-ticker信道" class="headerlink" title="5.9 ticker信道"></a>5.9 ticker信道</h5><p>ticker信道是一种特殊的集合信道，从上次从通道中消费后，在指定的延迟，会返回一个Unit。虽然这种方式看起来像一种无用的、独立的，但是它是创建复杂的基于时间的生产pipepiles和其他基于窗口和时间独立的处理进程。ticker channel</p>
<h4 id="6-共享可变状态和并发性"><a href="#6-共享可变状态和并发性" class="headerlink" title="6 共享可变状态和并发性"></a>6 共享可变状态和并发性</h4><p>协程也可以在多线程中运行，所以也会产生并发性问题。主要问题是访问共享可变状态的同步，在协程中，有些解决方案和多线程领域类似，但有些是独一无二。</p>
<h5 id="6-1-细粒度线程限制"><a href="#6-1-细粒度线程限制" class="headerlink" title="6.1 细粒度线程限制"></a>6.1 细粒度线程限制</h5><p>线程限制指接触到共享变量的地方都用一个线程访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val counterContext = newSingleThreadContext(&quot;CounterContext&quot;)</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.massiveRun &#123; // run each coroutine with DefaultDispathcer</span><br><span class="line">        withContext(counterContext) &#123; // but confine each increment to the single-threaded context</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码非常慢，因为其执行细粒度线程限制，每次做加法，都会从多线程调度器切换，默认使用withContext切换到单线程上下文。</p>
<h5 id="6-2-粗粒度线程限制"><a href="#6-2-粗粒度线程限制" class="headerlink" title="6.2 粗粒度线程限制"></a>6.2 粗粒度线程限制</h5><p>实际运用中，线程限制以大块执行的。比如，状态更新的业务逻辑被限制当个线程中。下面的示例就是这么做的，在单线程上下文运行每个协程，使用coroutineScope.相比上个例子，性能提升很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val counterContext = newSingleThreadContext(&quot;CounterContext&quot;)</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    CoroutineScope(counterContext).massiveRun &#123; // run each coroutine in the single-threaded context</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-3-使用互斥访问"><a href="#6-3-使用互斥访问" class="headerlink" title="6.3 使用互斥访问"></a>6.3 使用互斥访问</h5><p>互斥解决方案是保护共享状态的修改，关键部分不会并发执行。多线程中，通常会使用synchronized或reentrantlock，coroutine中另一个选择是mutex。具有加锁、解锁来执行关键部分。mutex.lock是一个挂起函数，不会阻塞线程。加锁的方式也是细粒度的。在某些场景中，你需要周期性修改共享变量，但是没有任何天然的线程限制这种状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line">val mutex = Mutex()</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.massiveRun &#123;</span><br><span class="line">        mutex.withLock &#123;</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-4-actor模型"><a href="#6-4-actor模型" class="headerlink" title="6.4 actor模型"></a>6.4 actor模型</h5><p>actor是一个实体，由一个协程、和被限制并封装在这个协程中的状态，也是一个channel，和其他协程通信。一个简单的actor，可以是一个函数，如果有更复杂的状态，一个类更适合。<br>一个actor协程builder，可以很方便的将actor的信箱组合到其作用域，用来接收消息，并将发送通道组合到生成的作业对象中，这样可以将对actor的单个引用作为句柄携带。<br>第一步是定义actor要处理的消息类。kotlin中sealed class非常适合这个场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Message types for counterActor</span><br><span class="line">sealed class CounterMsg</span><br><span class="line">object IncCounter : CounterMsg() // one-way message to increment counter</span><br><span class="line">class GetCounter(val response: CompletableDeferred&lt;Int&gt;) : CounterMsg() // a request with reply</span><br><span class="line"></span><br><span class="line">// This function launches a new counter actor</span><br><span class="line">fun CoroutineScope.counterActor() = actor&lt;CounterMsg&gt; &#123;</span><br><span class="line">    var counter = 0 // actor state</span><br><span class="line">    for (msg in channel) &#123; // iterate over incoming messages</span><br><span class="line">        when (msg) &#123;</span><br><span class="line">            is IncCounter -&gt; counter++</span><br><span class="line">            is GetCounter -&gt; msg.response.complete(counter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val counter = counterActor() // create the actor</span><br><span class="line">    GlobalScope.massiveRun &#123;</span><br><span class="line">        counter.send(IncCounter)</span><br><span class="line">    &#125;</span><br><span class="line">    // send a message to get a counter value from an actor</span><br><span class="line">    val response = CompletableDeferred&lt;Int&gt;()</span><br><span class="line">    counter.send(GetCounter(response))</span><br><span class="line">    println(&quot;Counter = $&#123;response.await()&#125;&quot;)</span><br><span class="line">    counter.close() // shutdown the actor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actor在什么上下文中执行并不重要，actor就是一个协程，按照顺序执行。因此将状态限制到指定的协程可以解决共享可变状态的问题。</p>
<h4 id="7-选择表达式"><a href="#7-选择表达式" class="headerlink" title="7. 选择表达式"></a>7. 选择表达式</h4><p>选择表达式可以同时等待多个挂起函数，并选择第一个可用的函数。<br>选择表达式是kotlinx.coroutines的一个实验特性。其中的API在接下来的版本中，可能会有比较大的改变。</p>
<h5 id="7-1-从channel中选择"><a href="#7-1-从channel中选择" class="headerlink" title="7.1 从channel中选择"></a>7.1 从channel中选择</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.fizz() = produce &#123;</span><br><span class="line">    while (true) &#123; // sends &quot;Fizz&quot; every 300 ms</span><br><span class="line">        delay(300)</span><br><span class="line">        send(&quot;Fizz&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.buzz() = produce &#123;</span><br><span class="line">    while (true) &#123; // sends &quot;Buzz!&quot; every 500 ms</span><br><span class="line">        delay(500)</span><br><span class="line">        send(&quot;Buzz!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">suspend fun selectFizzBuzz(fizz: ReceiveChannel&lt;String&gt;, buzz: ReceiveChannel&lt;String&gt;) &#123;</span><br><span class="line">    select&lt;Unit&gt; &#123; // &lt;Unit&gt; means that this select expression does not produce any result</span><br><span class="line">        fizz.onReceive &#123; value -&gt;  // this is the first select clause</span><br><span class="line">            println(&quot;fizz -&gt; &apos;$value&apos;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        buzz.onReceive &#123; value -&gt;  // this is the second select clause</span><br><span class="line">            println(&quot;buzz -&gt; &apos;$value&apos;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val fizz = fizz()</span><br><span class="line">    val buzz = buzz()</span><br><span class="line">    repeat(7) &#123;</span><br><span class="line">        selectFizzBuzz(fizz, buzz)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel fizz &amp; buzz coroutines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-2-通道关闭"><a href="#7-2-通道关闭" class="headerlink" title="7.2 通道关闭"></a>7.2 通道关闭</h5><p>当通道关闭时，select中onReceive会失败，导致相应select发生异常；当通道关闭时，可以使用onReceiveOrNull执行特定操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">suspend fun selectAorB(a: ReceiveChannel&lt;String&gt;, b: ReceiveChannel&lt;String&gt;): String =</span><br><span class="line">        select &#123;</span><br><span class="line">            a.onReceiveOrNull &#123; value -&gt;</span><br><span class="line">                if (value == null)</span><br><span class="line">                    &quot;Channel &apos;a&apos; is closed&quot;</span><br><span class="line">                else</span><br><span class="line">                    &quot;a -&gt; &apos;$value&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            b.onReceiveOrNull &#123; value -&gt;</span><br><span class="line">                if (value == null)</span><br><span class="line">                    &quot;Channel &apos;b&apos; is closed&quot;</span><br><span class="line">                else</span><br><span class="line">                    &quot;b -&gt; &apos;$value&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val a = produce &#123;</span><br><span class="line">        repeat(4) &#123; send(&quot;Hello $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val b = produce &#123;</span><br><span class="line">        repeat(4) &#123; send(&quot;World $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(8) &#123; // print first eight results</span><br><span class="line">        println(selectAorB(a, b))</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>select偏向于第一个子句，当多个子句可以选择时，其中第一个子句将会被选择。当channel关闭时，onReceiveOrNull会立马得到响应。</p>
<h5 id="7-3-选择发送"><a href="#7-3-选择发送" class="headerlink" title="7.3 选择发送"></a>7.3 选择发送</h5><p>select的onSend表达式，可以结合有偏向的特性使用。<br>下面的例子是，通道消费者无法跟上生成速度，会把值发送到一个侧通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.produceNumbers(side: SendChannel&lt;Int&gt;) = produce&lt;Int&gt; &#123;</span><br><span class="line">    for (num in 1..10) &#123; // produce 10 numbers from 1 to 10</span><br><span class="line">        delay(100) // every 100 ms</span><br><span class="line">        select&lt;Unit&gt; &#123;</span><br><span class="line">            onSend(num) &#123;&#125; // Send to the primary channel</span><br><span class="line">            side.onSend(num) &#123;&#125; // or to the side channel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val side = Channel&lt;Int&gt;() // allocate side channel</span><br><span class="line">    launch &#123; // this is a very fast consumer for the side channel</span><br><span class="line">        side.consumeEach &#123; println(&quot;Side channel has $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    produceNumbers(side).consumeEach &#123;</span><br><span class="line">        println(&quot;Consuming $it&quot;)</span><br><span class="line">        delay(250) // let us digest the consumed number properly, do not hurry</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Done consuming&quot;)</span><br><span class="line">    coroutineContext.cancelChildren()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-4-选择延迟的值（deferred-value）"><a href="#7-4-选择延迟的值（deferred-value）" class="headerlink" title="7.4 选择延迟的值（deferred value）"></a>7.4 选择延迟的值（deferred value）</h5><p>延迟的值可以使用onAwait接收到。以下例子说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.asyncString(time: Int) = async &#123;</span><br><span class="line">    delay(time.toLong())</span><br><span class="line">    &quot;Waited for $time ms&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.asyncStringsList(): List&lt;Deferred&lt;String&gt;&gt; &#123;</span><br><span class="line">    val random = Random(3)</span><br><span class="line">    return List(12) &#123; asyncString(random.nextInt(1000)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val list = asyncStringsList()</span><br><span class="line">    val result = select&lt;String&gt; &#123;</span><br><span class="line">        list.withIndex().forEach &#123; (index, deferred) -&gt;</span><br><span class="line">            deferred.onAwait &#123; answer -&gt;</span><br><span class="line">                &quot;Deferred $index produced answer &apos;$answer&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">    val countActive = list.count &#123; it.isActive &#125;</span><br><span class="line">    println(&quot;$countActive coroutines are still active&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数等待第一个函数完成，并计算仍处于活跃状态的延迟值的数量。select是kotlin的一个kotlin dsl表达式，可以使用任意代码为其提供子句，这种情况下，迭代一个延迟值列表，为每个延迟值提供onWait子句。</p>
<h5 id="7-5-切换延迟值的通道"><a href="#7-5-切换延迟值的通道" class="headerlink" title="7.5 切换延迟值的通道"></a>7.5 切换延迟值的通道</h5><p>例子是producer会消费通道中的延迟值，等待每个接收到的延迟值，直到下一个值到来，或者通道关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@ExperimentalCoroutinesApi</span><br><span class="line">fun CoroutineScope.switchMapDeferreds(input: ReceiveChannel&lt;Deferred&lt;String&gt;&gt;) = produce &#123;</span><br><span class="line">    var current = input.receive() // start with first received deferred value</span><br><span class="line">    while (isActive) &#123; // loop while not cancelled/closed</span><br><span class="line">        val next = select&lt;Deferred&lt;String&gt;?&gt; &#123; // return next deferred value from this select or null</span><br><span class="line">            input.onReceiveOrNull &#123; update -&gt;</span><br><span class="line">                update // replaces next value to wait</span><br><span class="line">            &#125;</span><br><span class="line">            current.onAwait &#123; value -&gt;</span><br><span class="line">                send(value) // send value that current deferred has produced</span><br><span class="line">                input.receiveOrNull() // and use the next deferred from the input channel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            println(&quot;Channel was closed&quot;)</span><br><span class="line">            break // out of loop</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current = next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.asyncString(str: String, time: Long) = async &#123;</span><br><span class="line">    delay(time)</span><br><span class="line">    str</span><br><span class="line">&#125;</span><br><span class="line">@ExperimentalCoroutinesApi</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val chan = Channel&lt;Deferred&lt;String&gt;&gt;() // the channel for test</span><br><span class="line">    launch &#123; // launch printing coroutine</span><br><span class="line">        for (s in switchMapDeferreds(chan))</span><br><span class="line">            println(s) // print each received string</span><br><span class="line">    &#125;</span><br><span class="line">    chan.send(asyncString(&quot;BEGIN&quot;, 100))</span><br><span class="line">    delay(200) // enough time for &quot;BEGIN&quot; to be produced</span><br><span class="line">    chan.send(asyncString(&quot;Slow&quot;, 500))</span><br><span class="line">    delay(100) // not enough time to produce slow</span><br><span class="line">    chan.send(asyncString(&quot;Replace&quot;, 100))</span><br><span class="line">    delay(500) // give it time before the last one</span><br><span class="line">    chan.send(asyncString(&quot;END&quot;, 500))</span><br><span class="line">    delay(1000) // give it time to process</span><br><span class="line">    chan.close() // close the channel ...</span><br><span class="line">    delay(500) // and wait some time to let it finish</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/11/29/gradle使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/gradle使用/" itemprop="url">gradle使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:08:26+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="常见规则语法"><a href="#常见规则语法" class="headerlink" title="常见规则语法"></a>常见规则语法</h4><h5 id="1-1-buildscript"><a href="#1-1-buildscript" class="headerlink" title="1.1 buildscript"></a>1.1 buildscript</h5><p>这个语法常常会在项目根目录的build.gradle中出现。</p>
<blockquote>
<p>这个声明是gradle自身所需要的资源，如maven仓库地址、依赖项、第三方插件。执行脚本时，会优先执行buildscript代码块中的内容，然后执行剩下的内容。</p>
</blockquote>
<p>如下使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = &apos;1.2.51&apos;</span><br><span class="line">    ext.slf4j_version = &apos;1.7.25&apos;</span><br><span class="line">    ext.testng_version = &apos;6.9.6&apos;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/nexus/content/repositories/central/&apos; &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-ext"><a href="#1-2-ext" class="headerlink" title="1.2 ext"></a>1.2 ext</h5><p>定义全局变量<br><br>使用方法1：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ext&#123;</span><br><span class="line">    kotlin_version = 1.2.61</span><br><span class="line">    targetVersion = 1.8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext.kotlin_version = &apos;1.2.51&apos;</span><br><span class="line">ext.slf4j_version = &apos;1.7.25&apos;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-3-classpath"><a href="#1-3-classpath" class="headerlink" title="1.3 classpath"></a>1.3 classpath</h5><p>build.gradle中buildscript下面有classpath 码块中你可以对dependencies使用classpath声明。</p>
<h5 id="1-4-调整gradle编译参数"><a href="#1-4-调整gradle编译参数" class="headerlink" title="1.4 调整gradle编译参数"></a>1.4 调整gradle编译参数</h5><p>配置gradle.properties<br><br>配置最大内存</p>
<blockquote>
<p>org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=1024m</p>
</blockquote>
<p>守护进程：</p>
<blockquote>
<p>org.gradle.daemon=true</p>
</blockquote>
<p>并行编译：</p>
<blockquote>
<p>org.gradle.parallel=true</p>
</blockquote>
<p>开启缓存：</p>
<blockquote>
<p>android.enableBuildCache=true</p>
</blockquote>
<h5 id="1-5-死库写法不推荐"><a href="#1-5-死库写法不推荐" class="headerlink" title="1.5 死库写法不推荐"></a>1.5 死库写法不推荐</h5><blockquote>
<p>dependencies{<br>    compile ‘com.google.grpc:1.2+’<br>}</p>
</blockquote>
<p>虽然可以保证每次库都是最新的，也会带来如下问题：</p>
<ul>
<li>build网络检查 速度慢</li>
<li>库更新带来bug</li>
<li>开发者得到不同版本的包<br>推荐写为固定版本</li>
</ul>
<h5 id="1-6-全局设定编码"><a href="#1-6-全局设定编码" class="headerlink" title="1.6 全局设定编码"></a>1.6 全局设定编码</h5><blockquote>
<p>allprojects{<br>    repositories{<br>        MavenCenter()<br>    }<br>}</p>
</blockquote>
<h5 id="1-7-依赖其他module和jar"><a href="#1-7-依赖其他module和jar" class="headerlink" title="1.7 依赖其他module和jar"></a>1.7 依赖其他module和jar</h5><blockquote>
<p>dependencies{<br>    compile project(‘module1’)<br>    compile files(‘libs/commons.jar’)<br>}</p>
</blockquote>
<h5 id="1-8-exclude关键字"><a href="#1-8-exclude关键字" class="headerlink" title="1.8 exclude关键字"></a>1.8 exclude关键字</h5><p>剔除一些组织库<br></p>
<blockquote>
<p>compile(‘com.google.avg’){<br>    exclude group: ‘com.google.avg.util’ //组织名称<br>}</p>
</blockquote>
<p>剔除某个库：</p>
<blockquote>
<p>compile(‘com.android.support:appcompat-v7:23.2.0’) {<br>    exclude group: ‘com.android.support’, module: ‘support-annotations’ // 写全称<br>    exclude group: ‘com.android.support’, module: ‘support-compat’<br>}</p>
</blockquote>
<h5 id="1-9-subprojects"><a href="#1-9-subprojects" class="headerlink" title="1.9 subprojects"></a>1.9 subprojects</h5><p>多模块项目之间有重复的配置，可以使用这个配置</p>
<blockquote>
</blockquote>
<p>subprojects {</p>
<pre><code>version &apos;1.0.0-SNAPSHOT&apos;
group &apos;hcyxy.tech&apos;

apply plugin: &apos;idea&apos;
apply plugin: &apos;java&apos;
apply plugin: &apos;kotlin&apos;

sourceCompatibility = 1.8

compileKotlin {
    kotlinOptions.jvmTarget = &quot;1.8&quot;
}
compileTestKotlin {
    kotlinOptions.jvmTarget = &quot;1.8&quot;
}


repositories {
    mavenLocal()
    mavenCenter()
}

dependencies {

    testCompile &quot;org.testng:testng:${testng_version}&quot;

    //kotlin
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version&quot;

    //log4j
    compile group: &apos;org.apache.logging.log4j&apos;, name: &apos;log4j-api&apos;, version: &apos;2.8&apos;
    compile group: &apos;org.apache.logging.log4j&apos;, name: &apos;log4j-core&apos;, version: &apos;2.8&apos;

    //log
    compile &apos;ch.qos.logback:logback-classic:1.1.7&apos;
    compile &quot;org.slf4j:slf4j-api:${slf4j_version}&quot;
    compile &quot;org.slf4j:jul-to-slf4j:${slf4j_version}&quot;
}
//noinspection GroovyAssignabilityCheck
tasks.withType(JavaCompile) {
    options.encoding = &quot;UTF-8&quot;
}}
</code></pre><h5 id="1-20-sourceSets"><a href="#1-20-sourceSets" class="headerlink" title="1.20 sourceSets"></a>1.20 sourceSets</h5><p>通过修改SourceSets中的属性，可以指定哪些源文件（或文件夹下的源文件）要被编译，哪些源文件要被排除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java &#123;</span><br><span class="line">            srcDir &apos;src/java&apos; // 指定源码目录</span><br><span class="line">        &#125;</span><br><span class="line">        resources &#123;</span><br><span class="line">            srcDir &apos;src/resources&apos; //资源目录</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、实践"><a href="#2、实践" class="headerlink" title="2、实践"></a>2、实践</h4><p>多模块项目中，根目录一半就配置好subprojects buildscript就基本OK了。还会有一些常用插件，比如querydsl grpc的插件配置。<br><br>google的protobuf配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        proto &#123;</span><br><span class="line">            srcDir &apos;src/main/proto&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        java &#123;</span><br><span class="line">            srcDirs &apos;src/main/java&apos;, &quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/java&quot;, &quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/grpc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">protobuf &#123;</span><br><span class="line">    generatedFilesBaseDir = &quot;$&#123;projectDir&#125;/src/generated&quot;</span><br><span class="line">    protoc &#123;</span><br><span class="line">        artifact = &quot;com.google.protobuf:protoc:3.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        grpc &#123;</span><br><span class="line">            artifact = &quot;io.grpc:protoc-gen-grpc-java:$grpc_version&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    generateProtoTasks &#123;</span><br><span class="line">        all()*.plugins &#123;</span><br><span class="line">            grpc &#123;</span><br><span class="line">                option &apos;enable_deprecated=false&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idea &#123;</span><br><span class="line">    module &#123;</span><br><span class="line">        sourceDirs += file(&quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/java&quot;)</span><br><span class="line">        sourceDirs += file(&quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/grpc&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">publishing &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            name &quot;snapshots&quot;</span><br><span class="line">            url &quot;&quot;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username = &quot;&quot;</span><br><span class="line">                password = &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publications &#123;</span><br><span class="line">        mavenJava(MavenPublication) &#123;</span><br><span class="line">            pom.withXml &#123;</span><br><span class="line">                asNode().dependencies.&apos;*&apos;.findAll() &#123;</span><br><span class="line">                    it.scope.text() == &apos;runtime&apos; &amp;&amp; project.configurations.compile.allDependencies.find &#123; dep -&gt;</span><br><span class="line">                        dep.name == it.artifactId.text()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.each() &#123;</span><br><span class="line">                    it.scope*.value = &apos;compile&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (project != rootProject) &#123;</span><br><span class="line">                artifactId &quot;$&#123;rootProject.name&#125;-$&#123;project.name&#125;&quot;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                artifactId &quot;$&#123;project.name&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            from components.java</span><br><span class="line">            if (!project.getTasksByName(&quot;sourceJar&quot;, false).isEmpty()) &#123;</span><br><span class="line">                artifact sourceJar &#123;</span><br><span class="line">                    classifier &quot;sources&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/11/28/paxos学习小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/28/paxos学习小结/" itemprop="url">Paxos小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T22:50:36+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、paxos解决什么问题？"><a href="#1、paxos解决什么问题？" class="headerlink" title="1、paxos解决什么问题？"></a>1、paxos解决什么问题？</h4><p><strong>三个人在不同的城市现在要达成一个协议：去哪个城市聚会？</strong><br><br>使用的工具：<strong>微信 QQ 电话 飞鸽传书</strong> <br><br>但是：可能会断网 飞鸽迷路<br><br>如何保证三个人能决定出一个一致的城市，这就是paxos算法，pasox是一个算法族，包括basic-paxos，multi-paxos，fast-paxos等。<br><br>paxos算法在工程应用里主要解决日志复制问题，如主备库的日志同步。</p>
<h4 id="2、一致性需要满足三个条件"><a href="#2、一致性需要满足三个条件" class="headerlink" title="2、一致性需要满足三个条件"></a>2、一致性需要满足三个条件</h4><ol>
<li>v达成一致时的值由某个进程提出。防止作弊方式：无论如何，最终都令每个进程的v为同一个预先设置的值</li>
<li>一旦v就某个值达成一致，v不会对另一个值再次达成一致，这是<strong>安全性</strong></li>
<li>一致总能达成，v总会被决定为某个值，不会无休止的等待，这称为<strong>活性</strong></li>
</ol>
<h4 id="3、paxos约束"><a href="#3、paxos约束" class="headerlink" title="3、paxos约束"></a>3、paxos约束</h4><ol>
<li>P1 acceptor必须接受收到的第一个提案</li>
<li>P2 如果一个value=v的提案被选择了，那么被批准的拥有更高proposalId的提案proposal的value=v<br>（P2a 一旦一个具有value v的提案被批准(chosen)，那么之后任何Acceptor 再次接受(accept)的提案必须具有value v）<br>（一旦一个具有value v的提案被批准(chosen)，那么以后任何 Proposer 提出的提案必须具有value v）<br>（P2c <strong>如果一个编号为n的提案具有value=v，那么存在一个多数派，要么他们中所有人都没有accept编号小于n的任何提案，要么他们已经accpet的所有编号小于n的提案中编号最大的那个提案具有value v</strong>）<br><br>P2c -&gt; P2b -&gt; P2c -&gt; P2a</li>
</ol>
<h4 id="4、basic-paxos算法"><a href="#4、basic-paxos算法" class="headerlink" title="4、basic-paxos算法"></a>4、basic-paxos算法</h4><p>先摆上算法流程：<br></p>
<h5 id="1、第一阶段Prepare"><a href="#1、第一阶段Prepare" class="headerlink" title="1、第一阶段Prepare"></a>1、第一阶段Prepare</h5><h5 id="P1a：Proposer发送Prepare"><a href="#P1a：Proposer发送Prepare" class="headerlink" title="P1a：Proposer发送Prepare"></a>P1a：Proposer发送Prepare</h5><p>proposer生成全局唯一且递增的提案ID，无需携带提案内容</p>
<h5 id="P1b：Acceptor应答Prepare"><a href="#P1b：Acceptor应答Prepare" class="headerlink" title="P1b：Acceptor应答Prepare"></a>P1b：Acceptor应答Prepare</h5><p>Acceptor收到PrepareRequest。<br>做出一个Response，两个Promise<br><br>一个Reponse：<br></p>
<ul>
<li>返回Accept的提案中PropalId最大的提案的内容，没有则返回空值</li>
</ul>
<p>两个Promise：<br></p>
<ul>
<li>不再应答PropalId&lt;=当前请求的PrepareRequest</li>
<li>不再应答PropoalId&lt;当前请求的AcceptRequest</li>
</ul>
<p>注意<br></p>
<ul>
<li>应答当前请求前，先检查是否违背承诺</li>
<li>应答前先在本地持久化当前ProposalId</li>
</ul>
<h5 id="2、第二阶段"><a href="#2、第二阶段" class="headerlink" title="2、第二阶段"></a>2、第二阶段</h5><h5 id="P2a：Proposer发送Accept"><a href="#P2a：Proposer发送Accept" class="headerlink" title="P2a：Proposer发送Accept"></a>P2a：Proposer发送Accept</h5><p>“提案生成规则”：Proposer收集到多数派应答的PrepareResponse，选择proposalId最大的提案内容，作为要发起Accept的提案，如果提案为空值，则可以随意决定提案内容，带上当前ProposalID，向集群发送AcceptRequest</p>
<ul>
<li>回复数量&gt;一半acceptor数量，且所有value为空，Proposer发出accept请求，带上指定value</li>
<li>回复数量&gt;一半acceptor，且有的回复value不为空，则Proposer发出accept请求，带上回复中ProposalId最大的value作为提案内容</li>
<li>回复数量&lt;=一半accept数量，尝试生成更大的ProposalId，转P1a执行</li>
</ul>
<h5 id="P2b-Accept应答Accept"><a href="#P2b-Accept应答Accept" class="headerlink" title="P2b:Accept应答Accept"></a>P2b:Accept应答Accept</h5><p>Acceptor收到AcceptRequest检查两个承诺，持久化当前ProposalId和提案内容，最后Proposer收集到多数派应答的AcceptResponse后，形成决议。<br><br>Acceptor收到Accept请求后：<br></p>
<ul>
<li>收到ProposalId&gt;=Max_ProposalId【一般情况是等于】，则回复提交成功，持久化ProposalId和value</li>
<li>收到ProposalId&lt;Max_proposalId，则不回复或者回复提交失败</li>
</ul>
<p>Proposer统计投票，propose收集到一些Accept：<br></p>
<ul>
<li>回复数量&gt;一半acceptor数量，则表示提交value成功。可以发一个广播给所有Proposer、Learner，通知已commit的value</li>
<li>回复数量 &lt;= 一半的Acceptor数量，尝试生成更大的 ProposalID，转P1a</li>
<li>收到提交失败的回复，生成更大ProposalId，转P1a</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>A、proposalId不要求全局唯一，本可以随机生成ProposalId，但是无法通过P1b约束概率很高<br><br>B、paxos流程为了每条日志生成全局唯一递增logId。如果有办法生成全局唯一递增logId，就不需要paxos了，每条日志accept一遍就OK了。<br></p>
<h4 id="5、multi-paxos算法"><a href="#5、multi-paxos算法" class="headerlink" title="5、multi-paxos算法"></a>5、multi-paxos算法</h4><p>basic-paxos针对每条redolog至少存在三次网络交互（1. 产生logId 2.prepare阶段 3.accept阶段）</p>
<ul>
<li>产生logId，集群内有很多proposer，任意server发起redolog同步，进行分布式协商产生全局唯一有序logId</li>
<li>prepare阶段，paxos instance进行redolog投票</li>
<li>accept阶段 对prepare的议案进行投票</li>
</ul>
<p>server应答prepare和accept前都要持久化本地redolog，最终basic-paxos进行redolog同步的延迟包括了3次网络交互和2次本地写盘。<br></p>
<h5 id="leader的产生"><a href="#leader的产生" class="headerlink" title="leader的产生"></a>leader的产生</h5><p>multi-paxos协议并不假设全局必须只能有唯一的leader来生成日志，允许有多个自认为是leader的server来并发生成日志，这样的场景退化为basic-paxos。<br><br>可以简单理解为经过一轮basic-paxos,成功得到多数派accept的proposer成为leader【leader elect】，只有通过lease机制，在leader任期内，不必每次向多数派询问logId，也不必执行prepare阶段，直接accept。<br><br>另一个问题：多个server并发执行leader elect，可能出现两个server在相近的时间内，先后leader elect都成功，因此当选leader在开始以leader身份提供服务之前，要使用leaer proposalId写一条日志（StartWorking日志） 得到多数派确认后，再开始提供服务。因为根绝basic-paxos约束，可以推断：先执行leader elect成功的leaer（L1)，它的proposalId(p1)一定会小于后执行leader elect成功的leader（L2）的proposalId（p2),而经过两轮leader Elect，集群多数派持久化的proposalId一定是P2，而此时L1使用P1执行accept，由于P1&lt; p2，将无法得到集群内多数派的accept。<br></p>
<p>顺势引出日志同步逻辑的简化，我们将 Leader 选主看作 Paxos 的 Prepare 阶段，这个 Prepare 操作在逻辑上一次性的将后续所有即将产生的日志都执行 Prepare，因此在 Leader任期内的日志同步，都使用同一个 Proposalid，只执行 Accept 阶段即可<br></p>
<p>各个备机在执行 Accept 的时候，需要注意什么？<br></p>
<p>把选主的那轮paos看做prepare，对于后续要accept的日志，遵守两个承诺，对于先后胜出选主的多个当选leader，同步日志时携带的proposalId大小是不同的，只有最大的proposalId能同步成功，称为正式leaderf。<br></p>
<p>再进一步简化：当选leader必写一条日志确认leader身份，允许多个当选，本质就是拿到集群两个承诺，选主过程对决议内容没有实际意义，进一步简化为只执行prepare阶段，无需accept<br></p>
<p>再进一步优化，与raft协议不同，multi-paxos不要求新leader拥有全部日志，需要知道补全哪些日志，向多数派查询各个机器maxLogId，确定补全日志结束的Logid。可以将这个操作与prepare一起发出。并非multi-paxos一部分。<br></p>
<p>回放逻辑：对每条形成多数派的日志，异步写出确认日志，回放时如果一条日志有对应的确认日志，不需重新执行paxos，直接回放。对于没有确认日志的，需要执行paxos。工程上为了避免“确认日志”与对应的 Redolog 距离过大而带来回放的复杂度，往往使用滑动窗口机制来控制他们的距离。同时“确认日志”也用来提示备机可以回放收到的日志了。与Raft协议不同，由于 Multi-Paxos 允许日志不连续的确认，以及允许任何成员都可以当选 Leader，因此新任leader需要补全自己本地缺失的日志，以及对未“确认”的日志重新执行 Paxos。我把这个过程叫做日志的“重确认”，本质上就是按照“最大commit原则”，使用当前最新的Proposalid，逐条的对这些日志重新执行Paxos，成功后再补上对应的“确认日志”。<br></p>
<p>功能：自动选主  简化同步逻辑  简化回放逻辑</p>
<h4 id="6、multi-paxos的问题"><a href="#6、multi-paxos的问题" class="headerlink" title="6、multi-paxos的问题"></a>6、multi-paxos的问题</h4><p>6.1 paxos存在永远无法达成一致的可能，就是所谓的活锁问题：</p>
<ul>
<li>被打回的第一阶段再次发起PrepareRequest请求前加入随机等待时间</li>
<li>设置一个超时时间，到达超时时间后，不再接受PrepareRequest请求</li>
<li>proposer选出一个leader，通过leader统一发出PrepareRequest和AcceptRequest</li>
</ul>
<p>6.2 影子日志<br><br>幽灵复现问题的根本原因是leader的乱序提交log<br><br>解决方法：<br>需要leader在完成日志冲确认，开始写入新的redolog之前，写一条StartWorking的日志，这条日志记录了当前leader的EpochId（可以使用ProposalId），leader每写一条日志都在日志内容中携带现任leader的EpochId，回放时，经过了一条StartWorking日志后，再遇到epochId比它小的日志，直接忽略。</p>
<h4 id="7、依赖时钟误差的变种-Paxos-选主协议"><a href="#7、依赖时钟误差的变种-Paxos-选主协议" class="headerlink" title="7、依赖时钟误差的变种 Paxos 选主协议"></a>7、依赖时钟误差的变种 Paxos 选主协议</h4><p>相对MultiPaxos和Raft协议的优势在于，它不需要持久化任何数据，引入选主窗口的概念，使得大部分场景下集群内的所有机器能够几乎同时发起选主请求，便于投票时比对预定的优先级。<br>选主协议规定选主窗口开启是当前时间对一个T取余为0的时间，即只能在第 0，T，2T，3T…N*T 的时间点上开启选主窗口，协议将一次选主划分为三个阶段<br></p>
<ol>
<li>T1 预投票开始即由各个选举组成员向集群里的其他机器发送拉票请求；</li>
<li>一段时间后进入 T2 预投票开始，选举组各个成员根据接受到的拉票请，从中选出优先级最高的，给它投票应答；</li>
<li>一段时间后进入 T3 计票阶段，收到多数派投票的成员成为 leader，并向投票组其他成员发送自己上任的消息。</li>
</ol>
<p>这个选主算法相对Paxos和Raft更加简单，但是对时钟误差有比较强的依赖，时钟误差过大的情况下，会造成投票分裂无法选出主，甚至可能出现双主,但是任何保持Leader身份的Lease机制都得依赖时钟，因此可能仅仅适合 BAT 这种配备了原子钟和 GPS校准时钟，能够控制时钟误差在 100ms 以内的土豪机房</p>
<h4 id="8、raft算法和paxos算法差异"><a href="#8、raft算法和paxos算法差异" class="headerlink" title="8、raft算法和paxos算法差异"></a>8、raft算法和paxos算法差异</h4><p>Raft可以认为是一种简化的Multi-Paxos实现，最大简化之处在于备机接受Leader日志的前提是收到LogID连续的日志，在这个假设前提下，没有“幽灵复现”和“重确认”问题。简化带来的代价是对网络抖动的容忍度稍低一些。raft不允许日志的空洞，这也是为了比较方便和拉平两个节点的日志方便。Raft连续确认更大的一个优势是新主上任过程简单了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/29/矩阵最长上升路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/矩阵最长上升路径/" itemprop="url">矩阵最长上升路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-29T22:12:25+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="矩阵中的最长上升路径"><a href="#矩阵中的最长上升路径" class="headerlink" title="矩阵中的最长上升路径"></a>矩阵中的最长上升路径</h5><p>给出一个数字矩阵，寻找一条最长上升路径，每个位置只能向上下左右四个位置移动。<br>Example：</p>
<p>nums = [</p>
<pre><code>[9, 9, 4],

[6, 6, 8],

[2, 2, 1]
</code></pre><p>]</p>
<p>返回 4，最长上升路径是[1, 2, 6, 9]</p>
<p>可以采用bfs，时间复杂度可能达到O(n^4)，或者dp、记忆化搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">val dx = arrayListOf(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">val dy = arrayListOf(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">var n: Int = <span class="number">0</span></span><br><span class="line">var m: Int = <span class="number">0</span></span><br><span class="line">var dp: Array&lt;IntArray&gt; = Array(<span class="number">3</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line">var flag: Array&lt;IntArray&gt; = Array(<span class="number">3</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line"><span class="function">fun <span class="title">search</span><span class="params">(x: Int, y: Int, A: Array&lt;IntArray&gt;)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y]</span><br><span class="line">    &#125;</span><br><span class="line">    var ans = <span class="number">1</span></span><br><span class="line">    var nx: Int</span><br><span class="line">    var ny: Int</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">        nx = x + dx[i]</span><br><span class="line">        ny = y + dy[i]</span><br><span class="line">        <span class="keyword">if</span> (nx in <span class="number">0</span>..(n - <span class="number">1</span>) &amp;&amp; ny in <span class="number">0</span>..(m - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[x][y] &gt; A[nx][ny]) &#123;</span><br><span class="line">                ans = Math.max(ans, search(nx, ny, A) + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[x][y] = <span class="number">1</span></span><br><span class="line">    dp[x][y] = ans</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">longest</span><span class="params">(A: Array&lt;IntArray&gt;)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = A.size</span><br><span class="line">    m = A[<span class="number">0</span>].size</span><br><span class="line">    var ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j in <span class="number">0</span> until m) &#123;</span><br><span class="line">            dp[i][j] = search(i, j, A)</span><br><span class="line">            ans = Math.max(ans, dp[i][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(vararg args: String)</span> </span>&#123;</span><br><span class="line">    val arr: Array&lt;IntArray&gt; = arrayOf(intArrayOf(<span class="number">9</span>, <span class="number">9</span>, <span class="number">4</span>), intArrayOf(<span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span>), intArrayOf(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(longest(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/28/复数的意义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/28/复数的意义/" itemprop="url">复数的意义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-28T23:00:19+08:00">
                2018-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转来自知乎ID：Heinrich</p>
<p>链接：<a href="https://www.zhihu.com/question/23234701/answer/26017000" target="_blank" rel="noopener">https://www.zhihu.com/question/23234701/answer/26017000</a></p>
<h5 id="复数（虚数）赋予了旋转的意义。"><a href="#复数（虚数）赋予了旋转的意义。" class="headerlink" title="复数（虚数）赋予了旋转的意义。"></a>复数（虚数）赋予了旋转的意义。</h5><h5 id="比如-4-i-i-4-代表在数轴上旋转了180度"><a href="#比如-4-i-i-4-代表在数轴上旋转了180度" class="headerlink" title="比如 4*i*i=-4 代表在数轴上旋转了180度"></a>比如 <code>4*i*i=-4</code> 代表在数轴上旋转了180度</h5><p><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCEd388d4d126fe37eddf38f5e45bc0147c/23237" alt="image"></p>
<p>来看一个函数<code>$e^t$</code><br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE9ad10deb44c13b2cc6a2dbad96df5354/23233" alt="image"></p>
<p>再加上一个参数i:<br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE0a6d646b45aa3e096a20b3f0c1b77510/23231" alt="image"></p>
<p>变成了一个螺旋线，和电磁场非常像</p>
<h4 id="更重要的意义在于保留了二维信息"><a href="#更重要的意义在于保留了二维信息" class="headerlink" title="更重要的意义在于保留了二维信息"></a>更重要的意义在于保留了二维信息</h4><p>如果分解一个实数8，可以有无数种分解方法，但是计算3+5i的话，可以分解出实部和虚部。可以让电场强度和复数磁场强度相加不损失各自的信息，而且满足电场与磁场垂直要求。<br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE4ba1f885390bb0b2025491366e1b6b74/23235" alt="image"></p>
<p>正弦波可以看做自然数中的1，可以构成其他数字的基础元素。</p>
<h5 id="复数的引入大大方便了涉及到的旋转计算"><a href="#复数的引入大大方便了涉及到的旋转计算" class="headerlink" title="复数的引入大大方便了涉及到的旋转计算"></a>复数的引入大大方便了涉及到的旋转计算</h5><p>比如计算合力，比如一个力是(3+i)，另一个力(1+3i)，求合力是多少？只需简单相加即可(4+4i)</p>
<h5 id="复数涉及乘法的计算"><a href="#复数涉及乘法的计算" class="headerlink" title="复数涉及乘法的计算"></a>复数涉及乘法的计算</h5><p>比如一条船航向（ 3 + 4i）<br>如果该船的航向，逆时针增加45度，新的航向是多少<br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE74c87b124fe4f6a37e7db3ac6a086c94/23278" alt="image"></p>
<p>( 3 + 4i ) * ( 1 + i ) = ( -1 + 7i )</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/27/有趣的条件概率/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/有趣的条件概率/" itemprop="url">条件概率</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-27T21:19:10+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望"><a href="#假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望" class="headerlink" title="假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望"></a>假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望</h5><h5 id="分析-既然每一次都只能是偶数，也就是只能出现-2-4-6，且出现-6-就停，那么答案就是-3-？但是答案不是-3。-答案是-1-5，这个-1-5-还并不是「扔一个-3-面的骰子」的答案-3-的一半，而是-1-1-1-3-，其中的-1-3-是「在符合条件的前提下继续扔」的概率"><a href="#分析-既然每一次都只能是偶数，也就是只能出现-2-4-6，且出现-6-就停，那么答案就是-3-？但是答案不是-3。-答案是-1-5，这个-1-5-还并不是「扔一个-3-面的骰子」的答案-3-的一半，而是-1-1-1-3-，其中的-1-3-是「在符合条件的前提下继续扔」的概率" class="headerlink" title="分析 既然每一次都只能是偶数，也就是只能出现 2,4,6，且出现 6 就停，那么答案就是 3 ？但是答案不是 3。==答案是 1.5，这个 1.5 还并不是「扔一个 3 面的骰子」的答案 3 的一半，而是 1 / (1 - 1/3)，其中的 1/3 是「在符合条件的前提下继续扔」的概率=="></a>分析 既然每一次都只能是偶数，也就是只能出现 2,4,6，且出现 6 就停，那么答案就是 3 ？但是答案不是 3。==答案是 1.5，这个 1.5 还并不是「扔一个 3 面的骰子」的答案 3 的一半，而是 1 / (1 - 1/3)，其中的 1/3 是「在符合条件的前提下继续扔」的概率==</h5><h5 id="问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1-3-5-6停止。求最后一次扔出-6-的条件下扔骰子次数的期望。"><a href="#问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1-3-5-6停止。求最后一次扔出-6-的条件下扔骰子次数的期望。" class="headerlink" title="问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1,3,5,6停止。求最后一次扔出 6 的条件下扔骰子次数的期望。"></a>问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1,3,5,6停止。求最后一次扔出 6 的条件下扔骰子次数的期望。</h5><p>考虑最原始的做法，即直接按照定义算。令概率空间 U 为 [6]∗ 所有无限长的字母表为 [6]∗ 的字符创。令  表示第一个 6 出现之前都是偶数这个事件，有:<br><code>$ \Pr[\mathcal{E}] = \frac{1}{6} \times \left (1 + \frac{1}{3} + \left(  \frac{1}{3}\right)^2 + \cdots \right) = \frac{1}{4}.$</code></p>
<p>令 f(x) 为字符串 x 中第一个 6 出现的位置，直接代入定义有：<br><code>$\mathbb{E}_X[f(X) | \mathcal{E}] = \frac{1}{\Pr[\mathcal{E}]} \int_{x \in \mathcal{E}} \Pr[X = x] f(x) \mathrm{d} x = 4 \times \frac{1}{6} \times \sum_{i=1} \left( \frac{1}{3} \right)^{i-1} i = \frac{3}{2}.$</code></p>
<h5 id="另一种分析方式："><a href="#另一种分析方式：" class="headerlink" title="另一种分析方式："></a>另一种分析方式：</h5><p>这道题有很多人第一反应都是3。因为基于类似的原因，问题看起来和扔一个只有2，4，6三种可能的骰子等价。这么分析错在哪里先按下不表，我们首先求一下：</p>
<p>假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的概率是多大？<br>利用上一道题的结论，每次扔骰子有1/6的概率扔出6停止，1/2的概率扔出奇数，余下1/3的概率取决于后面继续扔的结果。所以骰子只出现偶数的概率为 1/6 / (1/6 + 1/2) = 1/4。</p>
<p>有没有发现哪里不对？有1/6的概率第一次就扔出6停止，这个事件占了只出现偶数的概率的2/3，也就是说，在只出现偶数的条件下，有2/3的概率第一次就扔出6！</p>
<p>问题就出在，因为出现6就停止，所以扔出6更有可能让只出现偶数这件事情发生，所以某次扔出6这个事件和只出现偶数这个事件有很强的相关性。</p>
<p>这道题比较取巧的解法是，换一种描述问题的方式：</p>
<p>假设你不断扔一个等概率的六面骰子，直到扔出1, 3, 5, 6停止。求最后一次扔出6的条件下扔骰子次数的期望。在偶数序列情况下，最后一次是6的条件概率，<br>首先这个问题和原题目等价。因为条件概率 P(A|B) = P(AB) / P(B)，比较一下新题目的两个事件和原题目的两个事件完全等价。</p>
<p>然后这是一个系数为2/3的几何分布，期望为3/2。由于1，3，5，6的对称性，条件住6并不会改变期望的值。</p>
<p>所以本题答案为3/2<br>kotlin代码验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">game</span><span class="params">(cnt: Int)</span>: Int </span>&#123;</span><br><span class="line">    var num = cnt</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>) num = <span class="number">1</span></span><br><span class="line">    val t = (Math.random() * <span class="number">6</span> + <span class="number">1</span>).toInt()</span><br><span class="line">    <span class="keyword">return</span> when &#123;</span><br><span class="line">        t % <span class="number">2</span> == <span class="number">1</span> -&gt; <span class="comment">// 奇</span></span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        t == <span class="number">6</span> -&gt; num</span><br><span class="line">        <span class="keyword">else</span> -&gt; game(++num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">expect</span><span class="params">(n: Int)</span> </span>&#123;</span><br><span class="line">    var fenzi = <span class="number">0.0</span></span><br><span class="line">    var fenmu = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span>..n) &#123;</span><br><span class="line">        val t = game(<span class="number">0</span>) <span class="comment">// 扔出奇数时为 0</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fenzi += t</span><br><span class="line">            fenmu += <span class="number">1</span>  <span class="comment">// 扔出偶数时加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(fenmu / n)</span><br><span class="line">    println(fenzi / fenmu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(vararg args: String)</span> </span>&#123;</span><br><span class="line">    expect(<span class="number">10000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/26/计数数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/计数数组/" itemprop="url">计数数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T22:28:35+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="Count-of-Smaller-Numbers-After-Self-数组计数"><a href="#Count-of-Smaller-Numbers-After-Self-数组计数" class="headerlink" title="Count of Smaller Numbers After Self(数组计数)"></a>Count of Smaller Numbers After Self(数组计数)</h5><p>给定一个数组nums,返回一个计数数组count，count[i]表示nums中第i个右边有多少个数小于nums[i]</p>
<p>Example:</p>
<p>nums = [5, 2, 6, 1]</p>
<p>输出[2,1,1,0]<br>下面是给出的利用线段树，来处理的，时间复杂度O(NlogN)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class SegmentTreeNode(s: Int, e: Int) &#123;</span><br><span class="line">    var start: Int = s</span><br><span class="line">    var end: Int = e</span><br><span class="line">    var count: Int = <span class="number">0</span></span><br><span class="line">    var left: SegmentTreeNode? = <span class="keyword">null</span></span><br><span class="line">    var right: SegmentTreeNode? = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">countSmaller</span><span class="params">(nums: IntArray)</span>: List&lt;Int&gt; </span>&#123;</span><br><span class="line">    val result = ArrayList&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">    var min = Integer.MAX_VALUE</span><br><span class="line">    var max = Integer.MIN_VALUE</span><br><span class="line">    <span class="keyword">for</span> (i in nums) &#123;</span><br><span class="line">        min = Math.min(min, i)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i in nums.indices) &#123;</span><br><span class="line">            nums[i] -= min </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i in nums) &#123;</span><br><span class="line">        max = Math.max(max, i)</span><br><span class="line">    &#125;</span><br><span class="line">    val root = build(<span class="number">0</span>, max)</span><br><span class="line">    <span class="keyword">for</span> (i in nums.indices) &#123;</span><br><span class="line">        updateAdd(root, nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i in nums.indices) &#123;</span><br><span class="line">        updateDel(root, nums[i])</span><br><span class="line">        result.add(query(root, <span class="number">0</span>, nums[i] - <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">build</span><span class="params">(start: Int, end: Int)</span>: SegmentTreeNode? </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span> SegmentTreeNode(start, end)</span><br><span class="line">    val mid = (start + end) / <span class="number">2</span></span><br><span class="line">    val root = SegmentTreeNode(start, end)</span><br><span class="line">    root.left = build(start, mid)</span><br><span class="line">    root.right = build(mid + <span class="number">1</span>, end)</span><br><span class="line">    root.count = root.left!!.count + root.right!!.count</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">query</span><span class="params">(root: SegmentTreeNode?, start: Int, end: Int)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root.start == start &amp;&amp; root.end == end) <span class="keyword">return</span> root.count</span><br><span class="line">    val mid = (root.start + root.end) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> when &#123;</span><br><span class="line">        end &lt; mid -&gt; query(root.left, start, end)</span><br><span class="line">        start &gt; end -&gt; query(root.right, start, end)</span><br><span class="line">        <span class="keyword">else</span> -&gt; query(root.left, start, mid) + query(root.right, mid + <span class="number">1</span>, end)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">updateAdd</span><span class="params">(root: SegmentTreeNode?, num: Int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.start &gt; num || root.end &lt; num) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (root.start == num &amp;&amp; root.end == num) &#123;</span><br><span class="line">        root.count++</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    val mid = (root.start + root.end) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">        updateAdd(root.left, num)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateAdd(root.right, num)</span><br><span class="line">    &#125;</span><br><span class="line">    root.count = root.left!!.count + root.right!!.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">updateDel</span><span class="params">(root: SegmentTreeNode?, num: Int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.start &gt; num || root.end &lt; num) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (root.start == num &amp;&amp; root.end == num) &#123;</span><br><span class="line">        root.count--</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    val mid = (root.start + root.end) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">        updateDel(root.left, num)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateDel(root.right, num)</span><br><span class="line">    &#125;</span><br><span class="line">    root.count = root.left!!.count + root.right!!.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(vararg args: String)</span> </span>&#123;</span><br><span class="line">    val number = intArrayOf(<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>,<span class="number">100000</span>)</span><br><span class="line">    println(countSmaller(number))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>树状数组解法O(nLogN)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(vararg args: String)</span> </span>&#123;</span><br><span class="line">    val number = intArrayOf(<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">    println(countSmaller(number))</span><br><span class="line">    println(<span class="number">6</span> and -<span class="number">6</span>)</span><br><span class="line">    println(-<span class="number">6</span> and <span class="number">0xFF</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">lowbit</span><span class="params">(x: Int)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x and -x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">add</span><span class="params">(bit: IntArray, i: Int, num: Int)</span> </span>&#123;</span><br><span class="line">    var j = i</span><br><span class="line">    <span class="keyword">while</span> (j &lt; bit.size) &#123;</span><br><span class="line">        bit[j] += num</span><br><span class="line">        j += lowbit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">query</span><span class="params">(bit: IntArray, i: Int)</span>: Int </span>&#123;</span><br><span class="line">    var j = i</span><br><span class="line">    var ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += bit[j]</span><br><span class="line">        j -= lowbit(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">countSmaller</span><span class="params">(nums: IntArray)</span>: List&lt;Int&gt; </span>&#123;</span><br><span class="line">    val tmp = nums.clone()</span><br><span class="line">    Arrays.sort(tmp) <span class="comment">//asc升序</span></span><br><span class="line">    <span class="keyword">for</span> (i in nums.indices) nums[i] = Arrays.binarySearch(tmp, nums[i]) <span class="comment">//原数组各个元素在有序数组中的位置</span></span><br><span class="line">    val bit = IntArray(nums.size)</span><br><span class="line">    val ans = arrayOfNulls&lt;Int&gt;(nums.size)</span><br><span class="line">    <span class="keyword">for</span> (i in nums.indices.reversed()) &#123;</span><br><span class="line">        ans[i] = query(bit, nums[i])</span><br><span class="line">        add(bit, nums[i] + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList&lt;Int&gt;(*ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/24/k个不同字符的最长子字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/k个不同字符的最长子字符串/" itemprop="url">k个不同字符的最长子字符串</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-24T23:08:18+08:00">
                2018-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="最多有k个不同字符的最长子字符串"><a href="#最多有k个不同字符的最长子字符串" class="headerlink" title="最多有k个不同字符的最长子字符串"></a>最多有k个不同字符的最长子字符串</h4><p>使用两个指针，便可以大道O(n)时间复杂度</p>
<p>给定一个字符串，找到最多有k个不同字符的最长子字符串，并返回其长度。<br>样例<br>例如，给定 s = “eceba” , k = 3,<br>T 是 “eceb”，长度为 4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">solve_op</span><span class="params">(str: String, k: Int)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    val n = str.length</span><br><span class="line">    var max = <span class="number">0</span></span><br><span class="line">    var i = <span class="number">0</span></span><br><span class="line">    var j = <span class="number">0</span></span><br><span class="line">    val map = HashMap&lt;Char, Int&gt;()</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            val c = str[j]</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                map[c] = map[c] ?: <span class="number">0</span> + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.size == k) &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                map[c] = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, j - i)</span><br><span class="line">        println(<span class="string">"max: $max"</span>)</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">return</span> max</span><br><span class="line">        val c = str[i]</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[c] ?: <span class="number">0</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                map[c] = map[c] ?: <span class="number">0</span> - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.remove(c)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/21/趣问/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/21/趣问/" itemprop="url">趣问</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-21T23:01:39+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Q1：有8块石头它们彼此相似除了一个比其它更重。为找出它，给你一个天平。找出最重的石头需要最少的称量次数是多少？"><a href="#Q1：有8块石头它们彼此相似除了一个比其它更重。为找出它，给你一个天平。找出最重的石头需要最少的称量次数是多少？" class="headerlink" title="Q1：有8块石头它们彼此相似除了一个比其它更重。为找出它，给你一个天平。找出最重的石头需要最少的称量次数是多少？"></a>Q1：有8块石头它们彼此相似除了一个比其它更重。为找出它，给你一个天平。找出最重的石头需要最少的称量次数是多少？</h4><p>A：划分石头成子集象(3,3,2)。使用天平去称量(3,3)，如果该天平保持平衡，则重的是在剩下的2个中，再次使用天平从这2个中来找出那个重（总计称量2次）。如果天平不平衡在称量(3,3)时, 选石头子集比另一边更重的，把它分成子集(1,1,1)，使用天平称量首先的2个，若保持平衡，剩下的石头则是更重的，否则高翘那边的就是更重的（总计称量2次）。 </p>
<h4 id="Q2-只给你二个鸡蛋，你能上100层楼，你想知道鸡蛋的硬度。鸡蛋可能很硬或很脆弱，如果鸡蛋从第m层掉下而没破裂，而从第m-1层掉下就破裂了，那么这个鸡蛋的硬度就是m。你需要找出这个m和在最坏情况下最少试验次数。-经典鸡蛋问题"><a href="#Q2-只给你二个鸡蛋，你能上100层楼，你想知道鸡蛋的硬度。鸡蛋可能很硬或很脆弱，如果鸡蛋从第m层掉下而没破裂，而从第m-1层掉下就破裂了，那么这个鸡蛋的硬度就是m。你需要找出这个m和在最坏情况下最少试验次数。-经典鸡蛋问题" class="headerlink" title="Q2: 只给你二个鸡蛋，你能上100层楼，你想知道鸡蛋的硬度。鸡蛋可能很硬或很脆弱，如果鸡蛋从第m层掉下而没破裂，而从第m+1层掉下就破裂了，那么这个鸡蛋的硬度就是m。你需要找出这个m和在最坏情况下最少试验次数。(经典鸡蛋问题)"></a>Q2: 只给你二个鸡蛋，你能上100层楼，你想知道鸡蛋的硬度。鸡蛋可能很硬或很脆弱，如果鸡蛋从第m层掉下而没破裂，而从第m+1层掉下就破裂了，那么这个鸡蛋的硬度就是m。你需要找出这个m和在最坏情况下最少试验次数。(经典鸡蛋问题)</h4><p>A: 计算机学生可能会首先用第一个鸡蛋做二分搜索(O(logN))再用第二个递增做线性搜索（O(N)），最后必将用线性搜索结束因为用第二个鸡蛋时你无法确定最高一层。因此，问题变为如何使用第一个鸡蛋来减少线性搜索。</p>
<p>于是如果第一个蛋破裂在最高点我们要扔x-1次并且我们必须从x层高扔第一个蛋。现在如果第一个蛋的第一次扔没有破裂，如果第一个蛋在第二次扔破了我们要扔x-2次第二个蛋。假如16是答案，我需要扔16次才能找到答案。来验证一下是否可以从16层开始扔，首先从16层扔如果它破裂了，我们尝试所有其下的楼层从1到15；如果没破我们还能扔15次，于是我们将从32层(16+15+1)再扔。原因是如果它在32层破裂我们能尝试其下所有楼层从17到31最坏扔第二个蛋14次（总共能扔16次了）。如果32层并没破，我们还剩下能扔13次，依此类推得：</p>
<p>1 + 15 16 如果它在16层破裂，从1到15层最坏扔15次第二个蛋</p>
<p>1 + 14 31 如果它在31层破裂，从17到30层最坏扔14次第二个蛋</p>
<p>1 + 13 45…..</p>
<p>1 + 12 58</p>
<p>1 + 11 70</p>
<p>1 + 10 81</p>
<p>1 + 9  91</p>
<p>1 + 8  100 在最后我们能轻易地做到因为我们有足够多扔的次数来完成任务</p>
<p>从上表我们能看到最佳的一个在最后一步将需要0次线性搜索。</p>
<p>能把上述规律写为: (1+p) + (1+(p-1))+ (1+(p-2)) + ………+ (1+0) &gt;= 100.</p>
<p>令1+p=q上述式子变为q(q+1)/2&gt;=100,对100解答得到q=14。</p>
<p>扔第一个蛋从层14，27，39，50，60，69，77，84，90，95，99，100直到它破裂，再开始扔第二个蛋。最坏情况只需14次。</p>
<h4 id="Q3：有11瓶酒，只有一瓶有毒。喝酒之后，三天会死，只有三天时间。请问至少需要多少只老鼠，可以找出9瓶没有毒的酒。"><a href="#Q3：有11瓶酒，只有一瓶有毒。喝酒之后，三天会死，只有三天时间。请问至少需要多少只老鼠，可以找出9瓶没有毒的酒。" class="headerlink" title="Q3：有11瓶酒，只有一瓶有毒。喝酒之后，三天会死，只有三天时间。请问至少需要多少只老鼠，可以找出9瓶没有毒的酒。"></a>Q3：有11瓶酒，只有一瓶有毒。喝酒之后，三天会死，只有三天时间。请问至少需要多少只老鼠，可以找出9瓶没有毒的酒。</h4><p>分析</p>
<p>题目描述很简单，可我们仍要抓住要点：</p>
<p>11瓶，1瓶有毒<br>喝酒之后，三天会死；只有三天时间-&gt;即使某一个老鼠没有被毒死，也不会有时间重复利用了<br>要使用最少个数的老鼠，要找到9瓶没有毒的<br>10瓶无毒的，为何要找到9瓶呢？老鼠开始喝酒，第一只要喝哪些，第二只要喝哪些呢？现在有什么依据么？显然酒瓶和老鼠都是一样的，不可区分的。那么怎么来选择哪些老鼠喝哪瓶酒，进而进行判断呢？这是这个题目的关键点、核心点。11个酒瓶，我们对其编号1-11，如下为二进制的表示，看完二进制的表示，也许很多同学，就明白了该如何选择。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
</tr>
<tr>
<td>11</td>
<td>1011</td>
</tr>
</tbody>
</table>
<p>观察每一位的0和1的分布情况，从右向左，第一位是1的，有6个情况；是0的，有5个情况。这样，我们可以让一只老鼠喝掉都是1的，然后又两种情况：</p>
<p>老鼠死了，说明有毒的那个瓶子的二进制位从右到左第一位是1.<br>老鼠没死，说明有毒的那个瓶子的二进制位从右到左第一位是0.<br>同样的，同时，另外两只老鼠测试第二位为1的瓶子以及第三位为1的瓶子，分别因为死或者没死，得到0、1的情况。三只老鼠，所有可能的情况如下</p>
<p>01情况    解释<br>000    三个老鼠都没死，只可能是1000号瓶子有毒，剩下10个都没毒<br>001    可能有毒的是0001、1001，去掉这两个，还有9个无毒<br>010    0101有毒，10个无毒<br>011    0011,1011可能有毒，9个确保无毒<br>100    0100有毒，10个无毒<br>101    0101有毒，10个无毒<br>110    0110有毒，10个无毒<br>111    0111有毒，10个无毒<br>根据上面的表格，得到，至少需要三个老鼠。此类的题目分析的思路，就是这样的，要找到突破口：表示为二进制的形式。</p>
<hr>
<h5 id="第二种分析"><a href="#第二种分析" class="headerlink" title="第二种分析"></a>第二种分析</h5><p>原题描述<br>两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事。有座100层的建筑，要你用这两个鸡蛋通过最少的次数确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋</p>
<p>方法分析<br>看到这个题目，最保险的方法就是一层一层试验，但这样只需要一个鸡蛋就可以了。我们现在有两个鸡蛋，完全可以用有更快的方法。</p>
<p>进一步呢？可能试验的方法是二分查找，例如，第一个鸡蛋再50层扔下，如果碎了，第二个鸡蛋从1-49逐层试验；如果没碎，第一个鸡蛋在75层扔下，如果碎了，第二个鸡蛋从51-74逐层试验…但是，这个方法，很容易悲剧，例如，当正好49层是可以安全落下的，需要尝试50次。比只有一个鸡蛋的情况，效果还要差。</p>
<p>上面的分析都是从鸡蛋的角度出发的，想要得到最少的尝试次数，似乎比较难。那如果我们换个角度，从每个高度的楼层来看呢？如果，某个楼层是可以安全落下的，那么最少需要多少次尝试呢？看下面的分析</p>
<p>在我们编程解决问题的过程中，如果遇到最优问题的时候，往往可以先尝试一下动态规划的方法。而动态规划的方法，首要的我们要找到构成这个最优问题的最优子问题。所以，下面的分析，我们首先尝试动态规划的方法，如何解决这个问题，这也是典型的程序员的思路；其次，在众多的问题当中，有不少可以直接归结为数学方程式，如果我们能够写出数学方程式，那么，答案将是更加的简洁、美妙。所以，第二个方法，将尝试如果总结出数学方程式。</p>
<p>基于动态规划的方法<br>前面提到，若要采用动态规划的方法，最重要的是要找到子问题。做如下的分析，假设f{n}表示从第n层楼扔下鸡蛋，没有摔碎的最少尝试次数。第一个鸡蛋，可能的落下位置(1,n),第一个鸡蛋从第i层扔下，有两个情况：</p>
<p>碎了，第二个鸡蛋，需要从第一层开始试验，有i-1次机会</p>
<p>没碎，两个鸡蛋，还有n-i层。这个就是子问题了f{n-i} 所以，当第一个鸡蛋，由第i个位置落下的时候，要尝试的次数为1 + max(i - 1, f{n - i})，那么对于每一个i，尝试次数最少的，就是f{n}的值。状态转移方程如下： f{n} = min(1 + max(i - 1, f{n - 1}) ) 其中: i的范围为(1, n), f{1} = 1 完毕。</p>
<p>推广<br>动态规划的方法，可以推广为n层楼，m个鸡蛋。如下分析： 假设f{n,m}表示n层楼、m个鸡蛋时找到最高楼层的最少尝试次数。当第一个鸡蛋从第i层扔下，如果碎了，还剩m-1个鸡蛋，为确定下面楼层中的安全楼层，还需要f{i-1,m-1}次，找到子问题；不碎的话，上面还有n-i层，还需要f[n-i,m]次，又一个子问题。 状态转移方程如下： f{n, m} = min(1 + max(f{n - 1, m - 1}, f{n - i, m}) ) 其中： i为(1, n), f{i, 1} = 1</p>
<p>基于数学方程的方法<br>假设最少尝试次数为x，那么，第一个鸡蛋必须要从第x层扔下，因为：如果碎了，前面还有x - 1层楼可以尝试，如果没碎，后面还有x-1次机会。如果没碎，第一个鸡蛋，第二次就可以从x +（x - 1）层进行尝试，为什么是加上x - 1，因为，当此时，第一个鸡蛋碎了，第二个鸡蛋还有可以从x+1 到 x + (x - 1) - 1层进行尝试，有x - 2次。如果还没碎，那第一个鸡蛋，第三次从 x + (x - 1) + (x - 2)层尝试。碎或者没碎，都有x - 3次尝试机会，依次类推。那么，x次的最少尝试，可以确定的最高的楼层是多少呢？ x + (x - 1) + (x - 2) + … + 1 = x(x+1) / 2 那反过来问，当最高楼层是100层，最少需要多少次呢？x(x+1)/2 &gt;= 100, 得到x&gt;=14，最少要尝试14次。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hecy</p>
              <p class="site-description motion-element" itemprop="description">a dreamer</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hecy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
