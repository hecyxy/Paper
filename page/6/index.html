<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="a dreamer">
<meta property="og:type" content="website">
<meta property="og:title" content="万水千山">
<meta property="og:url" content="http://hcyxy.tech/page/6/index.html">
<meta property="og:site_name" content="万水千山">
<meta property="og:description" content="a dreamer">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="万水千山">
<meta name="twitter:description" content="a dreamer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hcyxy.tech/page/6/"/>





  <title>万水千山</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">万水千山</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">hcy && xy</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/12/多个数组最小范围/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/多个数组最小范围/" itemprop="url">多个有序数组最小数字范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T21:01:28+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>有k个有序的数组，请找到一个最小的数字范围。使得这k个有序数组中，每个数组都至少有一个数字在该范围中。 例如：</p>
<p>1: 4, 10, 15, 24, 26</p>
<p>2: 0, 9, 12, 20</p>
<p>3: 5, 18, 22, 30</p>
<p>所得最小范围为[20,24]，其中，20在2中，22在3中，24在1中。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>得到的最小数组最少包含3各元素，假设最小范围是[a,b,c],a&#60;b&#60;c，a b c 来自不同的有序数组。 还有一种情况是[a,b,d,c],这种情况下d只能来自b所在的数组。</p>
<ul>
<li>如果d来自a，有更小范围 c-b</li>
<li>如果d来自c，有更小范围 d-a</li>
</ul>
<p>d所在b的数组，范围大小无影响。从分析中得出，只需要考虑在最终排序中，考虑邻近的、来自不同有序数组的元素作为备选范围。假设p1,p2,p3分别指向三个数组第一个元素，代表三个数组移动的数组下标。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>指针当前值</th>
<th>最大值</th>
<th>最小值</th>
<th>min_range_value</th>
<th>移动指针</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1</td>
<td>4,0,5</td>
<td>5</td>
<td>0</td>
<td>5</td>
<td>p2</td>
</tr>
<tr>
<td> 1</td>
<td>4,9,5</td>
<td>5</td>
<td>0</td>
<td>5</td>
<td>p1</td>
</tr>
<tr>
<td> 1</td>
<td>10,9,5</td>
<td>5</td>
<td>0</td>
<td>5</td>
<td>p3</td>
</tr>
<tr>
<td> 1</td>
<td>10,9,18</td>
<td>5</td>
<td>0</td>
<td>9</td>
<td>p2</td>
</tr>
<tr>
<td> 1</td>
<td>10,12,18</td>
<td>5</td>
<td>0</td>
<td>8</td>
<td>p1</td>
</tr>
<tr>
<td> 1</td>
<td>15,12,18</td>
<td>5</td>
<td>0</td>
<td>6</td>
<td>p2</td>
</tr>
<tr>
<td> 1</td>
<td>15,20,18</td>
<td>5</td>
<td>0</td>
<td>5</td>
<td>p1</td>
</tr>
<tr>
<td> 1</td>
<td>24,20,18</td>
<td>5</td>
<td>0</td>
<td>6</td>
<td>p3</td>
</tr>
<tr>
<td> 1</td>
<td>24,20,22</td>
<td>5</td>
<td>0</td>
<td>4</td>
<td>p2</td>
</tr>
<tr>
<td> end</td>
<td></td>
</tr>
</tbody>
</table>
<p> 每次要移动指针当前值最小的数值所在数组的指针，直到某个数组数字遍历完毕</p>
<h5 id="代码实现如下："><a href="#代码实现如下：" class="headerlink" title="代码实现如下："></a>代码实现如下：</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span>[] c)</span> </span>&#123;</span><br><span class="line">       Map&lt;Integer, ArrayList&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (; i &lt; a.length &amp;&amp; j &lt; b.length &amp;&amp; k &lt; c.length; ) &#123;</span><br><span class="line">           <span class="keyword">int</span> mMax = findMax(a[i], b[j], c[k]);</span><br><span class="line">           <span class="keyword">int</span>[] temp = findMin(a[i], b[j], c[k]);</span><br><span class="line">           <span class="keyword">int</span> mMin = temp[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">if</span> (mMax - mMin &lt; min) &#123;</span><br><span class="line">               min = mMax - mMin;</span><br><span class="line">               <span class="keyword">if</span> (map.containsKey(min)) &#123;</span><br><span class="line">                   map.get(min).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mMin, mMax&#125;);</span><br><span class="line">                   map.put(min, map.get(min));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   ArrayList&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                   list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mMin, mMax&#125;);</span><br><span class="line">                   map.put(min, list);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (temp[<span class="number">1</span>] == <span class="number">0</span>) ++i;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (temp[<span class="number">1</span>] == <span class="number">1</span>) ++j;</span><br><span class="line">           <span class="keyword">else</span> ++k;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(min);</span><br><span class="line">       ArrayList&lt;<span class="keyword">int</span>[]&gt; arr = map.get(min);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; arr.size(); r++) &#123;</span><br><span class="line">           System.out.print(<span class="string">"min:"</span> + arr.get(r)[<span class="number">0</span>]);</span><br><span class="line">           System.out.print(<span class="string">"max:"</span> + arr.get(r)[<span class="number">1</span>]);</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (a &gt; max) &#123;</span><br><span class="line">           max = a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (b &gt; max) &#123;</span><br><span class="line">           max = b;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c &gt; max) &#123;</span><br><span class="line">           max = c;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span>[] findMin(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">if</span> (a &lt; min) &#123;</span><br><span class="line">           min = a;</span><br><span class="line">           temp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (b &lt; min) &#123;</span><br><span class="line">           min = b;</span><br><span class="line">           temp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c &lt; min) &#123;</span><br><span class="line">           min = c;</span><br><span class="line">           temp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       temp[<span class="number">0</span>] = min;</span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="越来越感觉java写的代码十分臃肿，建议使用kotlin，十分好用。"><a href="#越来越感觉java写的代码十分臃肿，建议使用kotlin，十分好用。" class="headerlink" title="越来越感觉java写的代码十分臃肿，建议使用kotlin，十分好用。"></a>越来越感觉java写的代码十分臃肿，建议使用kotlin，十分好用。</h6><h6 id="这个题的著名变种是从网页中产生包含所有查询词的最小的摘要。"><a href="#这个题的著名变种是从网页中产生包含所有查询词的最小的摘要。" class="headerlink" title="这个题的著名变种是从网页中产生包含所有查询词的最小的摘要。"></a>这个题的著名变种是从网页中产生包含所有查询词的最小的摘要。</h6>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/10/数字最小范围/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/数字最小范围/" itemprop="url">数组补丁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-10T21:19:18+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干。</p>
<ol>
<li>nums[1,3],n=6 返回1</li>
<li>nums[1,5,10], n=20,返回2</li>
</ol>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>每次使用1，2，4…2k这样k+1个数可以构造出[1,2k+1]之间任何数。但是这样肯定不是最少。<br>优化：</p>
<ol>
<li>开始1是表示范围的upper，每次尝试用已有的数字来扩大能表示的连续范围</li>
<li>假定当前上界U，下一个元素X，如果X&lt;=U，上界可以继续扩大。每个之前能表示出的数加上X，就扩大了能表示的范围。</li>
<li>如果X&gt;U，这时候意味不能增加在给定数组中的元素</li>
<li>此时，假定当前上界为U，需要把U加进来，这样U到2U-1之间这段就可以补进来</li>
<li>从而上界变成2U，从而上界变成2U，以此类推</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upper = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> miss = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (upper &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">if</span> (idx &lt; arr.length &amp;&amp; arr[idx] &lt;= upper) &#123;</span><br><span class="line">                upper += arr[idx];</span><br><span class="line">                idx += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                upper += upper;</span><br><span class="line">                miss += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> miss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(N)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/07/动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/07/动态规划/" itemprop="url">动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-07T19:09:14+08:00">
                2018-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h5><p>动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。</p>
<h5 id="“状态”代表什么及如何找到这些状态？"><a href="#“状态”代表什么及如何找到这些状态？" class="headerlink" title="“状态”代表什么及如何找到这些状态？"></a>“状态”代表什么及如何找到这些状态？</h5><p>“状态”用来描述该问题的子问题的解。</p>
<h6 id="用一个例子说明"><a href="#用一个例子说明" class="headerlink" title="用一个例子说明"></a>用一个例子说明</h6><p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p>
<p>首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？<br> 两个原因：</p>
<ol>
<li>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 </li>
<li>这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</li>
</ol>
<p>从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。  由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便。<br>那么，用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。</p>
<ul>
<li>当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。</li>
<li>当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。<br>一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！ </li>
<li>让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</li>
</ul>
<p><b>从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</b></p>
<p>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”，<br>根据子问题定义状态。找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p>
<p>d(i)=min{ d(i-vj)+1 }，其中i-vj &gt;=0，vj表示第j个硬币的面值;</p>
<h6 id="例子2-一个序列有N个数：A-1-A-2-…-A-N-，求出最长非降子序列的长度。"><a href="#例子2-一个序列有N个数：A-1-A-2-…-A-N-，求出最长非降子序列的长度。" class="headerlink" title="例子2 一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。"></a>例子2 一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。</h6><p>首先要找到“状态”和“状态转移方程”<br>假设要求的这N个数的序列是：5，3，4，8，6，7<br>根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示）</p>
<ul>
<li><p>前1个数的LIS长度d(1)=1(序列：5)</p>
</li>
<li><p>前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)</p>
</li>
<li><p>前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)</p>
</li>
<li><p>前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)</p>
</li>
</ul>
<p>状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到：<br>d(i) = max{1, d(j)+1},其中j&#60;i, A[j]&#60;=A[i]<br>用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p>
<p>该算法的时间复杂度是O(n2 )，并不是最优的解法。 还有一种很巧妙的算法可以将时间复杂度降到O(nlogn)，网上已经有各种文章介绍它。</p>
<h5 id="动态规划原理"><a href="#动态规划原理" class="headerlink" title="动态规划原理"></a>动态规划原理</h5><p>何时该使用动态规划方法解决问题呢？<br>问题应该具备两个要素：</p>
<ul>
<li>最优子结构</li>
<li>子问题重叠</li>
</ul>
<h6 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h6><p>如果一个问题的最优解包含其子问题的最优解，称此问题具有最优子结构性质。【具有最优子结构性质可能意味着可以使用贪心策略】</p>
<h6 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h6><p>子问题空间必须足够小，递归算法反复求解相同子问题，不是一直生成新的子问题，不同子问题的总数是输入规模的多项式函数最好。如果递归算法反复求解相同的子问题，称最优化问题具有重叠子问题性质。<br><b>适合分治算法求解的问题通常在递归的每一步都会生成全新子问题。</b></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/06/prepare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/06/prepare/" itemprop="url">others' advice</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-06T14:09:24+08:00">
                2018-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="面试前简历准备"><a href="#面试前简历准备" class="headerlink" title="面试前简历准备"></a>面试前简历准备</h5><p>如果没有好的简历，就没有面试，没有好的经历，就没有好的简历。因此第一步就是要获取有用的经历。<br>对于学生而言：</p>
<ul>
<li>参加大型项目，获取优秀的项目经验、设计思路、代码经历</li>
<li>大型公司的实习经历，学习大公司的编码规范、设计流程、运作规律</li>
<li>利用自己的空闲时间，设计一些开源项目、有意义的项目<br>对于已工作的、想要从小公司跳槽去大公司：</li>
<li>工作中，尽可能承担更大的责任，挑战难度大的项目，将其添加到简历中</li>
<li>利用空闲时间，建立开源项目、网站、app。总结技术，展示自己。</li>
</ul>
<h5 id="面试前问题准备"><a href="#面试前问题准备" class="headerlink" title="面试前问题准备"></a>面试前问题准备</h5><ol>
<li>以下面试表格需要思考：<br><img src="https://raw.githubusercontent.com/hecyxy/expand/master/src/main/resources/pic/table.png" alt="表格" title="table"></li>
<li>你的缺点是什么？<br>不要自作聪明的回答：我的缺点就是太努力…<br>你可以这么回答：有时我对细节没有很好地把控，但是有时也有好的一方面，能让我很快的执行，同时也意味着很容易犯一些低级错误，我也想到一些方法来解决，比如让我的同事帮我review。</li>
<li>问面试官的问题？<br>真诚的问题：<ul>
<li>公司的测试、开发之间如何交流？比例多少？项目计划是怎样的</li>
<li>公司能给我带来什么？对我来说最挑战的是什么<br>见解的问题：</li>
<li>你们公司用的是X语言，怎么解决Y问题的</li>
<li>为什么选择使用X协议，不使用Y。优缺点是什么<br>激情的问题：</li>
<li>我对扩展性很有兴趣，想学习的更多，在贵公司什么地方能学到相关的知识</li>
<li>对X不太熟悉，听起来很有趣，能告诉更多关于它是如何工作的么</li>
</ul>
</li>
</ol>
<h4 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h4><h5 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h5><p>比如，给你一个文件让你从北京传到上海，根绝文件大小，选用网络传输还是交通工具运输。</p>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>包括最好情况、最坏情况、期望情况</p>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><h5 id="专业问题回答过程"><a href="#专业问题回答过程" class="headerlink" title="专业问题回答过程"></a>专业问题回答过程</h5><p>以下基础知识需要掌握：<br><img src="https://raw.githubusercontent.com/hecyxy/expand/master/src/main/resources/pic/algorithm.png" alt="表格" title="table"></p>
<pre><code>- 仔细听
- 示例
- 暴力解法
- 优化
- 通过
- 实现
- 测试
</code></pre><h6 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h6><pre><code>- 找出最耗时的关键步骤，比如算法时间复杂度O(N)+O(nlogN)，很明显要解决第二步
- 去除不必要的步骤、重复的步骤
- 代入实际问题，形象化
- 找出最适合的数据结构 队列、栈、hashmap、heap、tree
- BCR（最好的时间复杂度应该是多少）。 比如你想要找出A、B数组[AB为长度]的公共元素，最好的时间复杂度应该是O(A+B)
</code></pre><h6 id="好的代码"><a href="#好的代码" class="headerlink" title="好的代码"></a>好的代码</h6><pre><code>正确、高效、简单、可读性强、健壮、可维护
使用datastructure、附庸代码、模块化、灵活健壮、错误检测、
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/06/找出无序整数数数组未出现最小整数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/06/找出无序整数数数组未出现最小整数/" itemprop="url">找出无序数组未出现的最小整数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-06T12:10:04+08:00">
                2018-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的最小整数。比如-1-2-0-返回-3-3-4-1-1-返回-2。最好能O-1-空间和O-n-时间"><a href="#给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的最小整数。比如-1-2-0-返回-3-3-4-1-1-返回-2。最好能O-1-空间和O-n-时间" class="headerlink" title="给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的最小整数。比如[1,2,0] 返回 3, [3,4,-1,1] 返回 2。最好能O(1)空间和O(n)时间"></a>给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的最小整数。比如[1,2,0] 返回 3, [3,4,-1,1] 返回 2。最好能O(1)空间和O(n)时间</h5><h5 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h5><h6 id="问题1：给定一个数组，长度为n，除a-0-以外，其他元素都是a-i-i。那么请找出第一个大于0，且不在此数组中的最小整数。"><a href="#问题1：给定一个数组，长度为n，除a-0-以外，其他元素都是a-i-i。那么请找出第一个大于0，且不在此数组中的最小整数。" class="headerlink" title="问题1：给定一个数组，长度为n，除a[0]以外，其他元素都是a[i] == i。那么请找出第一个大于0，且不在此数组中的最小整数。"></a>问题1：给定一个数组，长度为n，除a[0]以外，其他元素都是a[i] == i。那么请找出第一个大于0，且不在此数组中的最小整数。</h6><p>答案就是:  n + (a[0] == n)</p>
<h6 id="给定一个数组，长度为n，某几个位置的元素满足-a-x-lt-0-或者-a-x-gt-n，余下的元素都满足a-i-i。那么请找出第一个大于0，且不在此数组中的最小整数。"><a href="#给定一个数组，长度为n，某几个位置的元素满足-a-x-lt-0-或者-a-x-gt-n，余下的元素都满足a-i-i。那么请找出第一个大于0，且不在此数组中的最小整数。" class="headerlink" title="给定一个数组，长度为n，某几个位置的元素满足 a[x] &lt; 0 或者 a[x] &gt; n，余下的元素都满足a[i] == i。那么请找出第一个大于0，且不在此数组中的最小整数。"></a>给定一个数组，长度为n，某几个位置的元素满足 a[x] &lt; 0 或者 a[x] &gt; n，余下的元素都满足a[i] == i。那么请找出第一个大于0，且不在此数组中的最小整数。</h6><p>答：<br>很明显：当x的值限定为0时。就变成了问题1。<br>除此之外，这个问题的解也容易求得。<br>情况1： 首先从1-n开始扫描，当发现i != a[i]时，直接返回i。此时的i必定是最小的未出现的整数。<br>情况2： 当扫描完1-n之后，那么就回归至问题1了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i!=a[i]) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (n+(n == a[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<h6 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h6><p>当给出问题2之后，就需要考虑如何把原题目转换成为问题2了。<br>实际上要完成的任务就变成了，如何把一个数组中的元素归位。也就是让a[i] == i。如果能让这些元素元神归位，那么就转换成为问题2了。就很容易求解了。<br>算法如下：<br>       我们从后往前扫描，i = n - 1 to 0;<br>                  step1如果发现a[i] &lt; 0 || a[i] &gt; n; 则 continue;<br>                  step2 如果发现a[i] == a[a[i]]; 则continue;<br>                  step3 如果发现0 &lt; a[i] &lt; n<br>                          说明需要将a[i]元神归位。也就是放到a[a[i]]上去。<br>                           swap(a[i], a[a[i]]).<br>                           再跳转至step2。<br>Note: 需要注意一种有重复数的情况，比如a[11] = 2, a[2] = 2。这时候，就不用进行交换了。直接处理下一个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = n, t, temp;</span><br><span class="line"><span class="keyword">if</span> (!a || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> ((--i) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> &lt; a[i] &amp;&amp; a[i] &lt; n &amp;&amp; i != a[i]) &#123;</span><br><span class="line">        t = a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[t]) <span class="keyword">break</span>;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[t];</span><br><span class="line">        a[t] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="原题答案："><a href="#原题答案：" class="headerlink" title="原题答案："></a>原题答案：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = n, t, temp;</span><br><span class="line">    <span class="keyword">if</span> (!a || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((--i) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt; a[i] &amp;&amp; a[i] &lt; n &amp;&amp; i != a[i]) &#123;</span><br><span class="line">            t = a[i];</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[t]) <span class="keyword">break</span>;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[t];</span><br><span class="line">            a[t] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != i) <span class="keyword">return</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (n + (a[<span class="number">0</span>] == n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="另一种解法-这种方法代码简洁，主要思想是将数组的每个位置i，使num-i-i-1"><a href="#另一种解法-这种方法代码简洁，主要思想是将数组的每个位置i，使num-i-i-1" class="headerlink" title="另一种解法 这种方法代码简洁，主要思想是将数组的每个位置i，使num[i]=i+1"></a>另一种解法 这种方法代码简洁，主要思想是将数组的每个位置i，使num[i]=i+1</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missNum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>; <span class="comment">// 下标从0开始，</span></span><br><span class="line">    <span class="keyword">int</span> r = nums.size(); </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)<span class="comment">//从0开始找到每个位置应放入正确的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == l + <span class="number">1</span>)<span class="comment">//当前位置正确放置跳过</span></span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[l] 减去 1 表示数nums[l] 应该在的位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt; l + <span class="number">1</span> || nums[l] &gt; r || nums[nums[l] - <span class="number">1</span>] == nums[l])</span><br><span class="line">        &#123;</span><br><span class="line">            r--;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            swap(nums[l], nums[nums[l] - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/04/基于互信息 左右熵挖掘新词/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/04/基于互信息 左右熵挖掘新词/" itemprop="url">基于互信息 左右熵挖掘新词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-04T13:42:30+08:00">
                2018-10-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index">
                    <span itemprop="name">NLP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="成词标准一：熵-左右熵"><a href="#成词标准一：熵-左右熵" class="headerlink" title="成词标准一：熵-左右熵"></a>成词标准一：熵-左右熵</h3><p>通常我们认为两个片段可以成词的一个条件就是这个词语会在很多的语境中被提到。熵就是一个用来衡量这个维度的指标。熵是一种表示信息量的指标，熵越高就意味着信息含量越大，不确定性越高，越难以预测。通常对于一个随机变量 X, 它的熵可以被表示成：</p>
<p><img src="https://raw.githubusercontent.com/hecyxy/expand/master/src/main/resources/pic/v2-ab2f5003c9822fab020bdeddbb9c801f_hd.jpg" alt="pic" title="Markdown"></p>
<h3 id="成词标准二：内部聚合程度-互信息-mutual-information-amp-点间互信息-pointwise-mutual-information"><a href="#成词标准二：内部聚合程度-互信息-mutual-information-amp-点间互信息-pointwise-mutual-information" class="headerlink" title="成词标准二：内部聚合程度 - 互信息 (mutual information) &amp; 点间互信息 (pointwise mutual information)"></a>成词标准二：内部聚合程度 - 互信息 (mutual information) &amp; 点间互信息 (pointwise mutual information)</h3><p>互信息 (MI) 表示了两个随机变量 X, Y 共享的信息量。也可以说，互信息代表着知道了任意一个变量之后对另一个变量不确定性的减少。</p>
<p><img src="https://raw.githubusercontent.com/hecyxy/expand/master/src/main/resources/pic/v2-61bc0fa7cf105d74adb2e9b8cac342f9_hd.jpg" alt="pic2" title="Markdown"><br>步骤：</p>
<ol>
<li>对输入文本进行清洗和分词，没有任何分词词库情况下，直接将文本按照字符分割；<br>将字符两两组合作为候选词，因为需要前缀和后缀计算信息熵，需要存储长度为3的片段。后续设计到前后缀的查找饿词频的统计，选择trie树来存储数据。用3-gram序列构建前缀trie树和后缀树，trie树以单个字符为节点，每个节点记录从根节点到当前节点构成词汇出现的频次；</li>
<li>查询trie树，获取前缀和后缀的频次列表，计算候选词的左右信息熵以及候选词构成片段的左右信息熵。涉及到信息熵比较多，对每个信息熵作如下区分表及，（candidate为后选词，left为左边构成的片段，right为右边构成的片段）<br><img src="https://raw.githubusercontent.com/hecyxy/expand/master/src/main/resources/pic/v2-5a79911d6fc250cfc82960e2a936e992_hd.jpg" alt="avatar" title="Markdown"></li>
<li>查询trie树，获取候选词的词频以及左右片段的词频，有了词频可以计算实际出现的概率P(x,y）和期望出现的概率P(x)P(y)，从而计算出凝合度和互信息。为了防止冷启动前出现过高的概率p，预先跑一些基础词汇词频，在词频库基础上，保证刚开始拿到比较争取的概率p<br>增加准确率，设定词频和互信息阈值，排除低词频和低凝合度的词汇。所有满足条件的词汇，通过调用jieba的suggest_freq函数都能使其被分出来。词频大于2，PMI不小于24.<br>针对新词成词特点，分数计算：<br><img src="https://raw.githubusercontent.com/hecyxy/expand/master/src/main/resources/pic/v2-daf8dad77b7e7cc11f8c973d09f770cd_hd.jpg" alt="avatar" title="Markdown"></li>
</ol>
<p>分数由三个对应部分组成：<br><br>1）点间互信息：点间互信息越高，内部聚合程度越高<br>2）两个单词片段信息熵 h_r_l 和 h_l_r 的最小值：这个数值越大，则意味着两个单词一起出现的可能性越小<br>3）单词左右信息熵的最小值：这个数值越大就表示着候选词出现的语境越多，越有可能成词<br>因此，分数越高表示成词的可能性越大。</p>
<p>A、对于单词左右信息熵 ( h_l, h_r ) 为 0 的情况，迭代一轮，确认是否可能与左右的片段组成新词。 比如 “淘宝客” 这个词，先被分成了 “淘”、“宝”、“客”，在检测 “淘宝” 的时候，会发现它的右信息熵为 0，因此 “淘宝” 在当前上下文可能是另一个词的片段，所以通过下一轮迭代，检测 “淘宝” 和 “客” 能否成词。<br><br>B、最后根据词频和score的乘积排序，筛选出 top 5 的词汇作为新词。淘宝客这个例子中筛选出来的 top 5 新词结果如下：<br><img src="https://raw.githubusercontent.com/hecyxy/expand/master/src/main/resources/pic/v2-6fc041e4943846b55cd6183e82239f5d_hd.jpg" alt="avatar" title="Markdown"></p>
<p>实际应用中，词库实际上是不断被完善的，因此词库越完善，后续满足条件的未登录词会越少。我们对新词的挖掘也是基于内部的词库。试着跑一段时间内被反作弊系统悟空删除的内容，最后出来的前几个基本上都是站内被提及比较多的营销关键词了</p>
<h4 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h4><p>I(X,Y) = ∫x∫yP(X,Y)log(P(X,Y)/P(x) * P(y))= H(Y)-H(Y|X)<br>H(Y) = -∫yP(Y)logP(Y)<br>H(Y|X)则表示在已知X的情况下，Y的不确定度,可以看出，I(X,Y)可以解释为由X引入而使Y的不确定度减小的量，这个减小的量为H(Y|X)所以，如果X,Y关系越密切，I(X,Y)就越大.</p>
<p>在做文本分类时，我们可能会判断一个词和某类的相关程度，但是计算时，未考虑词频的影响<br>（可以让互信息的结果再乘上tf-idf因子，从而将特征频率与特征分布考虑进去）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/09/08/结巴分词/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/结巴分词/" itemprop="url">结巴分词</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T10:24:29+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index">
                    <span itemprop="name">NLP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、导入词库<br>load main dict  -&gt;  （词，词频，词性）<br>load model -&gt; 状态转移矩阵  发射矩阵  初始概率矩阵<br>2、sentenceProcess<br>  ● createDAG 根绝句子创建有向无环图 比如[0:[0,1,2],1:[1],2:[2,3,4]]   0,0-1,0-2都是可以成词的<br>  ● calc(sentence,DAG) 返回route计算概率最大的词语 比如2:[2,3,4] 最大概率是2-4<br>接着针对Map&lt;Integer, Pair<integer>&gt;中的最大概率词语<br>如果词典中包含该词语，直接将词语加入List<string> tokens<br>  ● 如果没有该词，利用维特比算法【基于动态规划寻找最大概率路径】<br>和树结构中寻找最短路径不同的是，这里的观察值是有序列的，每个序列有n个状态，长度为T，时间复杂度TN^2<br>关键代码如下：<br>public static int[] compute(int[] obs, int[] states, double[] start_p, double[][] trans_p, double[][] emit_p)<br>{<br>    double[][] V = new double[obs.length][states.length];<br>    int[][] path = new int[states.length][obs.length];<br>    for (int y : states)<br>    {<br>        V[0][y] = start_p[y] <em> emit_p[y][obs[0]];<br>        path[y][0] = y;<br>    }<br>    for (int t = 1; t &lt; obs.length; ++t)<br>    {<br>        int[][] newpath = new int[states.length][obs.length];<br>        for (int y : states)<br>        {<br>            double prob = -1;<br>            int state;<br>            for (int y0 : states)<br>            {<br>                double nprob = V[t - 1][y0] </em> trans_p[y0][y] * emit_p[y][obs[t]];<br>                if (nprob &gt; prob)<br>                {<br>                    prob = nprob;<br>                    state = y0;<br>                    // 记录最大概率<br>                    V[t][y] = prob;<br>                    // 记录路径<br>                    System.arraycopy(path[state], 0, newpath[y], 0, t);<br>                    newpath[y][t] = y;<br>                }<br>            }<br>        }<br>        path = newpath;<br>    }<br>    double prob = -1;<br>    int state = 0;<br>    for (int y : states)<br>    {<br>        if (V[obs.length - 1][y] &gt; prob)<br>        {<br>            prob = V[obs.length - 1][y];<br>            state = y;<br>        }<br>    }<br>    return path[state];<br>}</string></integer></p>
<h2 id="基于动态规划，每步寻找概率最大的状态，使观察值最大。"><a href="#基于动态规划，每步寻找概率最大的状态，使观察值最大。" class="headerlink" title="基于动态规划，每步寻找概率最大的状态，使观察值最大。"></a>基于动态规划，每步寻找概率最大的状态，使观察值最大。</h2><p>1、HMM隐马尔科夫模型<br>五元组：<br>  ● StatusSet 状态值集合<br>  ● ObservedSet 观察值集合<br>  ● TransProbMatrix 转移概率矩阵<br>  ● EmitProbMatrix 发射概率矩阵<br>  ● InitStatus 初始状态分布<br>2、主要用于解决三类问题<br>a)参数(StatusSet,TransProbMatrix,EmitRobMatrix,InitStatus)已知的情况下，求解观察值序列。(Forward-backward算法)<br>b)参数(ObservedSet,TransProbMatrix,EmitRobMatrix,InitStatus)已知的情况下，求解状态值序列。(viterbi算法)<br>c)参数(ObservedSet)已知的情况下，求解(TransProbMatrix,EmitRobMatrix,InitStatus)。(Baum-Welch算法)<br>第二种问题最长用：【中文分词】【语音识别】【新词发现】【词性标注】</p>
<p>StatusSet &amp; ObservedSet<br>状态值集合(B,M,E,S)代表每个词再词语中的位置,S代表单字成词<br>观察值集合就是所有汉字（一个句子）<br>状态值就是我们要求的值，HMM模型进行中文分词，输入一个句子（观察值序列），输出每个字的状态值，如<br>小明硕士毕业于中国科学院计算所<br>输出的状态序列为：<br>BEBEBMEBEBMEBES<br>再根据状态序列进行切词：<br>BE/BE/BME/BE/BME/BE/S<br>切词结果为：<br>小明/硕士/毕业于/中国/科学院/计算/所<br>同时我们可以注意到：<br>B后面只可能接(M or E)，不可能接(B or S)。而M后面也只可能接(M or E)，不可能接(B, S)<br>上面介绍了五元组中的两元【StatusSet、ObservedSet】，还有剩下三元，通过Viterbi算法串接起来，ObservedSet序列值是Viterbi的输入，而StatusSet序列值是Viterbi的输出，输入和输出之间Viterbi还需要借助三个模型参数<br>InitStatus初始概率分布：</p>
<p>#B<br>-0.26268660809250016</p>
<p>#E<br>-3.14e+100</p>
<p>#M<br>-3.14e+100</p>
<p>#S<br>-1.4652633398537678<br>即句子第一个字属于{B,E,M,S}这四种状态的概率，E、M概率都是0，即开头第一个字只能是B或S<br>TransProbMatrix转移概率矩阵<br>即BEMS x BEMS【数值是概率求对数后的值】<br>-3.14e+100 -0.510825623765990 -0.916290731874155 -3.14e+100<br>-0.5897149736854513 -3.14e+100 -3.14e+100 -0.8085250474669937<br>-3.14e+100 -0.33344856811948514 -1.2603623820268226 -3.14e+100<br>-0.7211965654669841 -3.14e+100 -3.14e+100 -0.6658631448798212<br>比如TransProbMatrix[0][0]表示从状态B转移到状态B的概率为0<br>EmitProbMatrix<br>发射概率也是一个条件概率，根据HMM三个基本假设其中的观察值独立性假设，观察值只取决于当前状态值，即<br>P(Observed[i], Status[j]) = P(Status[j]) * P(Observed[i] | Status[j])<br>其中P(Observed[i]|Status[j])这个值就是从EmitProbMatrix中获取。<br>EmitProbMatrix示例如下</p>
<p>#B<br>耀:-10.460283,涉:-8.766406,谈:-8.039065,伊:-7.682602,洞:-8.668696,…</p>
<p>#E<br>耀:-9.266706,涉:-9.096474,谈:-8.435707,伊:-10.223786,洞:-8.366213,…</p>
<p>#M<br>耀:-8.47651,涉:-10.560093,谈:-8.345223,伊:-8.021847,洞:-9.547990,….</p>
<p>#S<br>蘄:-10.005820,涉:-10.523076,唎:-15.269250,禑:-17.215160,洞:-8.369527…<br>虽然EmitProbMatrix也称为矩阵，这个矩阵太稀疏了，实际工程中一般是将上面四行发射转移概率存储为4个Map<br>HMM算法过程<br>输入：小明硕士毕业于中国科学院计算所<br>1）定义变量<br>二维数组 weight[4][15]，4是状态数(0:B,1:E,2:M,3:S)，15是输入句子的字数。比如 weight[0][2] 代表 状态B的条件下，出现’硕’这个字的可能性。<br>二维数组 path[4][15]，4是状态数(0:B,1:E,2:M,3:S)，15是输入句子的字数。比如 path[0][2] 代表 weight[0][2]取到最大时，前一个字的状态，比如 path[0][2] = 1, 则代表 weight[0][2]取到最大时，前一个字(也就是明)的状态是E。记录前一个字的状态是为了使用viterbi算法计算完整个 weight[4][15] 之后，能对输入句子从右向左地回溯回来，找出对应的状态序列<br>2）使用InitStatus对weight二维数组进行初始化<br>已知InitStatus如下：</p>
<p>#B<br>-0.26268660809250016</p>
<p>#E<br>-3.14e+100</p>
<p>#M<br>-3.14e+100</p>
<p>#S<br>-1.4652633398537678<br>且由EmitProbMatrix可得出：<br>Status(B) -&gt; Observed(小)  :  -5.79545<br>Status(E) -&gt; Observed(小)  :  -7.36797<br>Status(M) -&gt; Observed(小)  :  -5.09518<br>Status(S) -&gt; Observed(小)  :  -6.2475<br>3)初始化weight<br>weight[0][0] = -0.26268660809250016 + -5.79545 = -6.05814<br>weight[1][0] = -3.14e+100 + -7.36797 = -3.14e+100<br>weight[2][0] = -3.14e+100 + -5.09518 = -3.14e+100<br>weight[3][0] = -1.4652633398537678 + -6.2475 = -7.71276<br>3）确定边界条件和路径回溯<br>边界条件：对于每个句子，最后一个字的状态只可能是 E 或者 S，不可能是 M 或者 B。<br>所以在本文的例子中我们只需要比较 weight[1(E)][14] 和 weight[3(S)][14] 的大小即可<br>weight[1][14] = -102.492;<br>weight[3][14] = -101.632;<br>所以S&gt;E，对于路径回溯的起点是path[3][14]<br>回溯路径：SEBEMBEBEMBEBEB<br>倒序一下就是：BE/BE/BME/BE/BME/BE/S<br>切词结果：小明/硕士/毕业于/中国/科学院/计算/所<br>给定我们一个模型，我们对模型进行载入完毕之后，只要运行一遍Viterbi算法，就可以找出每个字对应的状态，根据状态也就可以对句子进行分</p>
<p>模型训练问题<br>以上的前提是基于模型来进行切词，假设手头上HMM模型已经是被训练好的，即InitStatus、TransProbMatrix、EmitProbMatrix三个模型关键参数都是已知的。这三个参数其实也是基于已分词完毕的语料进行统计计算，计算出相应的频率和条件概率就可以算出三个参数</p>
<p>HMM模型连个个基本假设：<br>  ● 齐次性假设（状态和当前时刻无关）<br>P(Status[i]|Status[i-1],Status[i-2],… Status[1]) = P(Status[i] | Status[i-1])<br>  ● 观察值独立性假设（观察值只取决于当前状态值）<br>P(Observed[i] | Status[i],Status[i-1],…,Status[1]) = P(Observed[i] | Status[i])</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/07/14/无锁编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/14/无锁编程/" itemprop="url">无锁编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-14T22:54:45+08:00">
                2018-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分布式系统中，多线程中，为了保持一致性，锁通常是一种很好用的方式，但是锁是涉及到操作系统层面的切换，是低效的一种方式，要尽量使用无锁的编程思想。</p><br><p>锁是一种悲观的策略，每次临界区操作都会产生冲突。无锁是一种乐观的策略，假设对资源的访问没有冲突。其有两大优点：</p>


<p>1.高并发情况下，比锁拥有更好的性能 <br><br>2.死锁免疫 <br><br>（一：基础类）<br>1.与众不同的并发策略：比较交换（CAS）</p>
<pre><code>与锁相比，使用比较交换（下文简称CAS）会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。

CAS算法的过程是这样：它包含三个参数CAS(V,E,N)。V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。

简单地说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，那说明它已经被别人修改过了。你就重新读取，再次尝试修改就好了。

在硬件层面，大部分的现代处理器都已经支持原子化的CAS指令。在JDK 5.0以后，虚拟机便可以使用这个指令来实现并发操作和并发数据结构，并且，这种操作在虚拟机中可以说是无处不在。
</code></pre><p>2.无锁的线程安全整数：AtomicInteger  LongAddr系列</p>
<pre><code>为了让Java程序员能够受益于CAS等CPU指令，JDK并发包中有一个atomic包，里面实现了一些直接使用CAS操作的线程安全的类型。其中，最常用的一个类，应该就是AtomicIn-teger。你可以把它看做是一个整数。但是与Inte-ger不同，它是可变的，并且是线程安全的。对其进行修改等任何操作，都是用CAS指令进行的。这里简单列举一下AtomicInteger的一些主要方法，对于其他原子类，操作也是非常类似的。
</code></pre><p>3.Java中的指针：Unsafe类</p>
<p> 在AtomicInteger中compareAndSet()方法：</p>
<pre><code>public final boolean compareAndSet(int expect, int update) {

    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);

}
</code></pre><p>有一个特殊的变量unsafe，它是sun.misc.Unsafe类型。这个类封装了一些不安全的操作，类似C语言中指针的操作。</p>
<p>   public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</p>
<pre><code>方法是一个navtive方法，它的参数含义是：

var1为给定的对象

var2为对象内的偏移量（其实就是一个字段到对象头部的偏移量，通过这个偏移量可以快速定位字段）

var4表示期望值

xvar5要设置的值。如果指定的字段的值等于var4，那么就会把它设置为var5。
</code></pre><p>不难看出，compareAndSwapInt()方法的内部，必然是使用CAS原子指令来完成的。<br>注意：根据Java类加载器的工作原理，应用程序的类由App Loader加载。而系统核心类，如rt.jar中的类由Bootstrap类加载器加载。Bootstrap加载器没有Java对象的对象，因此试图获得这个类加载器会返回null。所以，当一个类的类加载器为null时，说明它是由Bootstrap加载的，而这个类也极有可能是rt.jar中的类。就是由rt.jar加载<br>netty中的无锁队列底层MPSC队列（JCTools）无锁就是利用这个实现</p>
<p>4.无锁的对象引用：AtomicReference</p>
<pre><code>AtomicReference和AtomicInteger非常类似，不同之处就在于AtomicInteger是对整数的封装，而AtomicReference则对应普通的对象引用。也就是它可以保证你在修改对象引用时的线程安全性。在介绍AtomicReference的同时，我希望同时提出一个有关原子操作的逻辑上的不足。

之前我们说过，线程判断被修改对象是否可以正确写入的条件是对象的当前值和期望值是否一致。这个逻辑从一般意义上来说是正确的。但有可能出现一个小小的例外，就是当你获得对象当前数据后，在准备修改为新值前，对象的值被其他线程连续修改了两次，而经过这两次修改后，对象的值又恢复为旧值。这样，当前线程就无法正确判断这个对象究竟是否被修改过。
</code></pre><p>5.带有时间戳的对象引用：AtomicStampedReference</p>
<pre><code>AtomicReference无法解决上述问题的根本因为是对象在修改过程中，丢失了状态信息。

AtomicStampedReference，它内部不仅维护了对象值，还维护了一个时间戳（我这里把它称为时间戳，实际上它可以使任何一个整数来表示状态值）。当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳。可以解决ABA问题

当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值，写入才会成功。因此，即使对象值被反复读写，写回原值，只要时间戳发生变化，就能防止不恰当的写入。
</code></pre><p>6.数组也能无锁：AtomicIntegerArray</p>
<pre><code>除了提供基本数据类型外，JDK还为我们准备了数组等复合结构。当前可用的原子数组有：AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray，分别表示整数数组、long型数组和普通的对象数组。
</code></pre><p>7.让普通变量也享受原子操作：AtomicIntegerFieldUpdater</p>
<pre><code>将普通变量也变成线性安全的。

在原子包里还有一个实用的工具类AtomicIn-tegerFieldUpdater。它可以让你在不改动（或者极少改动）原有代码的基础上，让普通的变量也享受CAS操作带来的线程安全性，这样你可以修改极少的代码，来获得线程安全的保证。

根据数据类型不同，这个Updater有三种，分别是AtomicIntegerFieldUpdater、AtomicLong-FieldUpdater和AtomicReferenceFieldUpdater。顾名思义，它们分别可以对int、long和普通对象进行CAS修改。

虽然AtomicIntegerFieldUpdater很好用，但是还是有几个注意事项：

第一，Updater只能修改它可见范围内的变量。因为Updater使用反射得到这个变量。如果变量不可见，就会出错。比如如果score申明为private，就是不可行的。

第二，为了确保变量被正确的读取，它必须是volatile类型的。如果我们原有代码中未申明这个类型，那么简单地申明一下就行，这不会引起什么问题。

第三，由于CAS操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持static字段（Unsafe. objectFieldOffset()不支持静态变量）。    
</code></pre><p>8.SynchronousQueue的实现</p>
<pre><code>在对线程池的介绍中，提到了一个非常特殊的等待队列SynchronousQueue。Syn-chronousQueue的容量为0，任何一个对Syn-chronousQueue的写需要等待一个对Syn-chronousQueue的读,因此，Syn-chronousQueue与其说是一个队列，不如说是一个数据交换通道。

对SynchronousQueue来说，它将put()和take()两个功能截然不同的操作抽象为一个共通的方法Transferer.transfer()。
</code></pre><p>Object transfer(Object e, boolean timed, long nanos)</p>
<pre><code>当参数e为非空时，表示当前操作传递给一个消费者，如果为空，则表示当前操作需要请求一个数据。timed参数决定是否存在timeout时间，nanos决定了timeout的时长。如果返回值非空，则表示数据已经接受或者正常提供，如果为空，则表示失败（超时或者中断）。

SynchronousQueue内部会维护一个线程等待队列。等待队列中会保存等待线程以及相关数据的信息。比如，生产者将数据放入Syn-chronousQueue时，如果没有消费者接收，那么数据本身和线程对象都会打包在队列中等待（因为SynchronousQueue容积为0，没有数据可以正常放入）。
 1. 如果等待队列为空，或者队列中节点的类型和本次操作是一致的，那么将当前操作压入队列等待。比如，等待队列中是读线程等待，本次操作也是读，因此这两个读都需要等待。进入等待队列的线程可能会被挂起，它们会等待一个“匹配”操作。

 2. 如果等待队列中的元素和本次操作是互补的（比如等待操作是读，而本次操作是写），那么就插入一个“完成”状态的节点，并且让他“匹配”到一个等待节点上。接着弹出这两个节点，并且使得对应的两个线程继续执行。

 3. 如果线程发现等待队列的节点就是“完成”节点，那么帮助这个节点完成任务。其流程和步骤2是一致的。
</code></pre><p>（二：无锁数据结构）</p>
<p>1.RingBuffer<br>一个环状的数据结构，一个生产者，一个消费者，在linux任务调度里应用很多</p>
<p>2.disruptor数据结构<br>是一个生产者、消费者的设计模式，也是一个ringbuffer，但是适合多个生产者、消费者。底层优化到操作系统二级缓存，还有其他的一些优化，这里不作具体介绍；</p>
<p>3.JCTools工具包<br>原本jdk里面缺少了对无锁队列的支持，这是提供了各种无锁队列，比如单生产者单消费者、单生产者多消费者、多生产者单消费者、多生产者多消费者等。netty的新版中，也用MPSC代替了原本的LinkedBlockingQueue，经过测试，性能大大提升。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/07/08/动态加载Jar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/动态加载Jar/" itemprop="url">动态加载Jar</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T10:24:29+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应用场景，程序中使用不同的jdbc包，来连接数据库。</p>
<p>动态加载jdbc驱动：<br>//URL u = new URL(“file:C:\working\eclipse\Testsb\lib\“+mysqlJdbcFile);<br>URL u = new URL(“jar:file:lib/“ + mysqlJdbcFile + “!/“);<br>        String classname = jdbcVersionMap.get(mysqlJdbcFile);<br>        URLClassLoader ucl = new URLClassLoader(new URL[] { u });<br>        Driver d = (Driver)Class.forName(classname, true, ucl).newInstance();<br>        DriverShim driver = new DriverShim(d);<br>        DriverManager.registerDriver(driver);<br>使用完之后卸载这个driver：<br>DriverManager.deregisterDriver()</p>
<p>为什么Driver要用DriverShim包装一下呢？<br>因为DriverManager拒绝使用不是由SystemClassLoader加载的驱动程序。<br>解决方法就是创建一个shim类实现Driver的接口。因为DriverShim是由系统加载器加载的，所以它可以实现注册；<br>因为Class.forName不一定使用的是系统类加载器，而是使用调用者的类加载器，比如使用了自定义类加载器；<br>public static Class&lt;?&gt; forName(String className)<br>           throws ClassNotFoundException {<br>return forName0(className, true, ClassLoader.getCallerClassLoader());<br>   }<br>通过 ClassLoader.getCallerClassLoader()获取类加载器：<br>// Returns the invoker’s class loader, or null if none.<br>   // NOTE: This must always be invoked when there is exactly one intervening<br>   // frame from the core libraries on the stack between this method’s<br>   // invocation and the desired invoker.<br>   static ClassLoader getCallerClassLoader() {<br>       // NOTE use of more generic Reflection.getCallerClass()<br>       Class caller = Reflection.getCallerClass(3);<br>       // This can be null if the VM is requesting it<br>       if (caller == null) {<br>           return null;<br>       }<br>       // Circumvent security check since this is package-private<br>       return caller.getClassLoader0();  </p>
<h1 id=""><a href="#" class="headerlink" title="   }  "></a>   }  </h1><p>扩展，不仅仅是加载jdbc驱动，更广泛一些加载一些其他的实现包<br>URL url = new URL(“file:D:/test.jar”);<br>URLClassLoader myclassLoader1 = new URLClassLoader(new URL[]                        {},Thread.currentThread.getContextClassLoader());<br>Class&lt;?&gt; myclass1 = myClassLoader1.loadClass(“com.antmq.dynamic.TestAction”);//后面加载的为其实现类<br>Abstraction action1 = (AbstactAction)myClass1.newInstance();//AbstractionAction是一个接口<br>String str1 =action1.action();</p>
<p>HDFS上的jar包，不能直接用，因为url不支持hdfs协议。<br>URL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory());<br>这样就支持hdfs协议了，path就可以转url了，当然，得加载下hdfs相关配置文件，获取FileSystem实例<br>Path path = fs.getFileStatus(new Path(jarPath)).getPath();<br>URL url = path.toUri().toURL();<br>classLoader.addJar(url);  </p>
<h1 id="如果加载的是mapreduce程序的jar包，只能是本地路径，不能使用hdfs路径，在setJarByClass方法中，是需要寻找到jar包绝对路径的"><a href="#如果加载的是mapreduce程序的jar包，只能是本地路径，不能使用hdfs路径，在setJarByClass方法中，是需要寻找到jar包绝对路径的" class="headerlink" title="如果加载的是mapreduce程序的jar包，只能是本地路径，不能使用hdfs路径，在setJarByClass方法中，是需要寻找到jar包绝对路径的"></a>如果加载的是mapreduce程序的jar包，只能是本地路径，不能使用hdfs路径，在setJarByClass方法中，是需要寻找到jar包绝对路径的</h1><p>使用一段时间后发现，进程是不停的，需要加载的jar包是可能需要修改的，所以导致多次加载不同版本的jar包之后，程序会有bug，读不到最新的jar包，不太可能更新jar包就重启下程序<br>于是，又研究了下classloarder，在当前线程加载jar包比较保险，线程结束会释放掉，保证每次加载都是最新的，而且也不占内存<br>(URLClassLoader)ClassLoader.getSystemClassLoader();    </p>
<p>改为当前线程类加载器<br>(URLClassLoader)Thread.currentThread().getContextClassLoader(); </p>
<p>====================================================================<br>java.lang.ClassLoader几个重要方法<br>//加载指定名称（包括包名）的二进制类型，供用户调用的接口<br>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException{ … }  </p>
<p>//加载指定名称（包括包名）的二进制类型，同时指定是否解析（但是这里的resolve参数不一定真正能达到解析的效果），供继承用<br>protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ … }  </p>
<p>//findClass方法一般被loadClass方法调用去加载指定名称类，供继承用<br>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { … }  </p>
<p>//定义类型，一般在findClass方法中读取到对应字节码后调用，可以看出不可继承<br>//（说明：JVM已经实现了对应的具体功能，解析对应的字节码，产生对应的内部数据结构放置到方法区，所以无需覆写，直接调用就可以了）<br>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError{ … }  </p>
<p>自底向上判断是否装载，自顶向下尝试装载；<br>Class.forName(String name)默认会使用调用类的类加载器来进行类加载<br>在不指定父类加载器的情况下，默认采用系统类加载器</p>
<p>java程序动态扩展方式：<br>调用Class.forName<br>用户自定义加载器<br>1、首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2；<br>　　2、委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，真实虚拟机中各种类加载器最终会呈现树状结构），如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3；<br>　　3、调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转而抛异常，终止加载过程（注意：这里的异常种类不止一种）。<br>标准扩展类加载器和系统类加载器及其父类（java.net.URLClassLoader和java.security.SecureClassLoader）都没有覆写java.lang.ClassLoader中默认的加载委派规则—loadClass（…）方法。有关java.lang.ClassLoader中默认的加载委派规则前面已经分析过，如果父加载器为null，则会调用本地方法进行启动类加载尝试。</p>
<p>线程上下文类加载器 解决SPI（service provider interface）<br>SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题</p>
<p>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。<br>使用线程上下文类加载器，可以在执行线程中抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类<br>Web容器、hot swap都使用了线程上下文加载器</p>
<h2 id="一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程"><a href="#一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程" class="headerlink" title="一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程"></a>一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程</h2><p>Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。</p>
<p>OSGi是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse就是基于OSGi 技术来构建的<br>OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。<br>　OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。</p>
<ol>
<li>当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。 </li>
<li>当使用本类托管类加载，然而加载本类的ClassLoader未知时，为了隔离不同的调用者，可以取调用者各自的线程上下文类加载器代为托管。<br>简而言之就是ContextClassLoader默认存放了AppClassLoader的引用，由于它是在运行时被放在了线程中，所以不管当前程序处于何处（BootstrapClassLoader或是ExtClassLoader等），在任何需要的时候都可以用Thread.currentThread().getContextClassLoader()取出应用程序类加载器来完成需要的操作。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/07/08/Java线上问题排查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="万水千山">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/Java线上问题排查/" itemprop="url">Java线上问题排查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T10:22:06+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>线上问题调查常用命令<br>linux性能检测工具<br>     CPU<br>          基本概念:<br>               1.上下文切换<br>               2.运行队列<br>                    每个处理器运行队列应该不超过1-3个线程<br>               3.load<br>                    一段时间内cpu正在处理以及等待cpu处理的进程数之和的统计信息</p>
<pre><code>               安全load值:一般是cpu个数
                --------------------------------------------------------------
               uptime/w
               uptime命令可以显示系统运行多久、当前有多少的用户登录、在过去的1，5，15分钟里平均负载时多少
          4.CPU利用率
               User Time           65-70%(经验值:正常的均衡比例)
               System Time         30-35%(经验值:正常的均衡比例)
               Wait IO             
               Idel                0-5%(经验值:正常的均衡比例)
               --------------------------------------------------------------
               cpu信息:
                    cat /proc/cpuinfo
                    grep &apos;processor&apos; /proc/cpuinfo | wc -l
               --------------------------------------------------------------
               vmstat 1 100
                    procs（进程）：
                         r: 运行队列中进程数量
                         b: 等待IO的进程数量
                    memory（内存）：
                         swpd: 使用虚拟内存大小
                         free: 可用内存大小
                         buff: 用作缓冲的内存大小
                         cache: 用作缓存的内存大小
                    swap：
                         si: 每秒从交换区写到内存的大小
                         so: 每秒写入交换区的内存大小
                    io：（现在的Linux版本块的大小为1024bytes）
                         bi: 每秒读取的块数
                         bo: 每秒写入的块数
                    system：
                         in: 每秒中断数，包括时钟中断。
                         cs: 每秒上下文切换数。
                    cpu（以百分比表示）：
                         us: 用户进程执行时间(user time)
                         sy: 系统进程执行时间(system time)
                         id: 空闲时间(包括IO等待时间)
                         wa: 等待IO时间
                    例子:
                    procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
                     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
                     0  0      0 3780980  45064 1387444    0    0    55     3   41   67  1  0 99  1  0
               --------------------------------------------------------------
               top
                    H show all thread by process
                    P 按cpu占用排序
                    M 按内存占用排序
                    1 显示cpu个数
               --------------------------------------------------------------
               mpstat -P ALL 1 (Multiprocessor Statistics)
               --------------------------------------------------------------
               sar 能够查看历史数据, 也能查看实时数据
               sar -q 查看load情况
               sar -u 查看cpu使用率
               sar -q -f /var/log/sa/saXX 查看之前某一天的历史记录

          5.中断

Memory
     Virtual Memory
     kswapd
          kswapd进程确保内存空间总是在被释放中
     pdflush
          负责将内存中的内容和文件系统进行同步操作, 即写操作返回的时候数据并没有真正写到磁盘上, 而是先写到了系统的cache中, 随后又pdflush内核线程将系统中的脏页写到磁盘上
     内存信息
          cat /proc/meminfo
     --------------------------------------------------------------
     ps aux (RSS:实际占用的物理内存)
     ps -p javaProcessId -o rss 查看java进程内存使用情况
     --------------------------------------------------------------
     sar -r 内存和交换分区的使用率

磁盘IO
     df -ha 检查磁盘占用情况
     du -ha /XX(目录) 查看目录内档案占用磁盘大小
     iostat -x -d 1
     sar -b

Network
     ifconfig 网路配置信息
     ping
          TTL:IP数据包经过一个路由ttl减1
     netstat
          -a或-all: 显示所有连线的socket
          -n或-numeric: 直接使用IP, 不通过域名服务器
          -p或programs: 显示正在使用socket的程序识别码和程序名称
          -t或-tcp: 显示tcp连线状况
          netstat -anpt
     sar -n SOCK 查看网络链接资源
          totsck: Total number of sockets
          tcpsck: Number of tcp sockets cureently in use
     sar -n DEV 查看网络流量
     lsof 列出被进程打开的文件信息(比如调查too many open file 错误)
               lsof -p                     进程id
               lsof +D [目录]      目录下文件是否被某进程打开

其他:
     端口相连接的机器数:
          ss -nao | grep 18090 | wc -l
          netstat -anpt | grep 18090 | wc -l
     查看java线程:
          ps -eLf | grep java | wc -l
</code></pre><hr>
<p>jvm性能相关:<br>     java堆的经验值:<br>          Space                                Option                             Occupancy Factor<br>          Java heap                           -Xmx                               3x or 4x old generation space occupancy after full garbage collection<br>          Perm Generation                -MaxPermSize                1.2 or 1.5x perm generation space occupancy after full garbage collection<br>          Young Generation              -Xmn                               1x or 1.5x young generation space occupancy after full garbage collection<br>          Old Generation                                                           2x or 3x old generation space occupancy after full garbage collection</p>
<pre><code>jps（JVM Process Status Tools）
     jps [option] [hostid]
     其中hostid默认为本机，而option选项包含以下选项
          --------------------------------------------------------------
          Option    Function
          -q   只输出LVMID
          -m   输出JVM启动时传给主类的方法
          -l   输出主类的全名，如果是Jar则输出jar的路径
          -v   输出JVM的启动参数

jstat（JVM Statistics Monitoring Tools）
     jstat主要用于监控虚拟机的各种运行状态信息，如类的装载、内存、垃圾回收、JIT编译器等
     jstat [option vmid [interval [s|ms] [vount] ] ]
     参数interval和count分别表示查询间隔和查询次数，如每1毫秒查询一次进程20445的垃圾回收情况，监控20次，命令如下所示：
          jstat –gc 20445 1 20
          --------------------------------------------------------------
          Option    Function
          -class    监视类的装载、卸载数量以及类的装载总空间和耗费时间等
          -gc  监视Java堆，包含eden、2个survivor区、old区和永久带区域的容量、已用空间、GC时间合计等信息
          -gccapcity     监视内容与-gc相同，但输出主要关注Java区域用到的最大和最小空间
          -gcutil   监视内容与-gc相同，但输出主要关注已使用空间占总空间的百分比
          -gccause  与-gcutil输出信息相同，额外输出导致上次GC产生的原因
          -gcnew    监控新生代的GC情况
          -gcnewcapacity 与-gcnew监控信息相同，输出主要关注使用到的最大和最小空间
          -gcold    监控老生代的GC情况
          -gcoldcapacity 与-gcold监控信息相同，输出主要关注使用到的最大和最小空间
          -gcpermcapacity     输出永久带用到的最大和最小空间
          -compiler 输出JIT编译器编译过的方法、耗时信息
          -printcompilation   输出已经被JIT编译的方法

jinfo（JVM configuration Info for Java）
     Jinfo的作用是实时查看虚拟机的各项参数信息
     Jinfo [option] pid
          如 jinfo –sysprops {pid}

jmap（JVM Memory Map for Java）
     jmap用于生成堆快照（heapdump）。当然我们有很多方法可以取到对应的dump信息，如我们通过JVM启动时加入启动参数 –XX:HeapDumpOnOutOfMemoryError参数，可以让JVM在出现内存溢出错误的时候自动生成dump文件，亦可以通过-XX:HeapDumpOnCtrlBreak参数，在运行时使用ctrl+break按键生成dump文件，当然我们也可以使用kill -3 pid的方式去恐吓JVM生成dump文件。jmap的作用不仅仅是为了获取dump文件，还可以用于查询finalize执行队列、Java堆和永久带的详细信息，如空间使用率、垃圾回收器等。
     jmap [option] vmip
          --------------------------------------------------------------
          Option    Function
          -dump     生成对应的dump信息，用法为-dump:[live,]format=b,file={fileName}
          -finalizerinfo 显示在F-Queue中等待的Finalizer方法的对象（只在linux下生效）
          -heap     显示堆的详细信息、垃圾回收器信息、参数配置、分代详情等
          -histo    显示堆栈中的对象的统计信息，包含类、实例数量和合计容量
          -permstat 以ClassLoder为统计口径显示永久带的内存状态
          -F   当虚拟机对-dump无响应时可使用这个选项强制生成dump快照
          示例：jmap -dump:format=b,file=heap.dump 20445

jhat（JVM Heap Analysis Tool）
     jhat是用来分析dump文件的一个微型的HTTP/HTML服务器，它能将生成的dump文件生成在线的HTML文件，让我们可以通过浏览器进行查阅，然而实际中我们很少使用这个工具，因为一般服务器上设置的堆、栈内存都比较大，生成的dump也比较大，直接用jhat容易造成内存溢出，而是我们大部分会将对应的文件拷贝下来，通过其他可视化的工具进行分析
          jhat {dump_file}
               执行命令后，我们看到系统开始读取这段dump信息，当系统提示Server is ready的时候，用户可以通过在浏览器键入http://ip:7000进行查询。

jstack（JVM Stack Trace for java）
     jstack用于JVM当前时刻的线程快照，又称threaddump文件，它是JVM当前每一条线程正在执行的堆栈信息的集合。生成线程快照的主要目的是为了定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部时长过长导致线程停顿的原因。通过jstack我们就可以知道哪些进程在后台做些什么？在等待什么资源等！
     jstack [option] vmid
          --------------------------------------------------------------
          Option    Function
          -F   当正常输出的请求不响应时强制输出线程堆栈
          -l   除堆栈信息外，显示关于锁的附加信息
          -m   显示native方法的堆栈信息
          示例：jstack -l 20445

查找占用cpu高的java线程:
     top -H -p javaId                        // 找出java thread id
     printf &apos;0x%x\n&apos; java thread id          // 转16进制
     jstack
</code></pre><hr>
<pre><code>S0C：年轻代中第一个survivor（幸存区）的容量 (字节) 
     S1C：年轻代中第二个survivor（幸存区）的容量 (字节) 
     S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节) 
     S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节) 
     EC：年轻代中Eden（伊甸园）的容量 (字节) 
     EU：年轻代中Eden（伊甸园）目前已使用空间 (字节) 
     OC：Old代的容量 (字节) 
     OU：Old代目前已使用空间 (字节) 
     PC：Perm(持久代)的容量 (字节) 
     PU：Perm(持久代)目前已使用空间 (字节) 
     YGC：从应用程序启动到采样时年轻代中gc次数 
     YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) 
     FGC：从应用程序启动到采样时old代(全gc)gc次数 
     FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) 
     GCT：从应用程序启动到采样时gc用的总时间(s) 
     NGCMN：年轻代(young)中初始化(最小)的大小 (字节) 
     NGCMX：年轻代(young)的最大容量 (字节) 
     NGC：年轻代(young)中当前的容量 (字节) 
     OGCMN：old代中初始化(最小)的大小 (字节) 
     OGCMX：old代的最大容量 (字节) 
     OGC：old代当前新生成的容量 (字节) 
     PGCMN：perm代中初始化(最小)的大小 (字节) 
     PGCMX：perm代的最大容量 (字节)   
     PGC：perm代当前新生成的容量 (字节) 
     S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 
     S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 
     E：年轻代中Eden（伊甸园）已使用的占当前容量百分比 
     O：old代已使用的占当前容量百分比 
     P：perm代已使用的占当前容量百分比 
     S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节) 
     S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节) 
     ECMX：年轻代中Eden（伊甸园）的最大容量 (字节) 
     DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满） 
     TT： 持有次数限制 
     MTT ： 最大持有次数限制 
</code></pre><hr>
<p>其他</p>
<p>sudo -u admin /opt/taobao/java/bin/jstat -gcold <code>ps aux | grep tomcat | awk &#39;{ if($1==&quot;admin&quot;) print $2}&#39;</code> 1000 –&gt;gc</p>
<p>sudo -u admin /opt/taobao/java/bin/jstack -l <code>ps aux | grep tomcat | awk &#39;{ if($1==&quot;admin&quot;) print $2}&#39;</code> &gt; /tmp/js5.log –&gt;jvm_stack</p>
<p>sudo -u admin /opt/taobao/java/bin/jstat -gcutil <code>ps aux | grep tomcat | awk &#39;{ if($1==&quot;admin&quot;) print $2}&#39;</code> 1000 –&gt;gc老年代</p>
<p>top -Hp pid<br>printf ‘%x\n’ pid<br>jstack 10765 | grep ‘0x2a34’ -C5 –color</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hecy</p>
              <p class="site-description motion-element" itemprop="description">a dreamer</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hecy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
