<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="a dreamer">
<meta property="og:type" content="website">
<meta property="og:title" content="无病呻吟">
<meta property="og:url" content="http://hcyxy.tech/index.html">
<meta property="og:site_name" content="无病呻吟">
<meta property="og:description" content="a dreamer">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="无病呻吟">
<meta name="twitter:description" content="a dreamer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hcyxy.tech/"/>





  <title>无病呻吟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">无病呻吟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">hcy && xy</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/16/系统上运行程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/系统上运行程序/" itemprop="url">计算机系统(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T21:14:20+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index">
                    <span itemprop="name">计算机系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第二部分-系统上运行程序"><a href="#第二部分-系统上运行程序" class="headerlink" title="第二部分 系统上运行程序"></a>第二部分 系统上运行程序</h3><h4 id="7、链接"><a href="#7、链接" class="headerlink" title="7、链接"></a>7、链接</h4><p>将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可用于编译时(源代码-&gt;机器代码)，加载时，加载到内存并执行；执行于运行时，由应用执行。</p>
<h5 id="7-1-静态链接"><a href="#7-1-静态链接" class="headerlink" title="7.1 静态链接"></a>7.1 静态链接</h5><p>静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。链接器必须完成两个任务：</p>
<ul>
<li>符号解析。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。</li>
<li>重定位。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，重定位这些节，修改对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件。包含二进制代码和数据，在编译时与其他可重定位文件合并起来，创建一个可执行目标文件</li>
<li>可执行目标文件。包含二进制代码和数据，可以直接复制到内存执行；</li>
<li>共享目标文件。特殊的可重定位目标文件，可以在加载或者运行时被动态的加载进内存并链接。</li>
</ul>
<p>编译器和汇编器可重定位目标文件(包括共享目标文件)，链接器生成可执行目标文件。</p>
<h5 id="7-2-与静态库链接"><a href="#7-2-与静态库链接" class="headerlink" title="7.2 与静态库链接"></a>7.2 与静态库链接</h5><p>之前都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上所有编译系统都提供一种机制将所有相关目标模块打包成一个单独文件，称为<strong>静态库，可以用做链接器的输入</strong>。当链接器构造一个输出的可执行文件，只复制静态库里被应用程序引用的目标模块。</p>
<p><strong>为什么OS要支持库的概念？</strong><br><br>定义了一组广泛的标准I/O、字符串操作和整数数学函数。如果不适用静态库，如何向用户提供这些函数。一：让编译器辨认出对标准函数的调用，并直接生成响应代码，对c不适合，因为c标准定义了大量标准函数，这种方法给编译器增加了复杂性，每次添加删除或修改标准函数，就需要一个新的编译器版本。</p>
<p>另一种方法：将所有标准C函数放在一个单独可重定位目标模块中，应用程序可以把这个模块链接到可执行文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc min.c /usr/lib/libc.o</span><br></pre></td></tr></table></figure></p>
<p>这种方法优点：将编译器的实现与标准函数实现分离开来，很大缺点是系统中每个可执行文件都包含一份标准函数集合副本，对磁盘空间是很大浪费。另一个缺点：对任何标准函数的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件。</p>
<p>可以通过为每个标准函数创建一个独立的可重定位文件，把它们存放在一个公共目录，要求应用程序显示链接合适的目标模块到可执行文件中，耗时且容易出错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c /usr/lib/printf.o /usr/lib/scanf.o</span><br></pre></td></tr></table></figure></p>
<p>静态库用来解决这些缺点，相关函数被编译为独立目标模块，封装成一个单独静态库文件，应用程序可以通过在命令行上治理领单独的文件名来使用这些在库中定义的函数。</p>
<p>然后进行重定位：</p>
<ul>
<li>重定位条目：汇编器生成一个目标模块时，并不知道数据和代码最终放在内存什么位置，不知道这个模块引用任何外部定义的函数或者全局变量的位置。汇编器遇到对最终位置未知的目标引用，会生成一个<strong>重定位条目。</strong> 告诉链接器在将目标文件合并成可执行文件时如何修改这个引用；</li>
<li>重定位符号引用。1）重定位PC相对引用；2）重定位绝对引用，相对简单；</li>
</ul>
<h5 id="7-3-可执行目标文件"><a href="#7-3-可执行目标文件" class="headerlink" title="7.3 可执行目标文件"></a>7.3 可执行目标文件</h5><p>将ASCII文本文件转化为一个二进制文件，且二进制文件包含加载程序到内存并运行所需的所有信息，包括只读内存段(代码段)、读/写内存段(数据段)、不加载到内存的符号表和调试信息。</p>
<h5 id="7-4-加载可执行目标文件"><a href="#7-4-加载可执行目标文件" class="headerlink" title="7.4 加载可执行目标文件"></a>7.4 加载可执行目标文件</h5><p>比如执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ./start</span><br></pre></td></tr></table></figure></p>
<p>start不是一个内置的shell命令，shell会认为start是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器loader的OS代码来运行它。任何linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序第一条指令或入口点来运行该程序，将程序复制到内存并运行的过程叫加载。</p>
<p>动态链接共享库：静态库缺点需要定期维护和更新，另一个问题是每个c程序都使用标准IO函数，比如pritnf、scanf。运行时将这些函数代码复制到进程的文本段中，是堆内存资源的浪费。</p>
<p>共享库是致力于解决静态库缺陷的一个产物，共享库是一个目标模块，运行加载时，可以加载到任意内存地址，并和一个在内存中的程序链接起来，这个过程称为动态链接。linux中常用.so后缀来表示，windows中的共享库，被称为DLL。内存中一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。</p>
<h5 id="7-5-从应用程序中加载和链接共享库"><a href="#7-5-从应用程序中加载和链接共享库" class="headerlink" title="7.5 从应用程序中加载和链接共享库"></a>7.5 从应用程序中加载和链接共享库</h5><p>应用程序可能在其运行时要求动态链接器加载和链接某个共享库，无需在编译时将那些库链接到应用中。思路是：将每个生成动态内容的函数打包在共享库中，当一个来自web请求到达，服务器动态加载和链接适当函数，直接调用，而不是使用fork和execve在自己进程上下文中运行函数。</p>
<p><strong>共享库和java本地接口</strong><br><br>java定义了一个标准调用规则，叫做java本地接口，允许java调用本地c和c++函数，基本思想是将本地c函数编译到共享库中，当一个正在运行的java程序试图调用函数时，java解释器利用dlopen接口动态链接和加载xx.so，再调用具体函数。</p>
<h5 id="7-6-位置无关代码"><a href="#7-6-位置无关代码" class="headerlink" title="7.6 位置无关代码"></a>7.6 位置无关代码</h5><p>多个进程如何共享程序的一个副本。一种方法给每个共享库分配一个事先预备的专用地址空间片，然后要求加载器在这个低智商加载共享库，会使地址空间使用效率不高，因为一个进程即使不使用这个库，部分空间还是被分配出来，难以管理，必须保证没有片会重叠。当一个库修改了之后，必须确认已分配给它的片还适合它的大小。不适合必须找一个新的片。</p>
<p>要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置无需链接器修改，使用这种方法无限多个进程可以共享一个共享模块的代码的单一副本。可以加载无需定位的代码称为位置无关代码PIC。</p>
<ul>
<li>PIC数据引用。编译器通过：无论在内存何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总保持不变。因此代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置无关。需要引入一个全局偏移量表GOT。</li>
<li>PIC函数调用。假设程序调用一个共享库定义的函数，编译器没办法预测这个函数的运行时地址，因为共享模块可以加载到任意位置。GUN编译系统使用延迟绑定lazy binding，将过程地址绑定推迟到第一次调用该过程时。比如libc.so包含上千个函数，只会使用其中部分，将函数地址解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。</li>
</ul>
<h4 id="8、异常控制流"><a href="#8、异常控制流" class="headerlink" title="8、异常控制流"></a>8、异常控制流</h4><p>系统需要一些机制对由程序变量表示的内部程序状态中的变化做出反应。这些系统状态不是被内部程序变量捕获的，也不一定要和程序的执行相关。比如一个硬件定时器定期产生信号，这个事件必须得到处理；包到达网络适配器后，必须放在内存中；程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。OS通过异常控制流ECF，对这些突变做出反应。</p>
<ul>
<li>ECF是OS实现IO、进程、虚拟内存的基本机制；</li>
<li>ECF可以理解应用程序如何与OS交互；应用程序通过使用trap、系统调用的ECF形式，向OS请求服务；</li>
<li>ECF帮助理解并发。</li>
</ul>
<p>在任何情况下，当处理器检测到有事件发生，就会通过异常表exception table的跳转表，进行一个间接过程调用(异常)到一个专门设计用来处理这类事件的操作系统子程序。异常处理完成后，会进行：</p>
<ul>
<li>处理程序将控制返回给当前指令<code>$I_{curr}$</code></li>
<li>将控制返回给<code>$I_{next}</code>，没有发生异常执行下一条指令</li>
<li>处理程序终止被中断的程序</li>
</ul>
<h6 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h6><p>系统中每种类型的异常都分配了唯一的非负整数的异常号，一些号码由处理器设计者分配(包括被零除、缺页、内存访问违例、断点以及算术运算溢出)，其他号码由OS内核设计者分配(包括系统调用和来自外部I/O设备信号)。</p>
<p>系统启动时OS分配和初始化一张称为异常表的跳转表。运行时，处理器检测到发生一个事件，并且确定相应异常号k。随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应处理程序。异常表起始地址放在异常表基址寄存器的特殊CPU寄存器中。</p>
<p>异常类似于过程调用，有一些不同之处：</p>
<ul>
<li>过程调用，在跳转到处理程序前，处理器将返回地址压入栈中。根据异常类型，返回地址是当前指令或者是下一挑指令。</li>
<li>处理器也把一些额外处理器状态压到栈中，处理程序返回时，重新开始执行被中断的程序。</li>
<li>如果控制从用户程序转移到内核，所有项目都被压到内核栈中，而不是压到用户栈中；</li>
<li>异常处理程序运行在内核模式下，对所有系统资源都有完全访问权限。</li>
</ul>
<p>一旦硬件触发异常，由异常处理程序在软件中完成，处理完成后，通过执行一条特殊“从中断返回”指令，返回到被中断的程序，该指令将适当状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，状态恢复为用户模式。</p>
<p>异常类别：<br>|类别|原因|异步/同步|返回行为|<br>|—|—|—|—|<br>|中断|来自I/O设备信号|异步|返回到下一条指令|<br>|陷阱|有意的异常|同步|返回到下一条指令|<br>|鼓掌|潜在可恢复的错误|同步|可能返回到当前指令|<br>|终止|不可恢复的错误|同步|不会返回|</p>
<ul>
<li>中断：来自处理器外部的I/O设备信号结果，不是由任何一条专门指令造成的。I/O设备，如网络适配器、磁盘控制器、定时器芯片，通过向处理器芯片上一个引脚发信号，并将异常号放到系统总线上，触发中断；当前指令完成执行后，处理器注意到中断引脚电压变高，就从系统总线读取异常号，调用适当的中断处理程序；剩下的叫故障指令。</li>
<li>陷阱和系统调用。陷阱最重要的用途是在用户程序和内核之间提供一个过程一样的接口，叫做系统调用。用户程序经常向内核请求服务，如读文件read、创建新进程fork、加载新程序execve、终止进程exit。</li>
<li>故障。由错误情况引起，能够被故障处理程序修正，故障发生时，处理器将控制转移给故障处理程序。如缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出，就会发生故障。</li>
<li>终止。不可恢复的致命错误，如DRAM或SRAM位被损坏发生的奇偶错误。</li>
</ul>
<h6 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h6><p>异常是允许OS内核提供进程概念的基本构造块，进程也是OS最深刻、最成功概念之一。</p>
<p>系统中每个程序都运行在某个进程上下文中，上下文是由程序正确运行所需状态组成，包括存放在内存中的程序代码和数据，它的栈、通用目的寄存器的内容、PC、环境变量以及打开文件描述符的集合。</p>
<p>进程提供给应用程序的抽象：</p>
<ul>
<li>一个独立逻辑控制流，好像是独占的使用处理器；</li>
<li>一个私有地址空间，好像是独占使用内存系统。</li>
</ul>
<p>处理器通常是用某个控制寄存器中的一个模式位来提供用户态/内核态功能。设置了模式位，进程就运行在内核模式中。linux提供一种聪明的机制，叫做/proc文件系统，允许用户模式进程访问内核数据结构内容，比如cpu类型/proc/cpuinfo，某个特殊进程使用的内存段/proc/{pid}/maps。</p>
<h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><p>OS内核使用一种称为上下文切换的较高层形式的异常控制流实现多任务。内核为每个进程维护一个上下文，包括通用目的寄存器、浮点寄存器、PC、用户栈、状态寄存器、内核栈、各种内核数据结构(地址空间页表、进程表、打开文件的信息文件表)</p>
<p>执行系统调用（read）、sleep系统调用、中断都有可能引发系统调用</p>
<h6 id="8-3-进程控制"><a href="#8-3-进程控制" class="headerlink" title="8.3 进程控制"></a>8.3 进程控制</h6><p>父进程通过fork函数创建一个新的运行的子进程，子进程得到父进程用户级虚拟地址空间相同的一份副本，包括代码、数据段、堆、共享库以及用户栈、相同文件描述符副本。意味着子进程可以读写父进程中打开的任何文件。fork调用一次返回两次，在调用进程(父进程)返回子进程pid，在子进程返回o。</p>
<p>父进程和子进程相同但是独立的地址空间，每个进程都有相同用户栈、本地变量值、堆、全局变量值、相同的代码。但是都有各自私有的地址空间。</p>
<h6 id="8-3-2-回收子进程"><a href="#8-3-2-回收子进程" class="headerlink" title="8.3.2 回收子进程"></a>8.3.2 回收子进程</h6><p>一个进程由于某种原因终止，内核不是立即把它从系统清楚，而是保持一种已终止的状态，直到被父进程回收。当父进程回收已终止的子进程，内核将子进程的退出状态传递给父进程，抛弃已终止的进程。一个终止但未被回收的进程称为僵死进程。</p>
<p>如果父进程终止，内核会安排init进程称为孤儿进程的养父，init进程pid为1，系统启动时由内核创建的，不会终止，是所有进程祖先。如果父进程没有回收它的僵死子进程就终止了，内核会安排init进程去回收。</p>
<h6 id="8-3-3-让进程休眠"><a href="#8-3-3-让进程休眠" class="headerlink" title="8.3.3 让进程休眠"></a>8.3.3 让进程休眠</h6><p>sleep让一个进程挂起一段指定时间，sleep返回0，或者剩下要休眠的时间。</p>
<p>加载并运行程序：<br>execve函数加载并运行可执行目标文件filename。</p>
<p><strong>程序与进程</strong><br><br>程序是一堆代码和数据，可作为目标文件存于磁盘上，或者作为段存在地址空间中。进程是执行程序的一个具体实例，程序总是运行在某个进程上下文中。fork函数是在新的子进程中运行相同的程序，新的子进程是父进程一个复制品，execve是在当前进程上下文加载并运行一个新的程序，它会覆盖当前进程的地址空间，但没有创建新的进程。</p>
<h6 id="8-4-信号"><a href="#8-4-信号" class="headerlink" title="8.4 信号"></a>8.4 信号</h6><p>OS通过异常控制流来支持进程上下文切换，还有一种linux信号，允许进程和内核中断其他进程。</p>
<p>发送一个信号到目的进程由两个不同步骤组成：</p>
<ul>
<li>发送信号。内核通过更新目的进程上下文某个状态，发送一个信号给目的进程。发送信号可以有如下两种原因：1）内核检测到一个系统事件，如除零错误、子进程终止；2）一个进程调用kill函数</li>
<li>接收信号。目的进程被内核强迫以某种方式对信号的发送做出反应，它就接收了信号，进程可以忽略这个信号、终止或通过执行一个称为信号处理程序的用户层函数捕获这个信号。</li>
</ul>
<p>一个发出而没被接收的信号叫做待处理信号，一种类型至多有一个待处理信号，如果一个进程有一个类型为k的待处理信号，接下来发送到这个进程的类型为k的信号都不会排队等待，直接丢弃。</p>
<p>一个待处理信号最多只能被接收一次，内核为每个进程在pending位向量中维护着待处理信号集合，在blocked位向量维护着被阻塞的信号集合。只要传送一个类型为k的信号，内核就会设置pending中第k位，而只要接收了一个类型为k的信号，内核就会清楚pending中第k位。</p>
<p>每个进程都属于一个进程组，子进程和父进程属于同一个进程组；kill向另外进程发送信号；shell使用作业这个抽象概念对一条命令行求值而创建的进程，任何时刻至多只有一个前台作业和多个后台作业。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ls | sort</span><br></pre></td></tr></table></figure></p>
<p>会创建一个由两个进程组成的前台作业，两个后台进程组；这两个进程通过unix管道连接起来，一个ls程序，一个sort程序，shell为每个作业创建一个独立的进程组，进程组ID取父进程中的一个。</p>
<p>键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组每个进程，默认情况终止前台作业；输入Ctrl+Z会发送SIGTSTP信号到前台进程组每个进程，结果是停止(挂起)前台作业。</p>
<p>接收信号：当把进程p从内核模式切换到用户模式(如从系统调用返回或是完成了一次上下文切换)，会检查进程p的未被阻塞的待处理信号的结合，</p>
<h6 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h6><p>c提供一种用户级别异常控制流形式，称为非本地跳转，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列，非本地跳转通过setjmp和longjmp函数提供。非本地跳转一个重要应用是允许从一个深层嵌套的函数调用立即返回，通常是由检测到某个错误引起的。</p>
<p>Linux提供大量的监控和操作进程的有用工具：</p>
<ul>
<li>STRACE，打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹；</li>
<li>PS列出当前系统中的进程</li>
<li>TOP：打印关于当前进程资源使用信息</li>
<li>PMAP：显示进程内存映射</li>
</ul>
<h5 id="9、虚拟内存"><a href="#9、虚拟内存" class="headerlink" title="9、虚拟内存"></a>9、虚拟内存</h5><p>虚拟内存VM是硬件异常、硬件地址翻译、主存、磁盘文件和内核文件的完美交互，为每个进程提供了一个大的、一致的、私有的地址空间。</p>
<ul>
<li>将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效使用主存；</li>
<li>为每个进程提供一致的地址空间，简化内存管理；</li>
<li>保护每个进程的地址空间不被其他进程破坏</li>
</ul>
<p>使用虚拟寻址，CPU通过生成一个虚拟地址Virtual Address来访问主存，这个VA被送到主存前先转换成适当物理地址，将一个VA转换成物理地址的任务叫做地址翻译address translation。地址翻译需要CPU硬件和OS合作，CPU芯片上叫做内存管理单元MMU的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。</p>
<p><strong>虚拟内存空间被组织为一个存放在磁盘上的M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引</strong></p>
<h5 id="9-1-VM作为缓存工具"><a href="#9-1-VM作为缓存工具" class="headerlink" title="9.1 VM作为缓存工具"></a>9.1 VM作为缓存工具</h5><p>主存每个字节都有一个选自虚拟地址空间的虚拟地址和一个物理地址空间的物理地址；</p>
<p>磁盘上的内容缓存在主存中，磁盘上的数据被分割成块，作为磁盘和主存之间传输单元。VM将虚拟内存分割为虚拟页virtual page的大小固定块来处理这个问题。每个虚拟页VP大小为<code>$P=2^p$</code>字节。物理内存被分割为物理页PP，大小也为P字节，被称为页帧page frame。</p>
<p>任意时刻，虚拟页面集合分成三个不相交子集：</p>
<ul>
<li>未分配的：VM系统还未分配的页，未分配的块没有任何数据和它们相关联，不占用任何磁盘空间；</li>
<li>缓存的：当前已缓存在物理内存中的已分配页；</li>
<li>为缓存的：未缓存在无力内存中的已分配页；</li>
</ul>
<h6 id="9-1-1-DRAM缓存组织结构"><a href="#9-1-1-DRAM缓存组织结构" class="headerlink" title="9.1.1 DRAM缓存组织结构"></a>9.1.1 DRAM缓存组织结构</h6><p>SRAM缓存表示CPU和主存之间的L1、L2和L3高速缓存，用DRAM缓存表示虚拟内存系统的缓存，在主存中缓存虚拟页。DRAM比SRAM慢10倍，磁盘比DRAM慢大约慢10 0000倍。DRAM缓存不命中比SRAM缓存不命中更昂贵。</p>
<p><strong>因为大的不命中处罚和访问第一个字节开销，虚拟页往往很大，通常是4KB~2MB。由于大的不命中处罚，DRAM缓存是全相联的，任何虚拟页都可以放置在任何物理页中。不命中的替换策略也很重要，替换错了虚拟页的处罚也非常高，因此，与硬件对SRAM缓存，OS对DRAM缓存使用了更复杂精密的替换算法。因为对磁盘访问时间很长，DRAM缓存总是使用写回，而不是直写。</strong></p>
<h6 id="9-1-2-页表"><a href="#9-1-2-页表" class="headerlink" title="9.1.2 页表"></a>9.1.2 页表</h6><p>同任何缓存一样，VM必须有某种方法判定一个虚拟页是否缓存在DRAM某个地方，如果是还需要确定这个虚拟页在哪个物理页中，如果不命中，判断虚拟页存放在磁盘哪个位置，在物理内存中选择牺牲一页，将虚拟页从磁盘复制到DRAM，替换这个牺牲页。</p>
<p>这些功能是由软硬件联合提供的，包括OS软件、MMU内存管理单元中的地址翻译硬件和一个存放在物理内存的页表，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。OS负责维护页表内容，以及在磁盘与DRAM之间来回传送页。</p>
<p>页表就是一个页表条目(PTE)Page Table Entry的数组，虚拟地址空间中每个页在页表中一个固定偏移量处都有一个PTE。</p>
<p>DRAM缓存不命中称为缺页page fault，假如CPU引用了VP3中一个字，但是并未缓存在DRAM中，地址翻译硬件从内存读取PTE3，推断VP3未被缓存，并且触发一个缺页异常。缺页异常会调用缺页异常处理程序，该程序会选择一个牺牲页，(存放存放PP3的VP4)，如果VP4已经被修改，内核就会将其复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，表明VP4不再缓存在主存中。</p>
<p>接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3.随后返回，当异常处理程序返回时，会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是VP3已经缓存在主存中，页命中也能由地址翻译硬件正常处理了。</p>
<p>虚拟内存和SRAM缓存有很多相似的概念但是使用了不同术语，虚拟内存中，块被称为页，磁盘和内存之间传送页的活动叫做交换swapping或者页面调度。页从磁盘换入DRAM、从DRAM换出磁盘，当有不命中发生时，才换入页面的这种策略称为按需页面调度。</p>
<p><strong>虚拟页和磁盘文件映射，然后缓存到物理页。</strong></p>
<h6 id="9-1-3-分配页面"><a href="#9-1-3-分配页面" class="headerlink" title="9.1.3 分配页面"></a>9.1.3 分配页面</h6><p>当OS分配一个新的虚拟内存页，如调用malloc的结果，VP5的分配过程是在磁盘上创建空间并更新PTE5，使它指向磁盘上这个新创建的页面。</p>
<h6 id="9-1-4-局部性"><a href="#9-1-4-局部性" class="headerlink" title="9.1.4 局部性"></a>9.1.4 局部性</h6><p>尽管在整个运行过程中程序引用不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了任意时刻，程序将趋于在一个较小的活动页面集合上工作，这个集合叫工作集working set或者常驻集合。在初始开销，将工作集调度到内存后，接下来对这个工作集的引用将导致命中，不会产生额外磁盘流量。</p>
<p>只要程序有良好局部性，虚拟内存就能工作的很好。如果工作集大小超出了物理内存大小，程序就会产生抖动，这时页面不断地换进换出。</p>
<h6 id="9-1-5-虚拟内存作为内存管理工具"><a href="#9-1-5-虚拟内存作为内存管理工具" class="headerlink" title="9.1.5 虚拟内存作为内存管理工具"></a>9.1.5 虚拟内存作为内存管理工具</h6><p>OS为每个进程提供一个独立的页表，即一个独立的虚拟地址空间。比如进程i的页表将VP1映射到PP2，VP2映射到PP7。进程j的页表将VP1映射到PP7，VP2映射到PP10，多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p>VM简化了链接、加载、代码和数据共享，以及应用程序的内存分配：</p>
<ul>
<li>简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，不管代码和数据实际存放在物理内存何处。一个linux系统上每个进程都使用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址0x400000开始，数据段跟在代码段后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高部分，向下生长。这样的一致性极大简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中的代码、数据的最终位置；</li>
<li>简化加载。VM使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中的.text和.data加载到一个新创建的进程，Linux加载器为代码和数据段分配虚拟页，把它们标记为无效的(未被缓存的),将页表条目指向目标文件适当位置。<strong>但是加载器不从磁盘复制数据到内存。在每个页初次被引用时，要么是CPU取指令时引用的、或是一条正在执行的指令引用一个内存位置时引用的，VM会按照需要自动调入数据页。</strong><br>将一组连续虚拟页映射到任意一个文件中的任意位置表示的方法称作内存映射memory mapping。linux提供一个mmap的系统调用，允许应用程序自己做内存映射。</li>
<li>简化共享。独立地址空间为OS提供一个管理用户进程和OS自身之间共享的一致机制。一般情况下，每个进程都有自己私有的代码、数据、堆以及栈区，是不和其他进程共享的。这种情况，OS创建页表，将相应虚拟页映射到不连续的物理页面。</li>
</ul>
<p><strong>一些情况下需要进程共享代码和数据，如每个进程需调用相同OS内核代码(printf)。OS将不同进程中相应的虚拟页面映射到相同物理页面，从而多个进程共享这部分代码的一个副本。</strong></p>
<ul>
<li>简化内存分配。VM向用户进程提供一个简单的分配额外内存的机制，当一个运行在用户进程中的程序要求额外的堆空间，OS分配一个适当数字(k)个连续虚拟内存页面，将它们映射到物理内存中任意位置的k个任意的物理页面。由于页表工作方式，OS没有必要分配k个连续的物理内存页面，页面可以随机分散在物理内存中。</li>
</ul>
<h5 id="9-2-虚拟内存作为保护工具"><a href="#9-2-虚拟内存作为保护工具" class="headerlink" title="9.2 虚拟内存作为保护工具"></a>9.2 虚拟内存作为保护工具</h5><p>不允许用户进程修改只读代码段，不允许读或修改任何内核中的代码和数据结构，不允许读其他进程私有内存，不允许修改与其他进程共享的虚拟页面。</p>
<p>提供独立的地址空间使得区分不同进程的私有内存变的容易。但是地址翻译机制以一种自然的方式扩展到提供更好的访问控制，<strong>每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，通过在PTE添加一些额外的许可位来控制对一个虚拟页内容的访问。</strong> 比如PTE添加三个许可位，SUP位表示是否只能在内核模式访问，READ和WRITE控制对页面的读和写访问。如果一条指令违反这些许可条件，CPU会触发一个一般保护故障，将控制传给内核异常处理程序，段错误segmentation fault。</p>
<h5 id="9-3-地址翻译"><a href="#9-3-地址翻译" class="headerlink" title="9.3 地址翻译"></a>9.3 地址翻译</h5><p>MMU利用页表实现虚拟内存映射，CPU中一个控制寄存器-页表基址寄存器PageTableBaseRegister指向当前页表，n位的虚拟地址包含两部分，一个p位的虚拟页面偏移VPOffset和一个n-p位的虚拟页号virtual page number。MMU利用VPN选择适当PTE。当页面命中时，CPU执行步骤：</p>
<ul>
<li>处理器生成一个虚拟地址，传送给MMU</li>
<li>MMU生成PTE地址，从高速缓存/缓存请求得到；</li>
<li>高速缓存/主存向MMU返回PTE</li>
<li>MMU构造物理地址，并把它传送给告诉缓存/主存</li>
<li>高速缓存/主存返回所请求的数据字给处理器</li>
</ul>
<p>页面命中完全由硬件处理，处理缺页要求硬件和OS内核协作完成：</p>
<ul>
<li>1-3步与上述相同</li>
<li>PET中有效位是0，MMU触发异常，传递CPU中的控制到OS内核中的缺页异常处理程序；</li>
<li>缺页处理程序确定出物理内存中的牺牲页，如果这个页被修改了，换出到磁盘；</li>
<li>缺页处理程序页面调入新的页面，并更新内存中的PTE</li>
<li>缺页处理程序返回到原来进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。</li>
</ul>
<h6 id="9-3-1-结合高速缓存和虚拟内存"><a href="#9-3-1-结合高速缓存和虚拟内存" class="headerlink" title="9.3.1 结合高速缓存和虚拟内存"></a>9.3.1 结合高速缓存和虚拟内存</h6><p>在使用虚拟内存和SRAM的系统中，存在使用虚拟地址还是物理地址访问SRAM的问题，大多数会使用物理寻址。使用物理寻址，多个进程同时在cache中有存储块和共享来自相同虚拟页面的块是很简单的，cache无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</p>
<p><strong>假如CPU执行两道不同进程，进程的指令访问都是基于虚拟地址的，可能出现：进程A在被执行一段时间后，由于进程调度，被切换出去，需要执行进程B，而进程A的PCA(进程A的取地址指针)所指向的一段代码在cache中，而进程B的PCB由于是虚拟地址概念，有可能PCA=PCB(经过虚实地址转换后，物理PCB不会等于PCA)，如果在cache中利用PCB访问PCA，则会导致cache hit。为了解决这个问题，就采用物理地址访问cache，需要将地址进行一次转换</strong></p>
<p>用虚拟地址访问cache：</p>
<ul>
<li>如果两段进程虚拟PC正好相同，会出现虚地址访问cache冲突；</li>
<li>安全保护方法基于进程描述符ID，体现到了内存页表上，因此OS保护依赖于页表的安全，如果cache直接用虚拟地址访问，就绕过了页表机制，从而使用流水线中指令的执行不再存在保护；</li>
<li>OS允许多个虚拟页面映射到同一个物理地址页面空间，如果纯粹是虚拟地址访问，可能出现读写不一致情况；</li>
<li>读写外部设备问题：现在外部IO设备的地址映射一般是物理地址映射，TLB可以把虚拟地址映射为物理地址，但是在读写外部IO设备时，没有机制把物理地址映射为虚拟地址；</li>
</ul>
<p>虚拟地址访问cache，物理地址比较tag，利用了页表的虚拟地址和物理地址在低位是相同的，不同的是高位映射，物理地址映射：</p>
<ul>
<li>利用虚拟地址访问TLB，进行虚实地址转换，假设TLB命中，需要一个时钟周期；</li>
<li>利用得到的物理地址访问cache，取出cache行的tag信息和data信息；假设命中需要一个时钟周期；</li>
<li>基于物理地址，对TAG信息进行比较选择合适cache data。</li>
</ul>
<p>虚实结合方式：</p>
<ul>
<li>利用虚拟地址访问TLB，虚实地址转换，在这个周期中，利用虚拟地址低位访问cache，取出cache中存储的tag信息和data信息，这个时候tag信息其实对应的是物理地址的tag；</li>
<li>假设TLB和cache都命中，利用上个节拍得到的物理地址进行tag比较，选择合适cache和data数据。</li>
</ul>
<p>主要思路是在地址翻译发生在高速缓存查找之前，页表条目可以缓存：<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/00ADDEA3642648D7BC31884F4A1D418F/29951" alt="image"></p>
<h6 id="9-3-2-利用TLB加速地址翻译"><a href="#9-3-2-利用TLB加速地址翻译" class="headerlink" title="9.3.2 利用TLB加速地址翻译"></a>9.3.2 利用TLB加速地址翻译</h6><p>每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。最坏情况要求从内存多取一次数据，代价是几百个周期。如果PTE碰巧缓存在L1中，开销就会下降到1或2个周期。在MMU中包括一个关于PTE的小的缓存，称为翻译后备缓冲器TLB。每一行都保存着一个由单个PTE组成的块，通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址的虚拟页号提取出来的，如果TLB有<code>$T=2^t$</code>个组，那么TLB索引是由VPN的t个最低位组成的，而TLB标记是由VPN剩余位组成的。<br>当TLB命中：</p>
<ul>
<li>CPU产生一个虚拟地址</li>
<li>MMU从TLB取出相应PTE</li>
<li>MMU将这个虚拟地址翻译成一个物理地址，发送到cache/memory</li>
<li>cache/memory将所请求的数据字返回给CPU</li>
</ul>
<p>TLB不命中时，MMU必须从L1缓存取出相应PTE，新取出的PTE存放在TLB中，可能会覆盖一个已存在的条目。</p>
<h6 id="9-3-3-多级页表"><a href="#9-3-3-多级页表" class="headerlink" title="9.3.3 多级页表"></a>9.3.3 多级页表</h6><p>用来压缩页表常用方法是使用层次结构的页表；多级页表从两个方面减少了内存要求：</p>
<ul>
<li>如果一级页表中一个PTE是空的，相应的二级页表根本不会存在，存在很大节约，因为大部分虚拟地址空间是未分配的；</li>
<li>只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建、页面调入或调出二级页表，减少了主存压力，只有最经常使用的二级页表才需要缓存在主存中。</li>
</ul>
<h5 id="9-4-Intel-Core-Linux内存系统"><a href="#9-4-Intel-Core-Linux内存系统" class="headerlink" title="9.4 Intel Core/Linux内存系统"></a>9.4 Intel Core/Linux内存系统</h5><p>处理器封装包括四个核、一个大的所有核共享的L3高速缓存以及一个DDR3内存控制器。每个核包含一个层次结构的TLB、一个层次结构的数据和指令高速缓存，以及一组快速的点到点链路，这个链路基于QuickPath技术，为了让一个核与其他核与外部I/O桥直接通信。TLB是虚拟寻址、四路组相联，L1、L2、L3是物理寻址的，块大小为64字节。L1和L2是8路组相联的，L3是16路组相联，页大小可以在启动时被配置为4KB或4MB,linux使用4KB的页，使用4级页表，每个进程有自己私有的页表层次结构，当一个linux进程在运行时，允许页表换进换出，但是与已分配的页相关联的页表都是驻留在内存中的。</p>
<h6 id="优化地址翻译"><a href="#优化地址翻译" class="headerlink" title="优化地址翻译"></a>优化地址翻译</h6><p>地址翻译有两个步骤：1）MMU将虚拟地址翻译成物理地址2）将物理地址传送到L1高速缓存。 硬件实际上允许这些步骤部分重叠，加速了对L1高速缓存的访问。比如页大小为4KB的系统上有12位的VPO，并且这些位和相应物理地址的PPO12位是相同的。因为八路组相联、物理寻址的L1有64个组和大小为64字节的缓存块，每个物理地址有6个缓存偏移位<code>$log_2^{64}$</code>和6个索引位，这12位恰好是虚拟地址VPO部分，这不是偶然。当CPU需要翻译一个虚拟地址，发送VPN到MMU，发送VPO到L1，当MMU向TLB请求一个页表条目时，L1利用VPO查找相应的组，读出这个组里8个标记和相应数据字，MMU从TLB得到PPN时，缓存已经准备好试着把这个PPN与这8个标记进行匹配了。</p>
<h6 id="9-4-2-Linux虚拟内存系统"><a href="#9-4-2-Linux虚拟内存系统" class="headerlink" title="9.4.2 Linux虚拟内存系统"></a>9.4.2 Linux虚拟内存系统</h6><p>linux为每个进程维护一个单独虚拟地址空间，内核虚拟内存包含内核的代码和数据结构，内核虚拟内存某些区域被映射到所有进程共享的物理页面。Linux也将一组连续的虚拟页面映射到相应的一组连续的物理页面，为内核提供便利的方法来访问物理内存中特定位置，例如当需要访问页表或一些设备上执行内存映射的I/O操作，而这些设备被映射到特定的物理内存位置。</p>
<p>内核虚拟内存其他区域包含每个进程都不相同的数据，比如页表、内核在进程的上下文中执行代码使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p>
<p>linux将VM组织成一些段的集合，一个段就是已经存在着的虚拟内存的连续片，这些页以某种方式相关联的，例如代码段、数据段、堆、共享库段，以及用户栈都是不同区域。</p>
<h5 id="9-5-内存映射"><a href="#9-5-内存映射" class="headerlink" title="9.5 内存映射"></a>9.5 内存映射</h5><p>linux将一个虚拟内存区域与一个磁盘上的对象关联起来，初始化这个虚拟内存区域的内容，这个过程就是内存映射memory mapping。虚拟内存可以映射到两种类型对象：</p>
<ul>
<li>Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件连续部分，例如一个可执行目标文件。文件区section被分成页大小的片，每一片都包含一个虚拟页面初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用页面(即发射一个虚拟地址)，如果区域比文件大，用零填充余下部分。</li>
<li>匿名文件。一个区域也可以映射到一个匿名文件，由内核创建，包含的全是二进制0。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中。在磁盘和内存间并没有实际的数据传送，因此映射到匿名文件的区域中的页面有时也叫请求二进制的页demand-zero page</li>
</ul>
<p>无论哪种情况，一旦一个虚拟页面被初始化了，就在一个由内核维护的专门的交换文件之间换来换去，交换文件也叫做交换空间swap space。任何时刻，<strong>交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</strong></p>
<h6 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h6><p>一个对象可以被映射到虚拟内存一个区域，作为共享对象或者私有对象。共享对象被映射到多个共享区域，物理内存只需要存放共享对象一个副本；私有对象使用一种叫做写时复制copy-on-write的技术映射到虚拟内存中。</p>
<h6 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h6><p>fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给新进程创建虚拟内存创建了当前进程的mm_struct、区域结构和页表原样副本，将两个进程中每个页表标记为只读，并将两个进程中两个区域结构都标记为私有的写时复制。当fork函数在新进程中返回时，新进程现在的VM刚好和调用fork时存在的VM内存相同，当两个进程中任一个后来进行写操作时，写时复制就会创建新页面，因此为每个进程保持了私有地址空间的抽象概念。</p>
<h6 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h6><p>虚拟内存和内存映射将程序加载到内存的过程中扮演很关键的角色。假如调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;a.out&quot;,null,null)</span><br></pre></td></tr></table></figure></p>
<p>execve函数在当前进程中加载并运行包含可执行文件的目标文件a.out中的程序，包括以下几个步骤：</p>
<ul>
<li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分的已存在的区域结构；</li>
<li>映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新区域都是私有的、写时复制的。代码和数据区域被映射到a.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为0.</li>
<li>映射共享区域。如果a.out与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到虚拟地址空间中的共享区域内。</li>
<li>设置程序计数器PC。execve做的最后一件事就是设置当前进程上下文中的PC，使之指向代码区域入口点。</li>
</ul>
<p>下一次调度这个进程，将从这个入口点开始执行。</p>
<h6 id="使用mmap函数的用户级内存映射"><a href="#使用mmap函数的用户级内存映射" class="headerlink" title="使用mmap函数的用户级内存映射"></a>使用mmap函数的用户级内存映射</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(vaoid *start,size_t length,int prot,int flags,int df,off_t offset)</span><br></pre></td></tr></table></figure>
<p>mmap函数要求内核创建一个新的虚拟内存区域，最好是从start开始的一个区域，并将文件描述符fd指定的对象的一个连续的片chunk映射到这个新的区域。连续的对象片大小文length字节，从距文件开始处偏移量为offset字节的地方开始。start地址仅仅是个暗示，通常被定义为null。</p>
<p>prot包含描述新映射的虚拟内存区域的访问权限位。flags由描述被映射对象类型的位组成，如果设置了MAP_ANON标记位，被映射的对象就是一个匿名对象，相应虚拟页是请求二进制的。MAP_PRIVATE表示被映射的对象是一个私有的、写时复制对象，MAP_SHARED表示是一个共享对象。munmap删除虚拟内存的区域。</p>
<h5 id="9-6-动态内存分配"><a href="#9-6-动态内存分配" class="headerlink" title="9.6 动态内存分配"></a>9.6 动态内存分配</h5><p>虽然可以使用mmap和munmap函数创建、删除虚拟内存区域，但是动态内存分配dynamic memory allocator更方便，也具有更好移植性。</p>
<p>动态内存分配器维护着进程虚拟内存区域的堆heap。它紧接着在未初始化的数据区域开始，向上生长(向更高的地址)，对于每个进程，内核维护着一个变量brk，指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片chunk，要么是已分配的、要么是空闲的。已分配的块保持已分配状态，直到它被释放，这种释放是程序显示执行、或者是内存分配器隐式执行。</p>
<ul>
<li>显示分配器。通过malloc和free管理内存；</li>
<li>隐式分配器。也叫做垃圾回收。</li>
</ul>
<p>malloc通过使用mmap和munmap函数，显示分配和释放堆内存，还可以使用sbrk函数，通过将内核的brk指针增加incr来扩展和收缩堆。</p>
<h6 id="为什么要使用动态内存分配"><a href="#为什么要使用动态内存分配" class="headerlink" title="为什么要使用动态内存分配"></a>为什么要使用动态内存分配</h6><p>谋者程序直到运行时才知道某些数据结构大小。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/09/计算机系统-程序结构和执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/计算机系统-程序结构和执行/" itemprop="url">计算机系统(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T20:05:30+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index">
                    <span itemprop="name">计算机系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一部分-了解计算机系统"><a href="#第一部分-了解计算机系统" class="headerlink" title="第一部分 了解计算机系统"></a>第一部分 了解计算机系统</h3><h4 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h4><p>系统中所有的信息–包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。<strong>区分不同数据对象的唯一方法：是我们读到的这些数据对象时的上下文。</strong> 比如在不同上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或机器指令。</p>
<h4 id="1-2-程序被其他程序翻译成不同格式"><a href="#1-2-程序被其他程序翻译成不同格式" class="headerlink" title="1.2 程序被其他程序翻译成不同格式"></a>1.2 程序被其他程序翻译成不同格式</h4><p>为了在系统上运行c程序，每条C语句都被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件形式存放起来，目标程序也称为可执行目标文件。GCC编译驱动程序读取源程序文件xxx.c，将其翻译成一个可执行目标文件xxx。这个翻译过程可分为四个阶段完成。执行这四个阶段的程序（预处理器、编译器、汇编器、链接器）一起构成编译系统。<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCEc7c89e0ae49c5e590b3c392e5082ef11/27775" alt="image"></p>
<ul>
<li>预处理阶段。预处理器CPP根据以字符#开头的命令，修改原始的C程序。比如hello.c第1行#include &lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h内容，并把它插入程序文本中，于是得到另一个以.i作文文件扩展名</li>
<li>编译阶段。编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，包含一个汇编语言程序，该程序包含main函数定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">  subq $8 %rsp</span><br><span class="line">  movl $.LCO,%edi</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上每条语句都以一种文本格式描述了一条低级机器语言指令，汇编语言为不同高级语言的不同编译器提供了通用的输出语言，例如C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。</p>
<ul>
<li>汇编阶段。接下来，汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序relocatable object program的格式，并将结果保存在目标文件hello.o中，是一个二进制文件，包含的17个字节是函数main的指令编码。</li>
<li>链接阶段。hello程序调用printf函数，它是每个C编译器提供的标准C库的一个函数。printf函数存在一个printf.o的单独的预编译好的目标文件中，而这个文件必须以某种方式合并到hello.o程序中。链接器ld就负责处理这种合并，结果就得到hello文件，是一个可执行目标文件（可执行文件），可被加载到内存中，由系统执行。</li>
</ul>
<p><strong>GUN环境包括EMACS编译器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。</strong></p>
<h4 id="1-3-了解编译系统"><a href="#1-3-了解编译系统" class="headerlink" title="1.3 了解编译系统"></a>1.3 了解编译系统</h4><ul>
<li>优化程序性能。为了在C程序中做出好的编码选择，需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。如一个switch语句是否比一系列if-else语句高效；一个函数调用的开销有多大？while循环比for循环高效么；指针引用比数组索引更有效么，为了将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快的多呢？为什么只是简单地重新排列一下算术表达式中的括号就能让函数运行的更快？</li>
<li>理解链接时出现的错误。一些最令人困扰的程序错误往往斗鱼链接器操作有关，比如链接器报告无法解析一个引用？静态变量和全局变量的区别是什么，在不同c文件定义了名字相同的两个全局变量会发生什么，静态库和动态库的区别是什么，命令行上排列库的顺序有什么影响。还有一些链接错误直到运行时才出现</li>
<li>避免安全漏洞。缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误的原因是因为很少有程序员能理解需要限制从不受信任的源接受数据的数量和格式。第一步要理解数据和控制信息存储在程序栈上的方式会引起的后果。</li>
</ul>
<h4 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h4><ul>
<li>总线。贯穿整个系统的是一组电子管道，称作总线，携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字word。大多数机器字长是4byte或8byte。</li>
<li>I/O设备。如键盘、鼠标、显示器、以及长期存储数据和程序的磁盘驱动器(磁盘)。</li>
<li>主存。临时存储设备，处理执行程序时，用来存放程序和程序处理的数据。物理上来说是由一组动态随机存取存储器DRAM芯片组成；逻辑上说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)。</li>
<li><p>处理器。中央处理单元CPU，是解释或执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器PC。任何时候PC都指向主存中某条机器语言指令，即含有该条指令的地址。从系统通电开始，处理器不断执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。CPU在指令要求下可能会执行：</p>
</li>
<li><p>加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容</p>
</li>
<li>存储：从寄存器复制一个字节或一个字到主存的某个位置，以覆盖这个位置上内容。</li>
<li>操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li>跳转：从指令本身抽取一个字，并将这个字复制到程序计数器PC中，覆盖原来的值。</li>
</ul>
<h4 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb控制器-&gt; I/O桥 -&gt;总线接口-&gt;寄存器文件-&gt;IO桥-&gt;主存储器</span><br></pre></td></tr></table></figure>
<p>比如运行hello，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。利用直接存储器读取(DMA)技术，数据可以不通过处理器而直接从磁盘到达主存。</p>
<h4 id="1-5-高速缓存"><a href="#1-5-高速缓存" class="headerlink" title="1.5 高速缓存"></a>1.5 高速缓存</h4><p>一个典型寄存器只存储几百字节信息，主存可存放几十亿字节，L1高速缓存容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快；数十万到数百万自己的更大的L2高速缓存通过一条特殊总线连接到处理器。进程访问L2比L1慢5倍，仍然比访问主存快5-10倍。L1和L2高速缓存</p>
<h4 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h4><p><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCE27dc8912cba66ae85ad101f8e0d2598e/27899" alt="image"></p>
<h4 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h4><p>操作系统有两个基本功能：</p>
<ul>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li>
</ul>
<p>OS通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O设备的抽象，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</p>
<h5 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h5><p>进程是操作系统对一个正在运行的程序一种抽象。多核处理器能同时能够执行多个程序，无论单核还是多核系统，一个cpu都像是在并发执行多个进程，是通过上下文切换实现的。OS跟踪进程所需的所有状态信息，就是上下文，如PC和寄存器文件的当前值、以及主存的内容。</p>
<h5 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h5><p>事实上，一个进程实际上可以由多个称为线程的执行单元组成，<strong>每个线程都运行在进程的上下文中，共享同样的代码和全局数据。</strong> 由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程高效。</p>
<h5 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h5><p>虚拟内存是一个抽象概念，为每个进程提供了一个假象，即每个进程独占使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。</p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成那个，每个区都有专门的功能。</p>
<ul>
<li>程序代码和数据。代码从一固定地址开始，紧接着是和C全局变量相对应的数据位置。</li>
<li>堆。代码和数据区后紧随着是运行时堆。当调用malloc和free这样的C标准库，堆可以在运行时动态扩展和收缩。</li>
<li>共享库。地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li>栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和碓一样，用户栈在程序执行期间可以动态的扩展和收缩。每次调用一个函数，栈就会增长；从一个函数返回，就会收缩。</li>
<li>内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们不调用内核来执行这些操作。</li>
</ul>
<h5 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h5><p>文件就是字节序列。每个I/O设备，包括磁盘、键盘、显示器、甚至网络都可以看成是文件。系统中所有输入输出都是通过一小组称为Unix I/O的系统函数调用读写文件来实现的。向应用程序提供了一个统一的视图。</p>
<h4 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h4><p>网络可视为一个I/O设备，当系统从主存复制一串字节到网络适配器，数据流经过网络到达另一台机器。</p>
<h4 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h4><h5 id="1-9-1-Amdahl定律-阿姆达尔定律"><a href="#1-9-1-Amdahl定律-阿姆达尔定律" class="headerlink" title="1.9.1 Amdahl定律 阿姆达尔定律"></a>1.9.1 Amdahl定律 阿姆达尔定律</h5><p>对提升系统某一部分性能所带来的效果做出了简单却有见地的观察，这个定律被称为阿姆达尔定律。主要思想：<strong>当对系统某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为<code>$T_{old}$</code>.假设系统某部分所需执行时间与该时间的比例为<code>$\alpha$</code>，而该部分性能提升比例为k。即该部分初始所需时间为<code>$\alpha T_{old}$</code>,现在所需时间为<code>$(\alpha T_{old})/k$</code></strong>，因此总的执行时间为：<br><code>$T_{new}$</code>=(1-<code>$\alpha$</code>)<code>$T_{old}$</code>+(<code>$\alpha T_{old}$</code>)/k</p>
<p>由此可以计算加速比<code>$S=T_{old}/T_{new}$</code><br><br><code>$S=\frac{1}{(1-\alpha)+\alpha/k}$</code></p>
<h5 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h5><h5 id="1-线程级并发"><a href="#1-线程级并发" class="headerlink" title="1.线程级并发"></a>1.线程级并发</h5><p>多核处理器是将多个CPU(核)集成到一个集成电路芯片上。下图是一个典型的多核处理器组织结构，微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，L1高速缓存分为两个部分：一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口，工业界专家预言能够将几十个、上百个核做到一个芯片上。<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/WEBRESOURCEcd1c97a23f754da2b46c224be0a02f8b/27993" alt="image"></p>
<p>超线程，也称为同时多线程，允许一个CPU执行多个控制流。涉及CPU某些硬件有多个备份，比如PC和寄存器，而其他的硬件部分只有一份，比如之幸福店算术运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪个线程。这使得CPU能够更好地利用它的处理资源，比如一个线程必须等到某些数据被装载到高速缓存中，那么CPU就可以继续执行另一个线程。比如Intel i7可以让每个核并行执行两个线程。</p>
<p>多处理器可以从两方面提高系统性能。</p>
<ul>
<li>减少了在执行多个任务时模拟并发的需要。</li>
<li>其次，可以使应用程序运行的更快。必须要求程序是以多线程方式来书写，这些线程可以并行的高效执行。</li>
</ul>
<h5 id="2-指令级并行"><a href="#2-指令级并行" class="headerlink" title="2.指令级并行"></a>2.指令级并行</h5><p>早期的微处理器，需要多个(3-10)时钟周期来执行一条指令，最近的处理器每个时钟周期执行2-4条指令。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为<strong>超标量处理器的高级模型。</strong></p>
<h5 id="3-单指令、多数据并行"><a href="#3-单指令、多数据并行" class="headerlink" title="3.单指令、多数据并行"></a>3.单指令、多数据并行</h5><p>许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如，较新几代的Intel和AMD处理器都具有并行的对8对单精度浮点数做加法的指令。</p>
<p>提供这些SIMD指令是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从C程序自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。</p>
<p>并行：</p>
<ul>
<li>位级并行ILP，处理器处理的字长不断增加，并行度自然增加；</li>
<li>instruction level parallelismILP：指令级并行，处理器同时处理多条指令。超标量和超长指令字是目前最基本的两类指令级并行技术；</li>
<li>DLP：数据级并行，能同时处理多条数据；SIMD</li>
<li><p>TLP：任务级并行。更多的是被称为Thread-level parallelism。TLP，线程级并行。</p>
</li>
<li><p>时间级并行，指流水线并行；</p>
</li>
<li>空间并行：包括指令并行、数据并行、线程并行；</li>
</ul>
<p>简单理解，向量a[n],b[n],c[n],那么：</p>
<ul>
<li>垂直计算模式：a[i] op b[i] = c[i]</li>
<li>水平计算模式：a[i] op a[i+1] = c[i]</li>
<li>标量计算模式： a[0] op b[0] = c[0]<br>对于多媒体的计算和科学计算，存在大量类似计算，所以说SIMD能极大提高计算性能。<br><br>比如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;N;i++)c[i]=a[i]+b[i]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样的代码就能生成SIMD指令，但是不能接受无限大的N，对不同指令集，能接受的数据长度是一定的，比如AVX指令级，能接受的长度为256字节，所以可以这样优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;N;i+=4)&#123;</span><br><span class="line">    c[i]=a[i]+b[i];</span><br><span class="line">    c[i+1]=a[i+1]+b[i+1]</span><br><span class="line">    c[i+2]=a[i+2]+b[i+2]</span><br><span class="line">    c[i+3]=a[i+3]+b[i+3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的代码，很容易生成SIMD指令，具体需要依赖编译器实现，这里的4也是一个例子，前提是数组a/b/c的数据元素乘以4为SIMD指令集能接受一次运算的长度。</p>
<p>线程级并行：是一种更高层的数据并行，是一种分时复用的思想，可以依靠OS来完成，现在的处理器，硬件也会为线程并行提供帮助，提高效率。</p>
<h5 id="1-9-3-计算机系统中的抽象"><a href="#1-9-3-计算机系统中的抽象" class="headerlink" title="1.9.3 计算机系统中的抽象"></a>1.9.3 计算机系统中的抽象</h5><p>文件是对I/O设备的抽象，虚拟内存是对主存和IO设备的抽象；指令集架构是对处理器的抽象；进程是对IO、主存、处理器【正在运行的程序】的抽象；虚拟机是对整个计算机的抽象，包括OS、处理器程序。</p>
<h3 id="第二部分-程序结构和执行"><a href="#第二部分-程序结构和执行" class="headerlink" title="第二部分 程序结构和执行"></a>第二部分 程序结构和执行</h3><h3 id="2-1-信息的表示和处理"><a href="#2-1-信息的表示和处理" class="headerlink" title="2.1 信息的表示和处理"></a>2.1 信息的表示和处理</h3><h4 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h4><p>对于跨越多字节的程序对象，需要建立两个规则：<strong>这个对象地址是什么，以及在内存中如何排列这些字节。</strong> 几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。排列一个对象的字节有两个通用规则：</p>
<ul>
<li>某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，最低有效字节在最前面的方式，称为小端法</li>
<li>最高有效字节在最前面的方式，称为大端法。</li>
</ul>
<p>最前面指低地址位置。大多数Intel兼容机只用小端模式，另一方面IBM、Oracle的大多数机器则是按大端模式操作。</p>
<h3 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h3><p>了解如何将C程序编译成汇编语言。如何实现C语言中的控制结构，如if、while、switch语句，实现的过程包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。接着考虑在机器级如何实现像数组、结构和联合这样的数据结构。还会讨论内存访问越界、以及易受缓冲区溢出攻击问题和一些GDB调试技巧。</p>
<h4 id="3-1-机器级代码"><a href="#3-1-机器级代码" class="headerlink" title="3.1 机器级代码"></a>3.1 机器级代码</h4><p>计算机使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现细节，对于机器级编程来说，其中两种抽象很重要：</p>
<ul>
<li>指令集体系结构或指令集架构Instruction Set Architecture(ISA)来定义机器级程序的格式和行为，定义了处理器状态、指令格式，以及每条指令对状态的影响。大多数ISA将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条开始。处理器的硬件远比描述的精细复杂，并发执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的完全一致。</li>
<li>机器级程序使用的内存地址是虚拟地址，提供的内存模型和OS软件组合起来。</li>
</ul>
<p>X86-64的机器代码和原始C代码差距很大，一些通常对C语言程序员隐藏的处理器都是可见的：</p>
<ul>
<li>程序计数器PC，给出要执行的下一条指令在内存中的地址</li>
<li>整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言指针)或整数数据，有的寄存器被用来记录某些重要的程序状态，而其他寄存器用来保留临时数据，例如参数、局部变量、以及函数返回值；</li>
<li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。用来控制或数据流中的条件变化，比如if、while</li>
<li>一组向量寄存器可以存放一个或多个整数或浮点数值，为了支持向量计算，系统也提供了众多的向量寄存器</li>
</ul>
<p>机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。 程序内存包含：程序的可执行机器代码，OS需要的信息、管理过程调用和返回的运行时栈，以及用户分配的内存块(比如malloc)。OS负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。<strong>一条机器指令只执行一个非常基本的操作，如将寄存器中两个数字相加，在存储器和寄存器间传送数据，或是条件分支转移到新的指令地址。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -S hello.s</span><br></pre></td></tr></table></figure></p>
<p>将产生一个hello.s的汇编语言文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -c hello.c</span><br></pre></td></tr></table></figure></p>
<p>将生成二进制源文件。</p>
<h4 id="3-2-访问信息"><a href="#3-2-访问信息" class="headerlink" title="3.2 访问信息"></a>3.2 访问信息</h4><p>一个x86-64的中央处理单元CPU包含一组16个存储64位值得通用目的寄存器。这些寄存器用来存储整数数据和指针。</p>
<h5 id="3-2-1-操作数指示符"><a href="#3-2-1-操作数指示符" class="headerlink" title="3.2.1 操作数指示符"></a>3.2.1 操作数指示符</h5><p>大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置，源数据值可以是常数值、或寄存器、内存中读出；</p>
<ul>
<li>立即数，表示常数值，通常用 $后跟一个标准C表示的整数</li>
<li>寄存器。表示某个寄存器的内容，比如16个寄存器低1b、2b、4b、8b中的一个作为一个操作数，形如<code>$R[r_{a}]$</code>，<code>$r_a$</code>表示任意寄存器a，<code>$R[r_{a}]$</code>表示其值；</li>
<li>内存引用。根据计算出来的地址访问某个内存为止，因为将内存看成一个很大的字节数组，用符号<code>$M_b[Addr]$</code>表示对存储在内存中从地址Addr开始的b字节值得引用；</li>
</ul>
<p>有不同寻址模式，允许不同内存引用，<code>$Imm(r_b,r_i,s)$</code>表示最常用形式，立即数偏移<code>$Imm$</code>，基址寄存器<code>$r_b$</code>，变址寄存器<code>$r_i$</code>，比例因子s，s必须是1、2、4或者8.基址和变址寄存器必须是64位寄存器。有效地址：<code>$Imm+R[r_b]+R[r_i]*s$</code>。引用数组元素会用这种通用形式。</p>
<h4 id="3-2-2-数据传送指令"><a href="#3-2-2-数据传送指令" class="headerlink" title="3.2.2 数据传送指令"></a>3.2.2 数据传送指令</h4><ul>
<li>mov 将数据从一个位置复制到另一个位置的指令；</li>
<li>ret 函数返回指令</li>
</ul>
<p>C语言中所谓的指针其实就是地址，间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器，其次局部变量通常保存在寄存器中，而不是内存中，访问寄存器要比内存快的多；</p>
<h4 id="3-2-3-算术和逻辑操作"><a href="#3-2-3-算术和逻辑操作" class="headerlink" title="3.2.3 算术和逻辑操作"></a>3.2.3 算术和逻辑操作</h4><ul>
<li>leap实际是mvoq指令的变形，指令形式是从内存读数据到寄存器，实际上根本没有引用内存。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leap 7(%rdx,%rdx,4),%rax 设置寄存器%rax = 5x+7</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>leaq指令能执行加法和有限形式的乘法。<br>存储乘积需要两个movq指令，一个存储低8个字节，一个存储高8字节；出发中，需要将商和余数存储在不同寄存器中。</p>
<h4 id="3-3-控制"><a href="#3-3-控制" class="headerlink" title="3.3 控制"></a>3.3 控制</h4><h5 id="3-3-1-条件码"><a href="#3-3-1-条件码" class="headerlink" title="3.3.1 条件码"></a>3.3.1 条件码</h5><p>除了整数寄存器，CPU维护着一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。</p>
<ul>
<li>CF:进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出,(unsigned)t&lt;(unsigned)a；</li>
<li>ZF：零标志。最近的操作得出的结果为0,(t==0)</li>
<li>SF：符号标志。最近的操作得到的结果为负数,(t&lt;0)；</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出-正溢出、负溢出,(a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0!=a&lt;0)</li>
</ul>
<h5 id="3-3-2-访问条件码"><a href="#3-3-2-访问条件码" class="headerlink" title="3.3.2 访问条件码"></a>3.3.2 访问条件码</h5><p>条件码通常不会直接读取，常用的使用方法三种：</p>
<ul>
<li>根据条件码的某种组合，讲一个字节设置为0或1，</li>
<li>可以条件跳转到程序某个其他地方；</li>
<li>可以有条件传送数据</li>
</ul>
<h5 id="3-3-3-访问条件码"><a href="#3-3-3-访问条件码" class="headerlink" title="3.3.3 访问条件码"></a>3.3.3 访问条件码</h5><p>jmp指令会导致执行切换到一个全新的位置，jmp是无条件跳转，可以是直接跳转，即目标是作为指令的一部分编码，也可以是间接跳转，目标是从寄存器或内存位置读出；</p>
<h5 id="3-3-4-用条件传送来实现条件分支"><a href="#3-3-4-用条件传送来实现条件分支" class="headerlink" title="3.3.4 用条件传送来实现条件分支"></a>3.3.4 用条件传送来实现条件分支</h5><p>实现条件操作的传统方法是通过使用控制的条件转移，这种机制简单通用，但是在现代处理器上可能非常低效。<strong>一种替代的策略是使用数据的条件转移，这种方法计算第一个条件操作的两种结果，然后根绝条件是否满足选取其中一个。如果策略可行，可以用一条简单的条件传送指令来实现，更符合现代处理器性能特征。</strong></p>
<h5 id="为什么基于数据传送的代码比基于条件控制转移的代码性能好"><a href="#为什么基于数据传送的代码比基于条件控制转移的代码性能好" class="headerlink" title="为什么基于数据传送的代码比基于条件控制转移的代码性能好"></a>为什么基于数据传送的代码比基于条件控制转移的代码性能好</h5><p>处理器通过使用流水线pipeline来获得高性能，流水线中一条指令的处理要经过一系列阶段，每个阶段执行所需操作的一小部分（从内存取指令 -&gt; 确定指令类型-&gt;从内存读数据-&gt;执行算术运算-&gt;向内存写数据-&gt;更新程序计数器）。<strong>这种方法通过重叠连续指令的步骤来获得高性能，如在取一条指令的同时，执行前面一条指令的算术运算。所以要事先确定要执行的指令序列，这样才能保证流水线充满待执行的指令。</strong></p>
<p>机器遇到条件跳转（分支）时，只有当分支条件求值完成后，才能决定分支往哪走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否执行，只要猜测可靠（<strong>现代微处理器试图达到90%以上成功率</strong>），指令流水线就会冲满着指令。另一方面错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始从正确位置处起始的指令去填充流水线。<strong>错误预测会招致很严重的惩罚，浪费大约15-30个周期，导致程序性鞥严重下降。</strong></p>
<p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long absdiff(long x,long y)</span><br><span class="line">&#123;</span><br><span class="line">    long result;</span><br><span class="line">    if(x&lt;y)</span><br><span class="line">        result = y -x;</span><br><span class="line">    else</span><br><span class="line">        result = x -y;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于数据的条件转移<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long comvdiff(long x,long y)</span><br><span class="line">&#123;</span><br><span class="line">    long rval = y -x;</span><br><span class="line">    long eval = x -y;</span><br><span class="line">    //below line requires single instuction</span><br><span class="line">    if(ntext) rval = eval</span><br><span class="line">    return rval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个典型应用中，<code>$x&lt;y$</code>的结果非常不可预测，使用最精密的分支预测硬件也只有50%概率猜对。两个代码序列中计算执行都只需要一个时钟周期，分支预测错误处罚主导着函数性能，对于包含条件跳转的x86-64代码，<strong>分支行为容易预测时，每次调用函数需要大约8个时钟周期；分支行为是随机的时候，每次调用17.5个时钟周期，推断出分支预测错误的处罚大约是19个时钟周期，意味着函数需要的时间范围大约在8-27个周期间，依赖于分支预测是否正确。</strong></p>
<h6 id="如何确定分支预测错误处罚"><a href="#如何确定分支预测错误处罚" class="headerlink" title="如何确定分支预测错误处罚"></a>如何确定分支预测错误处罚</h6><p>假设预测错误概率为p，没有预测错误的时间为<code>$T_{ok}$</code>，预测错误处罚是<code>$T_{mp}$</code>，作为p的一个函数，执行代码平均时间是<code>$T_{avg}(p)=(1-p)T_{ok}+p(T_{ok}+T_{mp})=T_{ok}+pT_{mp}$</code>。<br>如果已知<code>$T_{ok}$</code>和<code>$T_{ran}$</code>(当p0.5时的平均时间)，即<code>$T_{ran}=T_{avg}(0.5)=T_{ok}+0.5T_{mp}$</code>，所以有<code>$T_{mp}=2(T_{ran}-T_{ok})$</code>,对于<code>$T_{ok}=8$</code>和<code>$T_{ran}=17.5$</code>，有<code>$T_{mp}=19$</code>.</p>
<p><strong>同条件跳转不同</strong>，处理器无需预测测试的结果就可以执行<strong>条件传送</strong>，处理器只是读原值，检查条件码，然后要么更新目的寄存器，要么保持不变。</p>
<p>不是所有的条件表达式都可以用条件传送来编译，比如<code>$xp ? *xp:0$</code>。使用条件传送也不总是提高代码效率，比如不同分支需要大量计算，如果对应条件不满足这些计算就白费了。编译器并不具有足够的信息来做出可靠的决定。对GCC的实验表明，只有两个表达式很容易计算如一条加法指令，才会使用条件传送。即使许多分支预测错误的开销会超过更复杂的计算，GCC还是会使用条件控制转移。</p>
<h6 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h6><p>在处理具有多种可能结果的测试时，这种语句很有用，不仅提高了C的可读性，而且通过<strong>跳转表jump table</strong>，这种数据结构使得实现更加高效；跳转表是一个数组，表项i是一个代码段的地址，当开关索引值等于i时，程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。<strong>和if-else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况数量无关，GCC根据开关情况的数量和开关情况值的稀疏成都来翻译开关语句。当开关情况数量比较多(4个以上)，并且值的范围跨度比较小，就会使用跳转表。</strong></p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>过程是软件中一种很重要的抽象，提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。要提供对过程的机器级支持，必须要处理许多不同属性，假设过程P调用Q，Q执行后返回到P，这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制。进入过程Q时，PC必须被设置为Q的起始地址，然后返回时，要把PC设置为P中调用Q后面那条指令的地址；</li>
<li>传递数据：P必须能够像Q提供一个或多个参数，Q必须能够向P返回一个值；</li>
<li>分配和释放内存：开始时Q可能需要为局部变量分配空间，返回前又必须释放这些存储空间。</li>
</ul>
<p>x86-64的过程实现包括一组特殊的指令和一些对机器资源（寄存器和内存）使用的约定规则，要尽量减少过程调用的开销，所以遵循了被认为是最低要求策略的方法。一步步构建不同机制。</p>
<h6 id="3-4-1-运行时栈"><a href="#3-4-1-运行时栈" class="headerlink" title="3.4.1 运行时栈"></a>3.4.1 运行时栈</h6><p>C语言过程调用一个关键特性：使用了栈数据结构提供后进先出的内存管理原则。当过程调用需要的存储空间超出寄存器能够存放的大小时，就会在<strong>栈上分配空间，这个部分称为过程的栈帧。</strong>P调用Q，Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间，这个空间中，可以保存寄存器的值，分配局部变量空间，为其调用过程设置参数，大多数过程的栈帧都是定长的，过程开始就分配好了，有些过程需要变长的诊。<strong>通过寄存器，过程P可以传递最多6个整数值，如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧里存储这些参数。</strong></p>
<p>为了提高空间和时间效率，x86-64过程只分配自己所需要的栈帧部分，许多过程有6个或者更少的参数，那么所有参数都可以通过寄存器传递。实际许多函数甚至不需要栈帧，当所有局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，就可以这样处理。</p>
<h6 id="3-4-2-转移控制"><a href="#3-4-2-转移控制" class="headerlink" title="3.4.2 转移控制"></a>3.4.2 转移控制</h6><p>将控制从函数P转移到函数Q，只需要简单把程序计数器PC设置为Q的代码起始位置，稍后从Q返回时候，处理器必须记录好它需要继续P的执行的位置。使用call和ret指令。</p>
<h6 id="3-4-3-数据传送"><a href="#3-4-3-数据传送" class="headerlink" title="3.4.3 数据传送"></a>3.4.3 数据传送</h6><p>当调用一个过程，除了要传递控制，还要在过程调用中把数据作为参数传递，而从过程返回还有可能包括返回一个值。大部分过程间的数据传送是通过寄存器实现的。x86-64最多传递6个整型参数，多出来的参数要存在栈上。</p>
<h6 id="3-4-4-数据传送"><a href="#3-4-4-数据传送" class="headerlink" title="3.4.4 数据传送"></a>3.4.4 数据传送</h6><p>有些情况局部数据必须放在内存中，常见情况：</p>
<ul>
<li>寄存器不足够存放所有本地数据</li>
<li>对一个局部变量使用地址运算符&amp;,因此必须能够为其产生一个地址；</li>
<li>某些局部变量是数组或结构，因此必须能通过数组或结构引用被访问到；</li>
</ul>
<p>一般来说过程通过减小栈指针在栈上分配空间，分配的结果作为栈帧一部分，标号为局部变量。</p>
<h6 id="3-4-5-寄存器中的局部存储空间"><a href="#3-4-5-寄存器中的局部存储空间" class="headerlink" title="3.4.5 寄存器中的局部存储空间"></a>3.4.5 寄存器中的局部存储空间</h6><p>寄存器是唯一被所有过程共享的资源，虽然在给定时刻只有一个过程是活动的，必须确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。</p>
<h6 id="3-4-6-递归过程"><a href="#3-4-6-递归过程" class="headerlink" title="3.4.6 递归过程"></a>3.4.6 递归过程</h6><p>每个过程调用在栈中都有自己的私有空间，因此多个未完成调用的局部变量不会相互影响，此外栈的原则很自然的提供了适当的策略，当过程被调用时分配局部存储，返回时就释放存储。</p>
<p>递归调用一个函数本身与调用其它函数一样，栈规则提供一种机制，每次函数调用都有它自己私有的状态信息(保存的返回位置和被调用者保存寄存器的值)存储空间，还可以提供局部变量的存储。</p>
<h5 id="3-5-数组分配和访问"><a href="#3-5-数组分配和访问" class="headerlink" title="3.5 数组分配和访问"></a>3.5 数组分配和访问</h5><p>c语言中的数组是一种将标量数据聚集成更大数据类型的方式。优化编译器非常善于简化数组索引所使用的地址计算。</p>
<h5 id="3-6-异质的数据结构"><a href="#3-6-异质的数据结构" class="headerlink" title="3.6 异质的数据结构"></a>3.6 异质的数据结构</h5><p>C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制，结构structure，用struct声明，将多个对象集合到一个单位中；联合union，用关键字union声明，允许集中不同的类型来引用一个对象。</p>
<ul>
<li>C语言的struct声明创建一个数据类型，将不同类型的对象聚合到一个对象中，用名字引用结构的各个组成部分，类似于数组的实现，结构所有组成部分都存放在内存中一段连续的区域内，指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。</li>
<li>联合。联合提供一种方式，可以规避C语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，语义相差比较大，用不同字段来引用相同的内存块。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct S3&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i[2];</span><br><span class="line">    double v;</span><br><span class="line">&#125;</span><br><span class="line">union U3&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i[2];</span><br><span class="line">    double v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在x86-64 linux机器上编译时，字段的偏移量、数据类型S3和U3的完整大小如下：<br>|类型|c|i|v|大小|<br>|—|—|—|—|—|<br>|S3|0|4|16|24|<br>|U3|0|0|0|8|<br>为什么S3中i的偏移量不是1，v的偏移量不是9或12；对于union U3 <strong>的指针p、p-&gt;c、p-&gt;i[0]引用的都是起始位置，一个联合的总大小等于最大字段的大小</strong>【存在数据对齐的规则】** 。在一些情况下，联合十分有用，也可能引起一些错误，绕过了C语言类型系统提供的安全措施，如果知道一个数据结构中两个不同字段的使用是互斥的，可以将这两个字段声明为联合一部分，会减小分配空间的总量。</p>
<h6 id="3-6-2-数据对齐"><a href="#3-6-2-数据对齐" class="headerlink" title="3.6.2 数据对齐"></a>3.6.2 数据对齐</h6><p>许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K(2、4、8)的倍数，这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。</p>
<h5 id="3-7-机器级程序中将控制与数据结合起来"><a href="#3-7-机器级程序中将控制与数据结合起来" class="headerlink" title="3.7 机器级程序中将控制与数据结合起来"></a>3.7 机器级程序中将控制与数据结合起来</h5><h6 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h6><p>C对于数组引用不进行任何边界检查，而且局部变量和状态信息（保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界数组元素的写操作会破坏存储在栈中的状态信息，当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现严重错误。</p>
<p>一种特别常见的状态破坏被称为缓冲区溢出，在栈中分配某个字符数组来保存某个字符串，但是字符串长度超出了为数组分配的空间。</p>
<p>缓冲区溢出一个更加致命的错误就是让程序执行本来不会执行的函数，这是一种最常见的通过计算机网络供给系统安全的方法，通常输入程序给程序一个字符串，这个字符串包含一些可执行代码的字节编码，攻击代码，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址，那么执行ret指令的效果就是跳转到攻击代码。另一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组OS函数。</p>
<h5 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h5><ul>
<li>栈随机化。为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分，产生这个指针需要知道这个字符串放置的栈地址。过去程序的栈地址很容易预测，栈地址相当固定。<strong>栈随机化的思想使得栈的位置在程序每次运行时都有变化，实现方式：程序开始时，在栈上分配一段0~n字节之间的随即大小空间，ASLR：每次运行程序不同部分(程序代码 库代码 栈 全局变量 堆数据 都会被加载到内存不同区域).</strong>也可以用蛮力克服随机化，在实际的攻击代码前插入很长一段nop指令。</li>
<li>栈破坏检测。破坏通常发生在当超越局部缓冲区的边界时。GCC正在产生代码中加入了一种栈保护者机制来检测缓冲区越界。思想是在栈帧中任何局部缓冲区与栈状态之间存储了一个特殊的金丝雀值，程序每次运行随机产生，在恢复寄存器状态、从函数返回前，程序检查这个金丝雀是否被该函数的某个操作或者函数调用的某个函数的某个操作改变了，如果是程序就异常中止。</li>
<li>限制可执行代码区域。限制哪些内存区域能够存放可执行代码。只有保存编译器产生的代码的那部分内存才需要是可执行的，其他部分只允许读和写。虚拟内存在逻辑上被分成了页，硬件支持多种形式的内存保护，能够指明用户程序和OS内核所允许的访问形式。许多系统允许控制三种访问形式，读、写、执行。有些类型的程序要求动态产生和执行代码的能力，如即时编译just-in-time为解释语言编写的程序动态产生代码，来提高性能。</li>
</ul>
<h5 id="支持边长栈帧"><a href="#支持边长栈帧" class="headerlink" title="支持边长栈帧"></a>支持边长栈帧</h5><p>为了管理边长栈帧，使用寄存器作为栈指针（基指针）。较早版本的x86代码每个函数调用都使用了栈指针，现在只有栈帧长可变的情况下才使用。</p>
<h4 id="4-处理器体系结构"><a href="#4-处理器体系结构" class="headerlink" title="4 处理器体系结构"></a>4 处理器体系结构</h4><p>一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构ISA。ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层。</p>
<h5 id="4-1-逻辑设计和硬件控制语言HCL"><a href="#4-1-逻辑设计和硬件控制语言HCL" class="headerlink" title="4.1 逻辑设计和硬件控制语言HCL"></a>4.1 逻辑设计和硬件控制语言HCL</h5><p>硬件设计中，用电子电路来对位进行运算，以及在各种存储器单元中存储位。大多数现代电路技术都使用信号线上的高电压、低电压表示不同的位值。逻辑1用高电压表示，逻辑0用0伏特左右的低电压表示。实现一个数字系统需要三个组成部分：<strong>计算对位进行操作的函数的组合、存储位的存储单元以及控制存储器单元的更新的时钟单元。</strong> HCL硬件控制语言，来描述不同处理器设计的控制逻辑。</p>
<p>现代逻辑设计：HDL是一种文本表示，看上去和编程语言类似，用来描述硬件结构而不是程序行为，常用语言有verilog、VHDL，用来表示数字电路的模拟模型。</p>
<h6 id="4-1-1-逻辑门"><a href="#4-1-1-逻辑门" class="headerlink" title="4.1.1 逻辑门"></a>4.1.1 逻辑门</h6><p>逻辑门是数字电路的基本计算单元，产生的输出等于它们输入位值的某个布尔函数。逻辑门是活动的，一旦一个门输入变化，很短时间内，输出也会相应变化。</p>
<h6 id="4-1-2-组合电路和HCL布尔表达式"><a href="#4-1-2-组合电路和HCL布尔表达式" class="headerlink" title="4.1.2 组合电路和HCL布尔表达式"></a>4.1.2 组合电路和HCL布尔表达式</h6><p>将很多的逻辑门组合成一个网就能构建计算块，称为组合电路。如何构建这些网有几个限制</p>
<ul>
<li>每个逻辑门输入必须连接到下述选项之一：1）一个系统输入2）某个存储器单元的输出3）某个逻辑门输出</li>
<li>两个或多个逻辑门的输出不能连接到一起，否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障；</li>
<li>这个电路必须是无环的。网中不能有路径经过一系列的门而形成一个回路。</li>
</ul>
<h6 id="4-1-3-字级的组合电路和HCL整数表达式"><a href="#4-1-3-字级的组合电路和HCL整数表达式" class="headerlink" title="4.1.3 字级的组合电路和HCL整数表达式"></a>4.1.3 字级的组合电路和HCL整数表达式</h6><p>通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常设计能对数据字word进行操作的电路.组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。算术/逻辑单元ALU是一种很重要的组合电路。</p>
<h6 id="4-1-3-存储器和时钟"><a href="#4-1-3-存储器和时钟" class="headerlink" title="4.1.3 存储器和时钟"></a>4.1.3 存储器和时钟</h6><p>组合电路本质上讲，不存储任何信息，只是简单响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，即有状态且在这个状态上进行计算的系统，必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性的信号，决定什么时候将新值加载到设备中。考虑两类存储设备：</p>
<ul>
<li>时钟寄存器。存储单个位或字，时钟信号控制寄存器加载输入值；</li>
<li><p>随机访问存储器，存储多个字，用地址选择该读、写哪些字。随机访问存储器包括1）处理器的虚拟内存系统；2）寄存器文件</p>
<p>说道硬件和机器级编程，“寄存器”这个词有细微的差别。硬件中寄存器直接将它的输入和输出连接到电路其他部分，机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里指寄存器ID，这些字通常都存在寄存器文件中。通常分别称为“硬件寄存器”和“程序寄存器”。</p>
<p>寄存器文件都两个读端口、一个写端口，这样一个多端口随机访问存储器允许同时进行多个读和写操作。虽然寄存器文件不是组合电路，因为它有内部存储。实现中，从寄存器文件读数据好像它是一个以地址输入、数据为输出的一个组合逻辑块。向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valW上的值就会被写入输入dstW上的寄存器ID指示的程序寄存器。</p>
</li>
</ul>
<h5 id="4-2-指令的顺序实现"><a href="#4-2-指令的顺序实现" class="headerlink" title="4.2 指令的顺序实现"></a>4.2 指令的顺序实现</h5><p>顺序处理的处理器SEQ，每个时钟周期上SEQ执行处理一条完整指令所需的所有步骤。需要很长的时钟周期，因此时钟周期频率会低到不可接受。开发SEQ的目标是提供实现最终目的的第一步，实现一个高效、流水线化的处理器。</p>
<h6 id="4-2-1-将处理组织成阶段"><a href="#4-2-1-将处理组织成阶段" class="headerlink" title="4.2.1 将处理组织成阶段"></a>4.2.1 将处理组织成阶段</h6><p>通常一条指令包括很多操作，将其组织成某个特殊的阶段序列，即使指令动作差异很大，所有指令都遵循统一序列。每一步的具体处理取决于正在执行的指令。创建这样一个框架，以便能充分利用硬件。</p>
<ul>
<li>取指fetch：从内存读取指令字节，地址为程序计数器的值。从指令抽取出两个四位部分：icode(指令代码)和ifun(指令功能).</li>
<li>译码decode：译码阶段从寄存器文件读入最多两个操作数。得到valA和valB，读入指令rA和rB字段指明的寄存器。</li>
<li>执行execute：执行阶段，算术/逻辑单元ALU要么执行指令指明的操作(根据ifun的值)，计算内存引用的有效地址，要么增加或减少栈指针。</li>
<li>访存memory：访存阶段可以将数据写入内存或者从内存读出数据；</li>
<li>写回write back：写回阶段最多可以写两个结果到寄存器文件</li>
<li>更新pc：将pc设置为下一条指令的地址</li>
</ul>
<p>处理器无限循环执行这些阶段，发生任何异常，处理器就会停止，执行halt指令或非法指令，处理器会进入异常处理模式。 </p>
<h6 id="4-2-2-SEQ的时序"><a href="#4-2-2-SEQ的时序" class="headerlink" title="4.2.2 SEQ的时序"></a>4.2.2 SEQ的时序</h6><p>一个时钟变化会引发一个经过组合逻辑的流，来执行整个指令。</p>
<p>SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器(程序计数器和条件码寄存器)、随机访问存储器(寄存器文件、指令内存和数据内存)。组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播。将随机访问存储器看成和组合逻辑一样的操作，根据地址输入产生输出字。</p>
<p>程序计数器、条件码寄存器、数据内存和寄存器文件需要通过一个时钟信号来控制，触发新值装载到寄存器以及将值写到随机访问存储器。只有在执行整数运算指令时，才会装载条件码寄存器。</p>
<p><strong>要控制处理器中活动的时序，只需要寄存器和内存的时钟控制。从不回读：处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</strong><br>比如对pushq指令实现先是将%rsp减8，再将更新后的%rsp值作为写操作的地址，这种方法同前面所说的那个原则相违背。真正的实现：实现产生出减后的栈指针值，作为信号valE，然后再用这个信号既作为寄存器写的数据，也作为内存写的地址。因此在时钟上升开始下一个周期时，处理器就可以同时执行寄存器写和内存写。</p>
<h5 id="4-3-流水线通用原理"><a href="#4-3-流水线通用原理" class="headerlink" title="4.3 流水线通用原理"></a>4.3 流水线通用原理</h5><p><strong>流水线化的一个重要特征就是提高了系统吞吐量，轻微的增加延迟。</strong></p>
<p>流水线的局限性？<br></p>
<ul>
<li>不一致的划分。比如将计算划分为三个阶段，这些阶段延迟从50ps到150ps不等，但是运行时钟的速率是由最慢的阶段的延迟限制的。通常处理器中某些硬件单元，如ALU和内存是不能划分成多个延迟较小的单元的。</li>
<li>流水线过深，收益反而下降。比如将计算分为6个阶段，流水线阶段数加倍，性能提高1.71倍，虽然将每个计算时钟时间缩短两倍，但是由于通过流水线寄存器的延迟，吞吐量没有加倍。</li>
</ul>
<p>为了提高时钟频率，现代处理器用了很深的流水线（15或更多阶段）。</p>
<h6 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h6><p>流水线化设计的目的就是每个时钟周期都发射一条新指令，每个时钟周期都有一条新指令进入执行阶段并最终完成。如果取出当前指令，确定的下一条指令是条件分支指令，则要在几个周期后，才能知道是否选择分支。猜测分支方向并根据猜测开始取指的技术成为分支预测。</p>
<h5 id="4-4-流水线冒险"><a href="#4-4-流水线冒险" class="headerlink" title="4.4 流水线冒险"></a>4.4 流水线冒险</h5><p>将流水线技术引入一个带反馈的系统，当相邻间存在相关时会导致出现问题，在完成设计前，要解决这个问题。</p>
<ul>
<li>数据相关。下条指令会用到这条指令计算出的结果</li>
<li>控制相关。一条指令要确定下一条指令的位置，例如在执行跳转。</li>
</ul>
<p>如何处理数据冒险？<br></p>
<ul>
<li>暂停stalling。暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足；</li>
<li>用转发避免数据冒险。将要写的值传到流水线寄存器作为源操作数。这种将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发(旁路)。</li>
<li>加载/使用数据冒险。有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚。可以使用暂停来处理加载/使用冒险，通过将某些指令暂停第一个周期，这种方法称为加载互锁。</li>
<li>避免控制冒险。当处理器无法根据处于取指阶段的当前指令确定下一条指令的地址时，就会出现控制冒险。控制冒险只会发生ret指令和跳转指令。</li>
</ul>
<p>异常处理：处理器中很多事情都会导致异常控制流，指令集体系结构包括三种不同内部产生的异常：1）halt指令2）有非法指令和功能码组合的指令；3）取指或数据读写试图访问一个非法地址；</p>
<p>流水线必须处理下面4种控制情况：</p>
<ul>
<li>加载/使用冒险：在一条从内存中读出一个值得指令和一条使用该值的指令之间，流水线必须暂停一个周期；</li>
<li>处理ret：流水线必须暂停直到ret指令达到写会指令；</li>
<li>预测错误的分支：在分支逻辑发现不应该选择分支前，分支目标处的几条指令已经进入流水线了，必须取消这些指令，并从跳转指令后面那条指令开始取指；</li>
<li>异常：当一条指令异常异常，想要禁止后面的指令更新程序员可见的状态，并且在异常指令到达写回阶段，停止执行；</li>
</ul>
<h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6><p>所有需要流水线控制逻辑进行特殊处理的条件，都会导致流水线不能实现每个时钟周期发射一条新指令的目标。可以通过确定往流水线出入气泡的频率，来衡量这种损失。目标是设计每个周期发射一条指令的流水线，即CPI为1.0。</p>
<p>此外还需要：</p>
<ul>
<li>多周期指令。还需要一些更复杂操作的指令，六整数乘法和除法、以及浮点运算。这些操作的典型执行时间从浮点加法的3或4个周期到整数除法的64个周期，既需要额外的硬件来执行这些计算还需要一种机制来协调这些指令的处理与流水线其他部分之间的关系。一种简单的方法就是简单的扩展执行阶段逻辑的功能，添加一些整数和浮点算术运算单元，一条指令在执行阶段逗留所需要的多个时钟周期，导致取指、译码阶段暂停，影响性能；采用独立于主流水线的特殊硬件功能来处理较为复杂的操作，可以得到更好的性能；通常有一个功能单元来执行整数乘法和除法，还有一个来执行浮点操作，浮点单元也是流水线化得，多条指令可以在主流水线和各个单元并发执行；</li>
<li>与存储系统的接口。假设取指单元和数据内存都可以在一个时钟周期内读或是写内存中任意位置。自我修改代码中，以存储器位置的虚拟地址来引用它们，要求在执行实际的读或写操作之前，要将虚拟地址翻译成物理地址，可能所需要的值位于磁盘上，会需要上百万个时钟周期才能把数据读入到处理器内存中。<strong>典型的处理器有两个第一层高速缓存，一个用于读指令，一个用于读和写数据。另一种类型的高速缓存存储器，称为后备缓冲器TLB，提供了从虚拟地址到物理地址的快速翻译。</strong> 将TLB和高速缓存结合起来使用，大多数时候确实可能在一个时钟周期内读指令并读、或写数据。</li>
<li>虽然高速缓存保存最常引用的存储器位置，但有时还会出现不命中情况，最好情况中，可以从较高层高速缓存或处理器主存找到不命中的数据，需要3~20个时钟周期，流水线简单暂停，将指令保存在取指或访存阶段，知道高速缓存能够执行读或写操作。有些情况，被引用的存储器位置实际上是存储在磁盘存储器上。硬件会产生一个缺页page fault异常信号。访问磁盘需要几百万个时钟周期，OS缺页中断需要几百个时钟周期。</li>
</ul>
<p><strong>从处理器角度来看，将用暂停来处理短时间的高速缓存不命中和用异常处理来处理长时间缺页结合起来，能够顾及到存储器访问时由于存储器层次结构引起的所有不可预测性。</strong></p>
<h4 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5 优化程序性能"></a>5 优化程序性能</h4><p>编写高效程序需要做到：</p>
<ul>
<li>选择适当的算法和数据结构</li>
<li>编写出编译器能够有效优化以转换成高效可执行代码的源代码(理解优化编译器的能力和局限性是很重要的)</li>
<li>针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行的计算。</li>
</ul>
<h5 id="5-1-优化编译器的能力和局限性"><a href="#5-1-优化编译器的能力和局限性" class="headerlink" title="5.1 优化编译器的能力和局限性"></a>5.1 优化编译器的能力和局限性</h5><p>现代编译器用复杂精细的算法来确定一个程序中计算的是什么值，以及被如何使用的。<strong>利用一些机会简化表达式，在几个地方使用同一个计算，降低一个给定的计算必须被执行的次数。</strong> 最简单的控制就是指定优化级别，以命令行选项”-Og”调用gcc，”-O1”、”-O2”、”-O3”使用不同级别的优化。确保优化后的程序和未优化的版本有一样的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void handle1(long *xp,long *yp)</span><br><span class="line">&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line">void handle2(long *xp,long *yp)</span><br><span class="line">&#123;</span><br><span class="line">    *xp += 2* *yp</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个过程似乎有相同的行为，将存储在由指针yp指示的位置处的值两次加到指针xp指示的位置处的值。handle2更加高效，3次内存引用(读<code>*xp</code> 读<code>*yp</code> 写<code>*xp</code>),而handle1需要6次(2次读<code>*xp</code> 2次读<code>*yp</code> 2次写<code>*xp</code>)</p>
<p>但是考虑到xp等于yp的情况，handle1会将xp的值增加4倍，而handle2增加3倍。</p>
<p>这两个指针可能指向同一个内存位置的情况称为内存别名使用，在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中同一位置。</p>
<h6 id="用内联函数替换优化函数调用"><a href="#用内联函数替换优化函数调用" class="headerlink" title="用内联函数替换优化函数调用"></a>用内联函数替换优化函数调用</h6><p>包含函数调用的代码可以用一个称为内联函数替换(inline substitution)的过程进行优化。此时将函数调用替换为函数体。例如可以通过替换掉对函数f的四次调用，展开func1的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">long func1in()&#123;</span><br><span class="line">    long t = counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    t += counter++;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">替换掉</span><br><span class="line">long func()&#123;</span><br><span class="line">    return counter++</span><br><span class="line">&#125;</span><br><span class="line">long func2()&#123;</span><br><span class="line">    return func()+func()+func()+func)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的转换既减少了函数调用的开销，也允许对展开的代码做进一步优化，比如编译器可以统一func1in中对全局变量couter更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long func1opt()&#123;</span><br><span class="line">    long t = 4*coutner + 6;</span><br><span class="line">    couter+=4</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>gcc最近版本会尝试进行这种形式的优化，要么是备用命令行选项”-finline”，要么使用优化等级-O1或更高等级。gcc只尝试在单个文件中定义的函数内联，无法应用于常见情况，即一组库函数在一个文件中被定义，却被其他文件内的函数所调用。</strong></p>
<p><strong>某些情况下，最好能阻止编译器执行内联替换。一种情况是用符号调试器如GDB来评估代码，如果一个函数已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败。另一种情况是用代码剖析的方式来评估程序性能。</strong></p>
<h5 id="5-2-表示程序性能"><a href="#5-2-表示程序性能" class="headerlink" title="5.2 表示程序性能"></a>5.2 表示程序性能</h5><p>引入度量标准每个元素的周期数(cycles per element，CPE),作为一种表示程序性能并指导改进代码的方法。CPE这种度量标准能够在更细节的级别上理解迭代程序的循环性能。如处理图像中的像素、计算矩阵乘积。</p>
<p>处理器活动的顺序是由时钟控制的，时钟提供某个频率的规律信号，通常用千兆赫兹GHz，即十亿周期每秒。循环展开，每次迭代计算多个元素，有更多好处。</p>
<h5 id="5-3-消除循环的低效率"><a href="#5-3-消除循环的低效率" class="headerlink" title="5.3 消除循环的低效率"></a>5.3 消除循环的低效率</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void lower1(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    for(i=0;i&lt;strlen(s);i++)&#123;</span><br><span class="line">        toLowerCase(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lower2(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    long len = strlen(s)</span><br><span class="line">    for(i=0;i&lt;len;i++)&#123;</span><br><span class="line">        toLowerCase(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在字符串很长的情况下，方法2的性能是方法1的50w倍。</p>
<h5 id="5-4-减少过程调用"><a href="#5-4-减少过程调用" class="headerlink" title="5.4 减少过程调用"></a>5.4 减少过程调用</h5><p>过程调用会带来开销，妨碍大多数形式的程序优化。比如循环中，每次都会调用get_vec_element来获取下一个向量元素，对每个向量引用，这个函数要把向量索引i与循环边界作比较，很明显很低效。将其改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void combine3(vec_ptr v,data_t *dest)&#123;</span><br><span class="line">    long i;</span><br><span class="line">    long length=get_vec_start(v);</span><br><span class="line">    *dest=IDENT;</span><br><span class="line">    for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">        *dest=*dest op data[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>性能没有明显提升，整数求和性能还略有下降，显然内循环中其他操作形成了瓶颈，限制性能超过调用get_vec_element。为什么反复的边界检查反而不会让性能更差。</p>
<h5 id="5-5-消除不必要的内存引用"><a href="#5-5-消除不必要的内存引用" class="headerlink" title="5.5 消除不必要的内存引用"></a>5.5 消除不必要的内存引用</h5><p>在combine3的代码块中，指针dest的地址存放在寄存器中，将低i个数据元素的指针保存在寄存器中，每次迭代这个指针加8.循环终止操作通过比较这个指针与保存在寄存器中的数值来判断。<strong>每次迭代，累积变量的数值都要从内存读出再写入到内存。这样的读写很浪费，每次迭代开始开始时要从内存读出再写到内存。因为每次迭代开始时从dest读出的值就是上次迭代最后写入的值。</strong></p>
<p>可以消除这种不必要的内存读写，按照下面方式重写代码，引入一个临时变量acc，在循环中用来累计计算出来的值。循环完才存放在dest中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void combine4(vec_ptr v,data_t *dest)&#123;</span><br><span class="line">    long i;</span><br><span class="line">    long length =vec_length(v);</span><br><span class="line">    data_t *data = get_vect_start(v);</span><br><span class="line">    data_t acc=IDENT;</span><br><span class="line">    for(i=0;i&lt;length;i++)&#123;</span><br><span class="line">        acc=acc op data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest=acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么编译器不会自动将combine3优化为combine4那种呢，因为可能存在内存别名这种情况。</p>
<h5 id="5-6-理解现代处理器"><a href="#5-6-理解现代处理器" class="headerlink" title="5.6 理解现代处理器"></a>5.6 理解现代处理器</h5><p>当一系列操作必须按照严格顺序执行时，会遇到延迟界限latency bound。还有吞吐量界限。</p>
<h5 id="5-6-1-整体操作"><a href="#5-6-1-整体操作" class="headerlink" title="5.6.1 整体操作"></a>5.6.1 整体操作</h5><p>超标量CPU架构是指在一颗处理器内核实行了指令级并行的一类并行运算，每个时钟周期执行多个操作，而且是乱序的，指令的执行顺序不一定与它们在机器级程序中的顺序一致，在相同的CPU主频下实现更高的CPU吞吐率。</p>
<p>整个设计有两个主要部分：指令控制单元ICU和执行单元EU。前者负责从内存读出指令序列，并根据这些指令序列生成一组针对数据的基本操作；后者执行这些操作。</p>
<p><strong>乱序处理器需要更大、更复杂的硬件，但是能更好的达到更高的指令级并行度。</strong></p>
<p>ICU从高速缓存读取指令，指令高速缓存是一个特殊的高速存储器，包含最近访问的指令。通常ICU会在当前正在执行的指令很早之前取指，这样才有足够时间对指令译码，并把操作发给EU。当程序遇到分支，处理器采用一种分支预测branch prediction的技术，处理器会猜测是否选择分支，同时还预测分支的目的地址，使用投机执行speculative execution技术。</p>
<p>指令译码接收实际的程序指令，将其转换成一组基本操作(微操作)，每个这样的操作都完成某个简单的计算任务(两个数相加，从内存读数据或是想内存写数据)。EU接收来自取指单元的操作，每个时钟周期会接收多个操作。这些操作会被分派到一组功能单元中，会执行实际的操作，这些功能单元专门用来处理不同类型的操作。</p>
<p>读写内存由加载和存储单元实现的，这个单元有一个加法器来完成地址计算。类似存储单元处理器写数据到内存的操作。加载和存储单元通过数据高速缓存data cache来访问内存，数据高速缓存是一个高速存储器，存放着最近访问的数据值。</p>
<h5 id="5-7-循环展开"><a href="#5-7-循环展开" class="headerlink" title="5.7 循环展开"></a>5.7 循环展开</h5><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量。减少了操作数量，如循环索引计算和条件分支；第二提供了一些方法，进一步变化代码，减少整个计算中关键路径上操作数量。</p>
<h5 id="5-8-提高并行性"><a href="#5-8-提高并行性" class="headerlink" title="5.8 提高并行性"></a>5.8 提高并行性</h5><p>程序的性能是受运算单元的延迟限制的，执行加法和乘法的功能单元是完全流水线化的，每个时钟周期开始一个新操作，并且有些操作可以被多个功能单元执行。<strong>硬件具有以更高速率执行乘法和加法的潜力，但是代码不能利用这种能力，即使是使用循环展开也不能。</strong></p>
<h5 id="5-9-1-多个累积变量"><a href="#5-9-1-多个累积变量" class="headerlink" title="5.9.1 多个累积变量"></a>5.9.1 多个累积变量</h5><p>对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。例如：<br><code>$P_n$</code>表示元素<code>$a_0,a_1,...,a_{n-1}$</code>的乘积:<code>$P_n=\prod_{i=0}^{n-1}a_i$</code>假设n为偶数，还可以将其写为<code>$P_n=PE_n*PO_n$</code>，这里<code>$PE_n$</code>是索引值为偶数的元素的积，<code>$PO_n$</code>是奇数的元素的乘积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;limit;i+=2)&#123;</span><br><span class="line">    acc0=acco op data[i];</span><br><span class="line">    acc1=acc1 op data[i+1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既使用了两次循环展开，也使用了两路并行，将其称为2x2循环展开。可以将多个累积变量变换归纳为展开k次，以及并行累积k个值，得到kxk循环展开。</p>
<h5 id="5-9-2-重新结合变换"><a href="#5-9-2-重新结合变换" class="headerlink" title="5.9.2 重新结合变换"></a>5.9.2 重新结合变换</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acc = (acc op data[i]) op data[i+1];</span><br><span class="line">acc = acc op (data[i] op data[i+1])</span><br></pre></td></tr></table></figure>
<p>下面这条更加高效，在执行重新结合变换时，又一次改变向量元素合并顺序，但是浮点数可能会出问题。总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好的利用功能单元的流水线能力获得更好的性能，大多数编译器不会尝试对浮点运算做重新结合，因为这些运算不保证是可结合的。<strong>每次迭代的第一个乘法都不需要等待前一次迭代的累计值就可以执行，最小可能的CPE减少了2倍。</strong></p>
<h6 id="用向量指令达到更高的并行度"><a href="#用向量指令达到更高的并行度" class="headerlink" title="用向量指令达到更高的并行度"></a>用向量指令达到更高的并行度</h6><p>intel99年引入SSE指令(streaming SIMD Extensions)流SIMD扩展。SSE功能经历几代，最新的版本为高级向量扩展advanced vector extension或AVX。SIMD执行模型是用单条指令对整个向量数据进行操作。这些向量保存在一组特殊的向量寄存器中，目前AVX向量寄存器长为32字节，因此每一个都可以存放8个32位数或4个64位数，AVX可以并行执行8组数值或4组数值的加法或乘法。</p>
<h5 id="5-10-优化合并代码的结果小结"><a href="#5-10-优化合并代码的结果小结" class="headerlink" title="5.10 优化合并代码的结果小结"></a>5.10 优化合并代码的结果小结</h5><p>使用多项优化技术，CPE已经接近于0.5和1.0吞吐量界限，只受限于功能单元的容量，重写代码利用较新的SIMD指令得到了将近4倍或8倍的性能，比如单精度乘法，CPE从11.14降到了0.06，整体性能提升超过180倍。</p>
<h5 id="5-11-一些限制因素"><a href="#5-11-一些限制因素" class="headerlink" title="5.11 一些限制因素"></a>5.11 一些限制因素</h5><ul>
<li>寄存器溢出。循环并行性的好处手汇编代码描述计算能力限制，如果并行度p超过了可用寄存器数量，那么编译器会溢出，将某些值放到内存中，通常是在运行时堆栈上分配空间。</li>
<li>分支预测和预测错误处罚。分支预测错误会丢弃掉所有投机执行的结果，预测错误处罚是19个时钟周期。不要过分关心可预测分支；写适合用条件传送实现的代码。程序中许多测试是完全不可预测的，依赖数据的任意特性，例如一个数是负数还是正数，对于这些测试，分支预测逻辑会处理的很糟糕。如果编译器能产生使用条件数据传送而不是条件控制转移，可以极大提高程序性能。</li>
</ul>
<h5 id="5-12-理解内存性能"><a href="#5-12-理解内存性能" class="headerlink" title="5.12 理解内存性能"></a>5.12 理解内存性能</h5><h5 id="5-12-1-加载的性能"><a href="#5-12-1-加载的性能" class="headerlink" title="5.12.1 加载的性能"></a>5.12.1 加载的性能</h5><p>一个包含加载操作的程序性能既依赖于流水线能力，也依赖于加载单元的延迟。<strong>除了使用SIMD操作时以外，对任何数据类型组合和合并操作来说，CPE没有到过0.5以下。一个制约示例的CPE因素是，对于每个被计算的元素，所有示例都需要从内存读一个值，所以CPE不可能小于0.5。对于每个被计算的元素必须加载k个值的应用，不可能获得低于k/2的CPE。</strong></p>
<h5 id="5-12-2-存储的性能"><a href="#5-12-2-存储的性能" class="headerlink" title="5.12.2 存储的性能"></a>5.12.2 存储的性能</h5><p>目前分析了大部分内存引用都是加载操作数的函数，即从内存位置读到寄存器中，与之对应是存储操作，将一个寄存器值写到内存。与加载操作一样，大多情况存储操作能够在完全流水线化的模式中工作，每个周期开始一条新的存储。</p>
<p>存储操作并不影响任何寄存器值，因此一系列存储操作不会产生数据相关。只有加载操作会受存储操作结果的影响，只有加载操作从存储操作写到那个位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void write_read(long *src,long *dst,long n)&#123;</span><br><span class="line">    long cnt =n;</span><br><span class="line">    long val =0;</span><br><span class="line">    while(cnt)&#123;</span><br><span class="line">        *dst=val;</span><br><span class="line">        val=(*src)+1;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用write_read(&amp;a[0],&amp;a[0],3)参数src和dest都指向数组元素a[0]的指针，这种情况指针引用<em>src每次加载都会得到指针引用</em>dest的前次执行存储的值。这种现象就是写/读相关，一个内存读的结果依赖最近的内存写。</p>
<p>会发现这种方法比调用write_read(&amp;a[0],&amp;a[1],3)慢6个时钟周期。</p>
<p>存储单元包含一个存储缓冲区，包含已经被发射到存储单元而又还没有完成的存储操作的地址和数据，<strong>包括更新数据高速缓存。提供这样一个缓冲区，使得一系列存储操作不必等待每个操作都更新高速缓存就能执行。当一个加载操作发生，必须检查存储缓冲区中的条目，看有没有地址匹配</strong>。如果有地址匹配，就取出相应的数据条目作为加载操作结果。<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/95E079DB5923452283675415CA1A9691/29061" alt="image"></p>
<h5 id="5-13-性能提高技术"><a href="#5-13-性能提高技术" class="headerlink" title="5.13 性能提高技术"></a>5.13 性能提高技术</h5><ul>
<li>高级设计。为问题选择合适的算法和数据结构，避免那些会渐进产生糟糕性能的算法或编码技术；</li>
<li>基本编码原则。消除连续函数调用：将计算移到循环外；消除不必要内存引用：引入临时变量保存中间结果，只有在最后的值计算出来，才将结果存放到数组或全局变量中；</li>
<li>低级优化。结构化代码利用硬件性能。展开循环，降低开销，使进一步优化成为可能；通过使用多个累积变量、重新结合等技术提供指令级并行；用功能性风格重写条件操作，使得编译采用条件数据传送；</li>
</ul>
<h5 id="5-14-确认和消除性能瓶颈"><a href="#5-14-确认和消除性能瓶颈" class="headerlink" title="5.14 确认和消除性能瓶颈"></a>5.14 确认和消除性能瓶颈</h5><h5 id="5-14-1-程序剖析"><a href="#5-14-1-程序剖析" class="headerlink" title="5.14.1 程序剖析"></a>5.14.1 程序剖析</h5><p>unix系统提供一个剖析程序GPROF，产生两种形式信息，确定程序每个函数花费多少CPU时间，计算每个函数调用次数。</p>
<p>GPROF值得注意的几个点：</p>
<ul>
<li>计时不是很准确。计时基于一个简单的间隔计数机制，编译过的程序为每个函数维护一个计数器。</li>
<li>假设没有执行内联替换，则调用信息相当可靠；</li>
<li>默认情况，不会显示对库函数的计时，相反库函数的时间都被计算到调用它们的函数时间中；</li>
</ul>
<h4 id="6、存储器层次结构"><a href="#6、存储器层次结构" class="headerlink" title="6、存储器层次结构"></a>6、存储器层次结构</h4><p>访问CPU寄存器中的数据，在0个周期内就能访问；存储在高速缓存中，需要4-75个周期；存储在主存中，需要上百个周期；存储在磁盘上，需要几千万个周期。围绕着计算机程序<strong>局部性</strong>进行讨论。基本存储技术-SRAM存储器、DRAM存储器、ROM存储器以及旋转和固态的硬盘，如何被组织成层次结构。高速缓存存储器，作为CPU和主存之间的缓存区域，对应用程序性能影响最大。一种描绘某台机器上存储器层次结构的性能的有趣方法：<strong>存储器山</strong>，展示出读访问时间是局部性的一个函数。</p>
<h5 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h5><h5 id="6-1-1-随机访问存储器"><a href="#6-1-1-随机访问存储器" class="headerlink" title="6.1.1 随机访问存储器"></a>6.1.1 随机访问存储器</h5><p>随机访问存储器RAM分为两类，静态、动态。静态RAM(SRAM)比DRAM快，更贵，SRAM用作高速缓存存储器，既可以在cpu芯片上，也在芯片外。DRAM用来作为主存以及图形系统的帧缓冲区。SRAM只要保持通电，里面储存的数据就可以恒常保持，DRAM存储的数据需要周期性更新。<br>内存模块：DRAM封装在内存模块中，插到主板的扩展槽上。通过将多个内存模块连接到内存控制器，能够聚合成主存。</p>
<h6 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h6><p>断电DRAM和SRAM会丢失信息，非易失性存储器断电后仍能保持信息。ROM(read-only memory)可以读写，但是整体上都被称为只读存储器，以它们能够被重变成(写)的次数和它们进行重变成所用的机制来区分的。</p>
<h6 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h6><p>数据流通过称为总线bus的共享电子电路在处理器和DRAM主存之间传递。每次CPU和主存间的数据传递都是通过一系列步骤完成，这些步骤称为<strong>总线事务</strong>。读事务read transaction从主存传送数据到CPU，写事务write transaction从CPU传送数据到主存。</p>
<p>总线是一组并行的导线，能携带地址、数据和控制信号，取决于总线设计，数据和地址信号可以共享同一组导线，也可以使用不同的导线。</p>
<p>同时两个以上设备也能共享同一总线，控制线携带的信号会同步事务，并标识当前正在被执行的事务的类型，并标识出当前正在被执行的事务类型。如当前关注的这个事务是到主存的么，还是到磁盘控制器这样的I/O设备，这个事务是读还是写，总线上是地址还是数据。</p>
<p>读事务：1）CPU将地址A放到系统总线上，I/O桥将信号传递到内存总线。I/O桥将信号传递到内存总线；2）主存拿到内存总线信号，从内存读取地址，从DRAM取出数字，将数据写到内存总线，IO桥将内存总线信号翻译成系统总线信号，然后沿着系统总线传递3）cpu拿到总线数据，复制到寄存器</p>
<h6 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h6><p>从磁盘访问数据是毫秒级，比DRAM慢10万倍，比SRAM慢100万倍。磁盘也成为旋转磁盘，使之区别与基于闪存的固定硬件SSD(没有移动部分)。</p>
<p>CPU使用一种称为内存映射I/O的技术向I/O设备发射命令，在使用内存映射I/O系统中，地址空间中有一块地址是为与I/O设备通信保留的。</p>
<p>CPU发出请求后，在磁盘执行读的时候，通常还会做其他事情。设备可以自己执行读或写总线事务不需要CPU干涉过程，称为直接内存访问DMA。DMA传送完成后，磁盘扇区的内容被安全存储在主存中，磁盘控制器通过给CPU发送一个中断信号来通知CPU。</p>
<h6 id="固定硬盘"><a href="#固定硬盘" class="headerlink" title="固定硬盘"></a>固定硬盘</h6><p>固态硬盘是一种基于闪存的存储技术，读SSD比写要快，随机读和写的性能差别是由底层闪存基本属性决定的。随机写很慢的原因：</p>
<ul>
<li>擦除块需要相对较长时间，1ms级的，比访问页高一个数量级。</li>
<li>写操作试图修改一个包含已经有数据的页p，那么这个块中所有带有用数据的页都必须被复制到一个新块，然后才能进行对页p的写。</li>
</ul>
<p>SSD优点：由半导体存储器构成，没有移动部件，因而随机访问时间比旋转磁盘块，能耗低。缺点：反复写之后，闪存块会磨损。</p>
<p>21世纪初计算机制造商遇上能量墙power wall，无法迅速增加cpu频率，否则芯片功耗太大，解决方法用多个小处理器核取代单个大处理器。每个完整处理器能够独立、与其他核并行执行程序。这种多核方法部分有效，因为一个处理器功耗正比于<code>$P=fCv^2$</code>，f是时钟频率，C是电容，v是电压。计算机越来越快，不是因为时钟频率增加，而是因为每个处理器核数增加。</p>
<h6 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h6><p>局部性包括时间局部性和空间局部性。硬件层局部性原理允许计算机设计者通过引入称为高速缓存存储器的小而快的存储器来保存最近被引用的指令和数据项，从而提高对主存访问速度。</p>
<h6 id="6-2-1-对程序数据引用的局部性"><a href="#6-2-1-对程序数据引用的局部性" class="headerlink" title="6.2.1 对程序数据引用的局部性"></a>6.2.1 对程序数据引用的局部性</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sumvec(int v[N])&#123;</span><br><span class="line">   int i,sum = 0;</span><br><span class="line">   for(i=0;i&lt;N;i++)&#123;</span><br><span class="line">       sum+=v[i];</span><br><span class="line">   &#125;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum每次循环迭代中被引用一次，sum有很好局部性，因为sum是标量，没有空间局部性。v有很好空间局部性，没有好的时间局部性。</p>
<h6 id="6-2-2-取指令的局部性"><a href="#6-2-2-取指令的局部性" class="headerlink" title="6.2.2 取指令的局部性"></a>6.2.2 取指令的局部性</h6><p>程序指令存放在内存中，CPU必须取出这些指令。for循环体里的指令按连续的内存顺序执行，具有良好空间局部性，循环体会被执行多次，具有很好时间局部性。</p>
<p>代码区别于程序数据一个重要属性是运行时不能被修改，程序正在执行时，cpu只从内存中读出指令，cpu很少重写这些指令。</p>
<p>局部性原则：</p>
<ul>
<li>重复引用相同变量的程序有良好的时间局部性；</li>
<li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好；</li>
<li>对于取指令，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多局部性越好；</li>
</ul>
<h6 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h6><h6 id="6-3-1-存储器层次结构中的缓存"><a href="#6-3-1-存储器层次结构中的缓存" class="headerlink" title="6.3.1 存储器层次结构中的缓存"></a>6.3.1 存储器层次结构中的缓存</h6><p>高速缓存cache是一个快速存储设备，作为存储在更大更慢的设备中的数据对象缓冲区域。存储器中心思想：<strong>对于每个k，位于k层的更快更小的存储设备作为位于k+1层更大更慢的存储设备的缓存。</strong> 数据总是以块大小为传送单元在k层和第k+1层来回复制。L1和L0传送通常使用1个字大小的块，L2和L1之间几十字节。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存什么</th>
<th>缓存在何处</th>
<th>延迟</th>
<th>由谁管理</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td>4字节或8字节</td>
<td>芯片cpu寄存器</td>
<td>0</td>
<td>编译器</td>
</tr>
<tr>
<td>TLB</td>
<td>地址翻译</td>
<td>芯片上TLB</td>
<td>0</td>
<td>硬件MMU</td>
</tr>
<tr>
<td>L1高速缓存</td>
<td>64字节块</td>
<td>芯片上L1高速缓存</td>
<td>4</td>
<td>硬件</td>
</tr>
<tr>
<td>L2高速缓存</td>
<td>64字节块</td>
<td>芯片上L1高速缓存</td>
<td>10</td>
<td>硬件</td>
</tr>
<tr>
<td>L3高速缓存</td>
<td>64字节块</td>
<td>芯片上L1高速缓存</td>
<td>50</td>
<td>硬件</td>
</tr>
<tr>
<td>虚拟内存</td>
<td>4KB页</td>
<td>主存</td>
<td>200</td>
<td>硬件+OS</td>
</tr>
<tr>
<td>缓冲区缓存</td>
<td>部分文件</td>
<td>主存</td>
<td>200</td>
<td>OS</td>
</tr>
<tr>
<td>磁盘缓存</td>
<td>磁盘扇区</td>
<td>磁盘控制器</td>
<td>10 0000</td>
<td>控制器固件</td>
</tr>
<tr>
<td>网络缓存</td>
<td>部分文件</td>
<td>本地磁盘</td>
<td>1000 0000</td>
<td>NFS客户</td>
</tr>
</tbody>
</table>
<h6 id="6-4-1-通用高速缓存存储器结构"><a href="#6-4-1-通用高速缓存存储器结构" class="headerlink" title="6.4.1 通用高速缓存存储器结构"></a>6.4.1 通用高速缓存存储器结构</h6><p>主存由一个个字块组成，每个字块包含N个字，主存的地址包含两部分，一部分用来寻找某个字块，另一部分用来寻找该字块中的字或字节，主存地址高m位表示主存块地址，低b位表示其块内的字或字节,<code>$2^m=M$</code>表示主存总块数，主存向cache迁移数据以line size为单位替换。cache容量远小于主存，不能一一对应，每个存储器地址有m位，形成<code>$M=2^m$</code>个不同的地址，这样一个机器高速缓存被组织成一个有<code>$S=2^s$</code>个高速缓存组,每个组包含E个高速缓存航cache line，每行由一个<code>$B=2^b$</code>字节的数据块组成，一个有效位指明这行是否包含有意义的信息，还有t=m-b-s个标记位，唯一标识存储在这个高速缓存行中的块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址： t位   s位     b位</span><br><span class="line">      标记  组索引  块偏移</span><br></pre></td></tr></table></figure></p>
<p>高速缓存(S,E,B,m)，每个组包含一个或多行，每行包含一个有效位，一些标记位，以及一个数据块。高速缓存将m个地址划分成了t个标记位，s个组索引和b个块偏移。</p>
<h6 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h6><p>根据每个组的高速缓存行数E，高速缓存被分为不同类。每个组只有一行E=1被称为直接映射高速缓存direct-mapped cache，这是最容易实现和理解的。缓存匹配分三步：1）组选择；2）行匹配；3）字抽取</p>
<ul>
<li>直接映射高速缓存中的组选择，高速缓存从w的地址中间抽取s个组索引位，对应于一个组号的无符号整数。如果把高速缓存看成一个关于组的一维数组，那么这些组索引就是一个到这个数组的索引；</li>
<li>直接映射高速缓存中的行匹配；已经选择了某个组i，假如高速缓存中的标记位与地址中的标记位匹配，则命中</li>
<li>直接映射cache中的字选择，知道w在这个块某个地方，最后一步确定所需要的字在块中是从哪里开始的。块偏移提供了所需要的字第一个字节的偏移。cache看成一个行的数组，块看成一个字节的数组，字节偏移就是到这个数组的一个索引。</li>
<li>直接映射cache不命中时的行替换。如果缓存不命中，需要从存储器下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。</li>
<li>运行中的直接映射高速缓存。硬件要在几纳秒内完成。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组号 [有效位 标记位 块0 块1 ...]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为什么用中间的位来做索引？<br><br>如果高位用作索引，那么一些连续内存块就会映射到相同的高速缓存块，导致对局部性支持的不够好。</p>
<h6 id="6-4-2-直接映射"><a href="#6-4-2-直接映射" class="headerlink" title="6.4.2 直接映射"></a>6.4.2 直接映射</h6><p>E=1的情况就是全相连映射，假如cache有8行即8块，主存256行，<code>$i=j mod c$</code>，i为cache块号，j为主存块号，C为cache块号。</p>
<ul>
<li>优点：实现简单，只需要利用主存地址的某些位直接判断，即可确定所需字块是否在cache中；</li>
<li>缺点：1）不够灵活，每个主存块只能固定的对应某个cache块，即使cache内还空着许多位置不能占用，不能充分利用；  2）冲突率高。某个块频繁进行交换。</li>
</ul>
<p>应用场合：适合大容量cache。</p>
<h6 id="6-4-2-全相连映射"><a href="#6-4-2-全相连映射" class="headerlink" title="6.4.2 全相连映射"></a>6.4.2 全相连映射</h6><p>全相连映射允许主存每个字块映射到cache任何一块的位置上。比如主存256个内存块，cache需要8位<code>$2^8=256$</code>来作为标记位。因为直接映射只需要识别组号，只需要5位作为标记位，主存256是cache的32倍，<code>$2^5=32$</code>.</p>
<ul>
<li>优点：1）全相连映射允许主存每一字块映射到cache任何一字块，cache命中率可以提高；2）减少了块的冲突率，提高了cache利用率；</li>
<li>缺点：tag位增加了，访问cache时主存字块标记需要和cache的全部标记进行比较，才能判断所访问的主存地址内容是否在cache内，这种比较通常采用按内容寻址的相连存储器来完成。适用于小容量的cache。</li>
</ul>
<p>全相连高速缓存只适合做小的高速缓存，例如虚拟内存系统中TLB。</p>
<h6 id="6-4-3-组组相连映射"><a href="#6-4-3-组组相连映射" class="headerlink" title="6.4.3 组组相连映射"></a>6.4.3 组组相连映射</h6><p>是对直接映射和全相连映射的一种折中，假设cache分为Q组，每组R块，<code>$i=j mod Q$</code>,i是cache组号，j为主存块号，Q为cache组数，将主存第j块内容复制到cache第i组，至于是第i组哪一块，可以随意放。当cache有4组，主存有256块，256/4=64，需要6位tag区分是哪个组。</p>
<p>组相连只有一组，此时组相连就等同于全相连映射，每组只有一块，此时组相连就等同于直接映射。</p>
<h6 id="6-4-4-写"><a href="#6-4-4-写" class="headerlink" title="6.4.4 写"></a>6.4.4 写</h6><p>高速缓存读操作很简单，在cache中查找所需字w的副本，命中立刻返回cpu。写的情况更复杂一些。</p>
<ul>
<li>直写write-through【全写】。写命中时怎么更新w在层次结构中低一层中的副本，，立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。</li>
<li>写回write back。尽可能会推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。由于局部性，能显著减少总线流量，缺点是增加了复杂性，高速缓存必须为每个高速缓存行维护一个额外的修改位dirty bit，表明这个高速缓存块是否被修改过。</li>
<li>写一次法。仅仅第一次写命中时要同时写回低一层。</li>
</ul>
<h6 id="如何处理写不命中"><a href="#如何处理写不命中" class="headerlink" title="如何处理写不命中"></a>如何处理写不命中</h6><ul>
<li>写分配write-allocate。加载相应的低一层中的块到高速缓存，然后更新这个高速缓存块。写分配利用写的空间局部性，缺点是每次不命中都会导致一个块从低一层传到高速缓存。</li>
<li>非写分配。避开高速缓存，直接把这个字写到低一层，直写高速缓存通常是非写分配的，写回高速缓存通常是写分配的。</li>
</ul>
<p><strong>建议采用一个使用写回和写分配的高速缓存模型。通常由于较长的传送时间，存储器层次结构中较低层的缓存更可能使用写回；例如虚拟存储系统只使用写，由于逻辑电路密度提高，写回的高复杂性不成为阻碍；使用写回写分配试图利用局部性，展示良好的空间和时间局部性，而不试图为某个存储器系统进行优化。</strong></p>
<h6 id="6-4-5-高速缓存层次结构"><a href="#6-4-5-高速缓存层次结构" class="headerlink" title="6.4.5 高速缓存层次结构"></a>6.4.5 高速缓存层次结构</h6><p>只保存指令的高速缓存称为i-cache,只保存程序数据的高速缓存称为d-cache。两者都保存的cache称为统一高速缓存。两个独立高速缓存，能同时读一个指令字和一个数据字。i-cache通常是只读的。通常会针对不同的访问模式来优化这两个高速缓存，可以有不同的块大小、相联度和容量。使用不同的高速缓存也确保数据访问不会与指令访问形成冲突不命中，反过来代价可能会引起容量不命中增加。</p>
<p>intel core i7每个cpu有4个核，每个核有自己私有的L1 i-cache、L1 d-cache和L2统一高速缓存，所有核共享片上L3统一的高速缓存，这个层次结构一个有趣特性是所有SRAM高速缓存存储器都在CPU芯片上。</p>
<table>
<thead>
<tr>
<th>高速缓存类型</th>
<th>访问时间</th>
<th>大小</th>
<th>相联度</th>
<th>块大小B</th>
<th>组数S</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1 i-cache</td>
<td>4</td>
<td>32KB</td>
<td>8</td>
<td>64B</td>
<td>64</td>
</tr>
<tr>
<td>L1 d-cache</td>
<td>4</td>
<td>32KB</td>
<td>8</td>
<td>64B</td>
<td>64</td>
</tr>
<tr>
<td>L2统一高速缓存</td>
<td>10</td>
<td>256KB</td>
<td>8</td>
<td>64B</td>
<td>512</td>
</tr>
<tr>
<td>L3统一高速缓存</td>
<td>40-75</td>
<td>8MB</td>
<td>16</td>
<td>64B</td>
<td>8192</td>
</tr>
</tbody>
</table>
<p>几个影响因素：</p>
<ul>
<li>cache大小。较大可能会提高命中率，但是会增加命中时间。</li>
<li>块大小影响。大的块能利用程序中可能存在的空间局部性，帮助提高命中率。对于给定高速缓存大小，块越大意味高速缓存行数越少，损害时间局部性比空间局部性更好的命中率。较大块对不命中处罚也有负面影响，块越大，传送时间越长；</li>
<li>相联度影响。E是每个组中高速缓存行数。较高相联度优点是降低了cache由于冲突不命中出现抖动的可能性。较高的相联度造成较高的成本，实现起来很昂贵，很难使之速度较快。每行需要记录更多标记位，需要额外的LRU状态位和控制逻辑。增加命中时间。<strong>相联度最终成了命中时间和不命中处罚间的折中，传统上，努力争取时钟频率的高性能系统会为L1cache选择较低的相联度，而在不命中处罚比较高的较低层上使用较小的相联度。i7中l1和l2是8路组相联，L3是16路组相联</strong></li>
<li>写策略。直写cache比较容易实现，能使用独立于cache的写缓冲区write buffer，用来更新内存。读不命中开销没这么大，不会触发内存写。写回高速缓存引起的传送比较少，允许更多的内存的带宽用于执行DMA的IO设备。越往层次结构下层走，传送时间增加，减少传送数量更重要，高速缓存越往下层，越可能使用写回而不是直写。</li>
</ul>
<p>高速缓存行、组、块的区别</p>
<ul>
<li>块是固定大小信息包，在cache和主存之间来回传送</li>
<li>行是cache一个容器，存储快及其他信息(有效位 标记位)</li>
<li>组是一个或多个行的集合，直接映射cache中的组只有一行组成</li>
</ul>
<h6 id="6-5-编写高速缓存友好的代码"><a href="#6-5-编写高速缓存友好的代码" class="headerlink" title="6.5 编写高速缓存友好的代码"></a>6.5 编写高速缓存友好的代码</h6><p>局部性比较好的程序更容易有较高的命中率，更应该试着编写高速缓存友好的代码。</p>
<ul>
<li>注意力集中在核心函数的循环上；</li>
<li>尽量减小每个循环内部的缓存不命中数量。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/02/趣题2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/趣题2/" itemprop="url">数据密集型应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T16:08:20+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="题目1：有一个黑匣子，黑匣子里有一个关于-x-的多项式-p-x-。我们不知道它有多少项，但已知所有的系数都是正整数。每一次，你可以给黑匣子输入一个整数，黑匣子将返回把这个整数代入多项式后的值。那么，最少需要多少次，-我们可以得到这个多项式每项的系数呢？答案是两次。"><a href="#题目1：有一个黑匣子，黑匣子里有一个关于-x-的多项式-p-x-。我们不知道它有多少项，但已知所有的系数都是正整数。每一次，你可以给黑匣子输入一个整数，黑匣子将返回把这个整数代入多项式后的值。那么，最少需要多少次，-我们可以得到这个多项式每项的系数呢？答案是两次。" class="headerlink" title="题目1：有一个黑匣子，黑匣子里有一个关于 x 的多项式 p(x) 。我们不知道它有多少项，但已知所有的系数都是正整数。每一次，你可以给黑匣子输入一个整数，黑匣子将返回把这个整数代入多项式后的值。那么，最少需要多少次， 我们可以得到这个多项式每项的系数呢？答案是两次。"></a>题目1：有一个黑匣子，黑匣子里有一个关于 x 的多项式 p(x) 。我们不知道它有多少项，但已知所有的系数都是正整数。每一次，你可以给黑匣子输入一个整数，黑匣子将返回把这个整数代入多项式后的值。那么，最少需要多少次， 我们可以得到这个多项式每项的系数呢？答案是两次。</h5><ul>
<li>第一次，输入1，于是得到整个多项式所有系数的和，记作S；</li>
<li>第二次，输入S+1，于是黑匣子返回的是：<code>$a_n*(S+1)^n+a_{n-1}(S+1)^{n-1}+...+a_0$</code></li>
<li>要得到<code>$a_n,...,a_0$</code>，只需要把这个值换成S+1进制，依次读出每一位上的数。</li>
</ul>
<p>第一次得到S是为了保证对任意系数<code>$a_i,a_i&lt;=S$</code> </p>
<p>其实输入e，一次就够了。</p>
<h5 id="题目2：有一个n个元素的数组，除了一个元素只出现一次外，其他元素都出现两次，让你找出这个只出现一次的元素是几，要求时间复杂度为O-n-且不再开辟新的内存空间。"><a href="#题目2：有一个n个元素的数组，除了一个元素只出现一次外，其他元素都出现两次，让你找出这个只出现一次的元素是几，要求时间复杂度为O-n-且不再开辟新的内存空间。" class="headerlink" title="题目2：有一个n个元素的数组，除了一个元素只出现一次外，其他元素都出现两次，让你找出这个只出现一次的元素是几，要求时间复杂度为O(n)且不再开辟新的内存空间。"></a>题目2：有一个n个元素的数组，除了一个元素只出现一次外，其他元素都出现两次，让你找出这个只出现一次的元素是几，要求时间复杂度为O(n)且不再开辟新的内存空间。</h5><p>将所有元素做异或运算，即a[1] XOR a[2] XOR a[3] XOR…XOR a[n]，所得的结果就是那个只出现一次的数字，时间复杂度为O(n)</p>
<h5 id="升级版：有一个n个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为O-n-且再开辟的内存空间固定-与n无关"><a href="#升级版：有一个n个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为O-n-且再开辟的内存空间固定-与n无关" class="headerlink" title="升级版：有一个n个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为O(n)且再开辟的内存空间固定(与n无关)"></a>升级版：有一个n个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为O(n)且再开辟的内存空间固定(与n无关)</h5><ul>
<li>把所有结果异或，得到的就是那两个只出现一次的元素异或的结果；</li>
<li>这个结果至少某一位是不同的，找到为1的那位，以这位是1还是0为标准，将数组的n个元素分为两部分，将这一位为0的所有元素做异或运算，得出的数就是只出现一次的数中的一个；；将这一位为的所有元素做异或，得出的数就是只出现一次数中的另一个。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/02/22/数据密集型应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/数据密集型应用/" itemprop="url">数据密集型应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T22:11:38+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、数据系统基石"><a href="#1、数据系统基石" class="headerlink" title="1、数据系统基石"></a>1、数据系统基石</h3><h4 id="1-1-可靠性reliabiity-可扩展性scalability-可维护性maintainability"><a href="#1-1-可靠性reliabiity-可扩展性scalability-可维护性maintainability" class="headerlink" title="1.1 可靠性reliabiity  可扩展性scalability   可维护性maintainability"></a>1.1 可靠性reliabiity  可扩展性scalability   可维护性maintainability</h4><p>很多应用程序都是数据密集型（data-intensive）而不是计算密集型（compute-intensive）。因此CPU很少称为这类应用瓶颈，<strong>问题主要来自数据量、数据复杂性以及数据变更速度。</strong><br></p>
<ul>
<li>存储数据：database</li>
<li>记住开销昂贵的操作结果，加快读取速度 cache</li>
<li>按关键字搜索，各种方式过滤（es solar）</li>
<li>向其他进程发消息，进行异步处理（stream processing）</li>
<li>定期处理大批量数据（batch processing）</li>
</ul>
<p>数据库、消息队列、缓存表面有一些相似性（存储一段时间的数据），但他们有不同的访问模式，意味着迥异的性能特征和实现手段。</p>
<h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><ul>
<li>应用程序表现出用户期望的功能</li>
<li>允许用户犯错，允许用户以出乎意料的方式使用软件</li>
<li>在预期负载和数据量下，性能满足要求</li>
<li>系统能防止未经授权的访问和滥用</li>
<li>fault-tolerant容错性，有硬件错误、软件错误、人为错误。硬件错误包括硬盘崩溃、内存出错、断电。硬盘平均无故障时间(MTTF mean time to failure)约为10-50年。在拥有1w个磁盘的存储集群上，平均每天就有1个磁盘出故障。应对：磁盘raid，双路电源、热插拔CPU。软件错误：接受特定错误输入，导致所有应用服务器实例崩溃。比如12年6-30的闰秒，linux内核一个错误，许多应用同时挂了。失控进程占用一些共享资源，包括cpu、内存、磁盘空间、网络带宽。系统依赖的服务变慢；级联故障，一个小组件鼓掌触发另一个组件中的故障；解决方法：仔细考虑系统中假设和交互；彻底测试；进程隔离；允许进程崩溃并重启；测量、监控分析系统行为。</li>
</ul>
<h5 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h5><p>性能：</p>
<ul>
<li>增加负载参数并保持系统资源（CPU 内存 网络带宽）不变，系统性能受到什么影响</li>
<li>增加负载参数并保持性能不变，需要增加多少系统资源</li>
</ul>
<p>系统性能：吞吐量（每秒处理请求量 每秒处理数据量）、延迟、响应时间。</p>
<p>百分点通常用于服务级别目标（SLO service level objectives）和服务级别协议（SLA service level agreements），即定义服务预期性和可用性合同。SLA可能会声明：如果服务响应时间中位数小于200ms，且99.9百分位点小于1s，则认为服务工作正常。</p>
<p>实践中的百分位点<br><br>在多重调用的后端服务中，高百分位数十分重要。即使并行调用，只有一个调用变慢，整个请求就会变慢，称为尾部延迟放大效应。如果想将响应时间百分点添加到服务监视仪表板，需要有效的计算。简单的实现是在时间窗口内保存所有请求响应时间列表，每分钟对列表进行排序。<strong>大数据量情况下可能效率太低。有些算法如前向衰减、t-digest、HdrHistogram、hyperLogLog来计算百分位近似值。</strong><br></p>
<p>适应某个级别负载的架构不太可能应付10倍于此的负载。当负载发生数量级增长，需要重新考虑架构。通常有纵向扩展(scaling up)【垂直扩展vertical scaling转向更强大的机器】和横向扩展scaling out【水平扩展 horizontal scaling，将负载分布到多台小机器上】。跨多台机器分配负载也称为无共享架构share-nothing。<br><br>有些系统是弹性的，意味着可以检测到负载增加时自动增加计算资源。跨多台机器部署无状态服务非常简单，将带状态的数据系统从单节点变为分布式配置会引入许多额外复杂度。</p>
<h5 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h5><ul>
<li>可操作性(Operability)便于运维团队平稳运行</li>
<li>简单性（Simplicity）从系统中消除尽可能多的复杂度，使新工程师也能轻松理解系统</li>
<li>可演化性（evolability）也称为可扩展性extensibility </li>
</ul>
<h4 id="1-2数据模型与查询语言"><a href="#1-2数据模型与查询语言" class="headerlink" title="1.2数据模型与查询语言"></a>1.2数据模型与查询语言</h4><p>数据模型层次：</p>
<ul>
<li>观察世界：人、货、行为、资金，我们可以用对象、数据结构以及操控那些数据的API进行建模；</li>
<li>存储这些数据结构可以用json/xml，关系数据库中的表、图来存储；</li>
<li>数据库要选择如何以内存、磁盘或网络上字节表示json/xml/关系/图数据，这类表示形式使数据可能有各种方式来查询、搜索、操纵和处理。</li>
<li>更低层次上，硬件工程师可以使用电流、光脉冲、磁场或其他东西来表示字节。</li>
</ul>
<p><strong>关系模型与文档模型</strong><br></p>
<ul>
<li>关系模型：即传统的关系数据库SQL；</li>
<li>文档模型：NoSQL。</li>
<li>网络模型：是层次模型的推广，每条记录可能有多个父节点。</li>
</ul>
<p><strong>文档模型中的架构灵活性</strong><br><br>文档数据库有时称为无模式(schemaless)，具有误导性，因为读取数据的代码通常假定某种结构，更精确的是<strong>schema-on-read 数据是隐含的，只有在数据被读取时才被解释</strong>。传统关系数据库是schema-on-write写时模式。读时模式类似编程语言中动态（运行时）类型检查，而写时模式类似静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大争议一样。<br></p>
<p><strong>查询的数据局部性</strong><br><br>文档通常以单个连续字符串形式进行存储，如果应用程序经常访问整个文档，那么存储局部性会带来性能优势。局部性仅仅适用于同时需要文档绝大部分内容的情况。即使之访问其中一小部分，数据库通常需要加载整个文档，十分浪费。更新文档需要整个重写。<br><br>为了局部性而分组集合相关数据不局限于文档模型，spanner在关系数据模型中提供了同样的局部性属性，允许模式声明一个表的行应该交错嵌套在附父表内。orable中的多表索引集群表multi-table index cluster tables。bigtable中cassandra、hbase中的列族概念与管理局部性类似。随着时间推移，关系数据库和文档数据库变的越来越相似，模型相互补充。<br></p>
<p><strong>数据查询</strong></p>
<ul>
<li>SQL声明式查询语言（编程语言是命令式的）</li>
<li>MapReduce查询，用于在多台机器上批量处理大规模数据。是一个相当底层的编程模型，用于计算机集群分布式执行。</li>
<li>图数据模型 neo4j cypher</li>
</ul>
<h4 id="1-3-存储与检索"><a href="#1-3-存储与检索" class="headerlink" title="1.3 存储与检索"></a>1.3 存储与检索</h4><p>主要有两种存储引擎：日志结构（log-structured）、面向页面（page-oriented）B树。<br><br>数据存储的诸多问题：文件格式、删除记录、崩溃恢复、部分写入、并发控制。为什么追加日志：追加和分段合并是顺序写入，比随机写快。某种程度上顺序写基于闪存的固态硬盘SSD也是很好的；如果段文件是附加的或不可变得，并发和崩溃恢复就简单了；合并旧段可以避免数据文件随着时间推移分散的问题。<br><br><strong>哈希索引缺点</strong><br></p>
<ul>
<li>散列表必须可以放进内存</li>
<li>范围查询效率不高</li>
</ul>
<h5 id="SSTables和LSM树"><a href="#SSTables和LSM树" class="headerlink" title="SSTables和LSM树"></a>SSTables和LSM树</h5><p>每个日志结构存储段都是一系列键值对。假设要求键值对的序列按键排序，就把这种格式称为排序字符串表（Sorted String Table），简称SSTable。压缩保证每个键只在每个合并段文件出现一次。优点：</p>
<ul>
<li>合并简单高效。类似归并排序</li>
<li>为了在文件中找到一个特定的键，不需要保存内存中所有键的索引。</li>
</ul>
<p>在磁盘上维护有序结构是可能的（B树），但是内存中更容易。比如红黑树、AVL树。那么构建存储引擎的思路：</p>
<ol>
<li>写入时，添加到内存中的AVL树，这个内存树被称为内存表（memtable）</li>
<li>当内存表大于某个阈值（几兆），将其作为SSTable写入磁盘。写入后，继续写入到一个新的内存表；</li>
<li>为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，在下一个较旧的段中找到该关键字；</li>
<li>有时在后台运行合并、压缩过程以组合段文件并丢弃覆盖或删除的值。<br>如果数据库崩溃，则最近写入的内存表则会丢失，所以在写入日志时，日记追加到磁盘上，以便崩溃后恢复。</li>
</ol>
<p>用SSTable制作LSM树：算法本质上是LevelDB、RocksDB中使用关键值存储引擎库，被设计嵌入到其他应用程序中。Cassandra、HBase使用了类似存储引擎，都是受到SSTable、memtable启发。<br><br>lucene是ES、Solr使用的一种全文搜索引擎，使用类似方法它的词典。全文索引比键值索引复杂，基于类似想法：在搜索查询中给出一个单词，找到提及的单词的所有文档。通过键值结构实现，键是单词（term），值包含单词（文章列表）的所有文档的ID列表。</p>
<p><strong>性能优化</strong><br><br>当查找数据库中不存在的键时，LSM树算法可能很慢：必须检查内存表，可能会从磁盘读取每一个，才能确定键是否存在。为了优化这种访问，存储引擎通常使用额外的<strong>bloom过滤器</strong>。不同策略确定SSTable如何被压缩、合并顺序时间。分层压缩、平坦压缩，比如levelDB使用平坦压缩，HBase使用大小分层，cassandra同时支持。规模级别的调整中，更新和更小的SSTable先后被合并到更老、更大的SSTable中。水平压缩，关键范围被拆分成更小的SSTable，较旧的数据被移动到单独的水平上，使得压缩能够递增进行，使用更少的磁盘空间。</p>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>像SSTable一样，B树保持按键排序的键值对，允许高效的键值查找和范围查询。日志结构索引将数据库分解为可变大小的段，总是按顺序编写段。相比B树将数据库分解为固定大小的块或页，传统上为4kb（有时更大），并且一次只能读取或写入一个页面。这种设计更接近底层硬件，因为磁盘也被安排在固定大小的块中。<br><br><strong>让B树更可靠</strong><br><br>B树基本底层写操作是用新数据覆盖磁盘上页面，假定覆盖不改变页面位置。这与日志结构索引LSM形成对比，LSM只附加到文件，删除过时文件。硬盘上发生的操作：磁头移到正确位置，转到正确位置后，用新的数据覆盖适当扇区。固态硬盘上，SSD必须一次擦除和重写相当大的存储芯片块。为了防止数据库崩溃数据丢失，B树也实现了一个额外的磁盘数据结构：预写式日志（WAL write-ahead-log redo log）。仅追加的文件，多个线程修改的时候，需要进行并发控制。</p>
<h5 id="比较B树和LSM树"><a href="#比较B树和LSM树" class="headerlink" title="比较B树和LSM树"></a>比较B树和LSM树</h5><p>LSM树写入速度更快，B树读取速度更快。读取LSM需要压缩不同阶段检查几个不同数据结构和SSTable。<br><br><strong>LSM树优点</strong></p>
<ul>
<li>B树索引至少两次写入每一段数据：一次写入预先写入日志，一次写入树页面本身。即使页面几个字节发生变化，也需要一次编写整个页面。</li>
<li>由于反复压缩、合并SSTable，日志结构也会重写数据。在数据库的生命周期中写入数据库导致对磁盘的多次写入，被称为写放大write amplification。</li>
<li>LSM树通常能够比B树支持更高的写入吞吐量，具有较低的写放大，因为顺序写入紧凑的SSTable不是覆盖树中几个页面。</li>
<li>LSM树可以被压缩的更好，比B树在磁盘上产生更小的文件。B树存储引擎会由于分割留下一些未使用的磁盘空间：当页面被拆分或某行不能放入现有页面，页面中某些空间仍未被使用。由于LSM树不是面向页的，并且定期重写SSTable去除碎片，所以有较小存储开销，特别是使用平坦压缩。</li>
</ul>
<p><strong>LSM缺点</strong></p>
<ul>
<li>压缩过程有时会干扰正在进行的读写操作。尽管存储引擎尝试逐步执行压缩而不影响并发访问，但是磁盘资源有限，很容易发生请求需要等待磁盘完成昂贵压缩操作。对吞吐量和平均响应时间影响通常很小。</li>
<li>压缩另一个问题出现在高写入吞吐量：磁盘的有限写入带宽需要在初始写入（记录和刷新内存表到磁盘）和后台运行的压缩线程间共享。数据库越大，压缩所需的磁盘带宽就越多。</li>
<li>如果写入吞吐量很高，并且压缩没有仔细配置，压缩跟不上写入速度。这种情况下，磁盘上未合并段数量不断增加，直到磁盘空间用完，读取速度也会减慢。通常情况，即使压缩无法跟上，基于SSTable的存储引擎也不会限制写入速度，需要进行监控。</li>
</ul>
<p>B树一个优点是：每个键只存在于索引一个位置，而日志结构化存储引擎可能在不同段中有相同键多个副本，B树可以更容易实现事务。</p>
<ul>
<li>主键索引 二级索引</li>
<li>多列索引 将多个字段组合成一个键</li>
<li>全文搜索和模糊索引 Lucene为其词典使用了一个类似SSTable的结构，这个结构需要一个小的内存索引，告诉查询在排序文件中哪个偏移量查找关键字。Lucene中内存中索引是键中字符的有限状态自动机，类似于Trie，支持在给定编辑距离内有效搜索单词。</li>
<li>缓存 内存数据库。内存数据库重启需要从磁盘、网络从副本加载状态。</li>
<li>列存储 不要讲所有来自一行的值存储在一起，将来自每列的值存储在一起。还可以进一步通过压缩数据来进一步降低对磁盘吞吐量的需求，面向列存储很适合压缩，使用位图。cassandra和Hbase有列族的概念，从BigTable继承，面向列存储是有误导性的，因为在每个列族中，将一行中的所有列与行键一起存储，并且不适用列压缩，因此BigTable模型仍然主要面向行的。</li>
</ul>
<p>内存带宽和向量处理<br></p>
<ul>
<li>需要扫描数百万行的数据仓库查询，巨大的瓶颈是从磁盘获取数据到内存的带宽。另一个地方是：如何有效利用主存储器带宽到CPU缓存的带宽，避免CPU指令处理流水线中的分值错误预测和泡沫，以及现代中使用单指令多数据（SIMD）指定CPU。</li>
<li>除了减少从磁盘加载的数据量外，面向列存储也可以有效利用CPU周期。比如查询引擎可以将大量压缩的列数据放在L1缓存中，然后在紧密的循环中循环（没有函数调用）。前面描述的按位“与”和“或”运算可以被设计为直接在这样的压缩列数据块上操作。这种技术被称为<strong>矢量化处理</strong>。</li>
</ul>
<h3 id="2-分布式数据"><a href="#2-分布式数据" class="headerlink" title="2 分布式数据"></a>2 分布式数据</h3><h5 id="共享内存架构"><a href="#共享内存架构" class="headerlink" title="共享内存架构"></a>共享内存架构</h5><p>许多处理器，内存和磁盘可以在同一个OS下相互连接，快速的相互连接允许任意处理器访问内存、磁盘的任意部分。在这种共享内存架构（share-memory），所有组件都可以看作一台单独的机器。（大型机中，尽管任意处理器可以访问内存任意部分，但总有一些区域与一些处理器更接近，称为非均匀内存访问NUMA，为了更有效利用这种架构特性，需要对处理进行细分，以便每个处理器主要访问临近内存，分区partitioning仍是必要的）<br><br>共享内存问题：成本增长速度快于线性增长。双倍处理器、双倍内存不足以处理双倍载荷。共享内存架构提供有限的容错能力，尽管高端机器可以使用热插拔组件（不更换磁盘、内存、甚至处理器）</p>
<h5 id="共享磁盘shared-disk"><a href="#共享磁盘shared-disk" class="headerlink" title="共享磁盘shared-disk"></a>共享磁盘shared-disk</h5><p>使用多台具有独立处理器和内存的机器，但将数据存储在机器之间的共享磁盘整列上，磁盘通过网络连接，这种架构用于某些数据仓库，但竞争和锁定的开销限制了共享磁盘方法的可扩展性。</p>
<h5 id="无共享架构shared-nothing"><a href="#无共享架构shared-nothing" class="headerlink" title="无共享架构shared-nothing"></a>无共享架构shared-nothing</h5><p>有时称为水平扩展scale out。每个节点只使用各自处理器、内存、磁盘。节点间的任何协调，都是在软件层面使用传统网络实现。无共享架构不需要使用特殊硬件，可以使用任意机器。</p>
<h5 id="复制replication-VS-分区partitioning"><a href="#复制replication-VS-分区partitioning" class="headerlink" title="复制replication VS 分区partitioning"></a>复制replication VS 分区partitioning</h5><p>数据分布在多个节点上有两种常见方式：复制，在几个不同节点保存相同副本，复制提供冗余。分区：将一个大型数据库拆分成较小子集，从而不同分区指派给不同节点node，也称为分片shard。</p>
<h5 id="为什么数据需要复制"><a href="#为什么数据需要复制" class="headerlink" title="为什么数据需要复制"></a>为什么数据需要复制</h5><ul>
<li>使得数据与用户在地理上接近（从而减少延迟）</li>
<li>系统一部分出现故障，系统也能继续工作（提高可用性）</li>
<li>扩展可以接受请求的机器数量（提高读吞吐量）</li>
</ul>
<p>复制困难之处在于处理复制数据的变更，主要有三种流行的复制算法：单领导者(single leader) 多领导者(multi leader) 无领导者(leaderless)。复制时需要考虑，同步复制还是异步复制，如何处理失败的副本。</p>
<p>处理异常：</p>
<ul>
<li>从库失效：追赶恢复</li>
<li>主库失效：故障切换。将其中一个从库提升为新的主库，以将他们的写操作发送给新主库，这个过程称为failover。</li>
</ul>
<h5 id="复制日志的实现"><a href="#复制日志的实现" class="headerlink" title="复制日志的实现"></a>复制日志的实现</h5><p><strong>基于语句的复制</strong><br><br>主库记录执行的每个请求（语句statement），并将该语句日志发送给其从库。对于关系数据库来说，就是每个insert update delete语句。但是也有一些问题：</p>
<ul>
<li>任何调用非确定性函数(nondeterministic)语句，可能会在每个副本上生成不同的值，比如Now()，rand()。</li>
<li>如果语句使用了自增列(auto increment)，或者依赖现有数据，则必须在每个副本按照完全相同的顺序执行，否则会产生不同的效果。当有多个并发执行事务时，可能成为一个限制。</li>
<li>有副作用语句（触发器、存储过程）可能会在每个副本产生不同副作用。</li>
<li>解决方法：主库可以用固定返回值替代确定的函数调用，以便从库获得相同的值。</li>
</ul>
<p><strong>传输预写式日志</strong><br></p>
<ul>
<li>对于日志结构存储引擎，日志段在后台压缩，并进行垃圾回收</li>
<li>对于覆写单个磁盘块的B树，每次修改都会写入预写式日志（WAL）</li>
</ul>
<p>任何情况日志都包含所有数据库写入的仅追加字节序列，可以使用完全相同的日志在另一个节点上构建副本。除了将日志写入磁盘，主库还可以通过网络将其发给从库。</p>
<p>Postgre和Oracle使用这种复制方法，缺点是：日志记录非常底层，WAL包含哪些磁盘块中，哪些字节发生更改。这使复制与存储引擎紧密耦合。</p>
<p><strong>逻辑日志复制（基于行）</strong><br><br>复制和存储引擎使用不同的日志格式，可以使复制日志从存储引擎内部分离出来。这种复制日志称为逻辑日志，以将其与存储引擎（物理）的数据表区分开。</p>
<ul>
<li>对于插入的行，日志包含所有列的新值</li>
<li>对于删除的行，日志包含足够的信息标识已删除的行</li>
<li>对于更新的行，日志包含更新的行，以及更新的新值。</li>
</ul>
<p><strong>基于触发器复制</strong><br><br>相比其他复制具有更高的开销，更容易出错，也有很多限制，但更灵活。</p>
<p><strong>多主复制</strong><br><br>应用场景：数据库的副本分布在不同数据中心，常规基于领导者复制，主库必须位于其中一个数据中心，所有写入都要经过该数据中心。要解决不同数据中心同时修改相同数据，需处理冲突。另一种场景：应用程序在断网后仍需要继续工作。协同编辑场景。避免冲突：通过一些手段指定固定的leader。或者通过唯一ID、时间戳。自定义冲突解决逻辑，写时执行或读时执行，让应用自己选择解决。复制拓扑有环形拓扑、星型拓扑、雪花拓扑。</p>
<p><strong>无主复制</strong><br><br>单主复制、多主复制都是基于这样想法：客户端向一个主库发送写请求，数据库系统负责将写入复制到其他副本，主库决定写入的顺序，从库按相同顺序应用主库写入。最早一些复制系统是无领导的leaderless，现在又开始流行起来。</p>
<p><strong>读修复和反熵</strong><br><br>读修复：客户端并行读取多个节点，可以检测到任何陈旧响应，判定新值，写会复制品。<br><br>反熵过程：数据存储的后台不断查找副本间数据差异，将任何缺少的数据从一个副本复制到另一个副本。</p>
<h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>数据在不同节点上的副本，对于非常大的数据集成本很高（吞吐量很大），仅仅复制是不够的。还需要将数据进行分区partitions，也成为分片sharding。【与网络分区不是同一个概念】<br></p>
<p>分区概念在MongoDB、ES、Solor中称为分片shard，HBase中称为region，Bigtable中是tablet，Cassandra是vnode虚节点。</p>
<p>分区主要是为了<strong>扩展性</strong>，不同分区可以放在不共享集群中不同节点上，因此大数据集可以分布在多个磁盘上。分区通常与复制结合使用，使得每个分区副本存储在多个节点上，意味着每条记录属于一个分去，仍然可以存储在多个不同节点上获得容错能力。</p>
<p>键值数据如何分区，哪些节点存储哪些数据，如果分区不公平，会导致形成高负载的分区，也成为热点hot spot。</p>
<h5 id="根据键的范围分区"><a href="#根据键的范围分区" class="headerlink" title="根据键的范围分区"></a>根据键的范围分区</h5><p>为每个分区指定一块连续的键范围，如果知道范围边界，则可以轻松确定哪个分区包含某个值。key range分区缺点是某些特定模式会导致热点。</p>
<h5 id="根据键的散列分区"><a href="#根据键的散列分区" class="headerlink" title="根据键的散列分区"></a>根据键的散列分区</h5><p>根据散列函数、哈希、加密算法，在分区之间分配键，分区边界可以是均匀间隔的，也可以是伪随机选择的，有时也可以称之为<strong>一致性哈希</strong>。</p>
<p>通过使用Key散列进行分区，失去了键范围分区的一个很好的属性：<strong>高效执行范围查询的能力</strong>。组合索引为一对多关系提供了一个优雅的数据模型，比如主键（userId,updateTime）。</p>
<h5 id="负载倾斜与消除热点"><a href="#负载倾斜与消除热点" class="headerlink" title="负载倾斜与消除热点"></a>负载倾斜与消除热点</h5><p>极端情况，所有读写可能是针对同一个键的，所有请求都会被路由到同一分区。大数据系统无法自动补偿这种高度偏斜的负载，应用程序有责任减少偏斜。比如在火爆ID的前后加一些数字，保证其分布在不同分区。</p>
<h4 id="分片与次级索引"><a href="#分片与次级索引" class="headerlink" title="分片与次级索引"></a>分片与次级索引</h4><p>前面的分区方案依赖键值数据模型，如果只通过主键访问记录，可以确定键分区。如果涉及次级索引，会更加复杂。通常辅助索引不能唯一标识记录。次级索引是关系数据库基础，在文档数据库也很普遍。次级索引不能整齐映射到分区，有两种用二级索引对数据库进行分区的方法：<strong>基于文档的分区document-based 基于关键词term-based</strong></p>
<h5 id="按文档的二级索引"><a href="#按文档的二级索引" class="headerlink" title="按文档的二级索引"></a>按文档的二级索引</h5><p>假如有一个汽车列表，每个列表有一个唯一ID（文档ID），利用ID对数据库进行分区，可以通过颜色、厂商过滤，所以需要在颜色、厂商建次级索引（文档数据库中是字段field，关系数据库中是列column）。比如有俩分区</p>
<ul>
<li>partition0：191 -&gt; {color:”red”,make:”Honda”} 214 -&gt;{color:”black”,make:”Dodge”} 306 -&gt;{color:”red”,make:”Ford”}</li>
</ul>
<ol>
<li>次级索引： color:black -&gt; [214]  color:red -&gt; [191,306]  color:yellow -&gt; []</li>
</ol>
<ul>
<li>Partition1：515 -&gt; {color:”silver”} 768 -&gt; {color:”red”} 893 -&gt; {color:”silver”}</li>
</ul>
<ol start="2">
<li>color:black -&gt; [] color:red -&gt; [768]  color:siler -&gt; [515,893]</li>
</ol>
<p>这种索引方法每个分区独立，分区维护自己的二级索引。文档分区索引也被称为本地索引local index。查询的时候需要发送到所有分区，这种查询称为分散/聚集(scatter gather)，并且可能会使二级索引上读取查询很昂贵，即时并行查询分区，分散/聚集也容易导致尾部延迟放大。cassandra、es、solor中广泛使用。</p>
<h5 id="根据关键词（Term）的二级索引"><a href="#根据关键词（Term）的二级索引" class="headerlink" title="根据关键词（Term）的二级索引"></a>根据关键词（Term）的二级索引</h5><p>也可以构建一个覆盖所有分区数据的全局索引，而不是给每个分区创建自己的次级索引。但是不能只把这个索引存储在一个节点上，可能会成为瓶颈，违背分区目的。全局索引也必须进行分区，可以采用与主键不同分区方式。</p>
<ul>
<li>partition0: color:black -&gt; [214]  color:red -&gt; [191,306,768]</li>
<li>partition1: color:silver -&gt; [515,893] color:yellow -&gt; []</li>
</ul>
<p>可以通过关键词本身或散列进行索引分区，根据其本身对范围扫描非常有用（数字，汽车报价），而对关键词的哈希分区提供了负载均衡能力。</p>
<h4 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h4><p>随着时间推移，数据库的变化：</p>
<ul>
<li>查询吞吐量增加，增加更多CPU</li>
<li>数据集大小增加，增加磁盘 RAM</li>
<li>机器故障，其他机器来接管</li>
</ul>
<p>这些更改都需要将数据和请求从一个节点移动到另一个节点，将负载从集群一个节点移向另一个节点称为再平衡reblancing。</p>
<p>再平衡需要满足：</p>
<ul>
<li>负载在集群节点间公平共享</li>
<li>再平衡发生时 数据库继续接受读取写入</li>
<li>节点之间只移动必须的数据，以便快速再平衡，减少网络和磁盘IO</li>
</ul>
<h5 id="平衡策略"><a href="#平衡策略" class="headerlink" title="平衡策略"></a>平衡策略</h5><ul>
<li>固定数量分区：创建比节点更多的分区，每个节点分配多个分区。如运行在10个节点的集群可能被拆为1000个分区，大约有100个分区分配给每个节点。如果一个节点添加到集群中，则可以从旧节点分配一些区给新节点。分区数量不变，还可以解决硬件不匹配问题：为更强大的节点分配更多区，承受更多负载，如ES couchHbase</li>
<li>动态分区 对于使用键范围分区的数据库，具有固定边界的固定数量的分区将非常不便。按键范围进行分区的数据库（如HBase）会动态创建分区，分区增长超过配置大小，会被分成两个分区。数据量小的分区可以合并。</li>
<li>按节点比例分区。以上两种策略中，分区的数量与节点数量无关。cassandra使用的是分区数与节点数成正比，每个节点具有固定数量分区。一个新节点加入集群，随机选择固定数量现有分区进行拆分，然后占有这些拆分分区中每个分区一半。可能产生不公平分割。</li>
</ul>
<h5 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h5><p>客户发出请求如何知道连接哪个节点，概括为服务发现service discovery。</p>
<ol>
<li>允许客户连接任何节点（如Round-Robin load balancer）。如果该节点恰巧拥有请求的分区，则处理返回；否则将请求转发到适当节点；</li>
<li>将客户端请求转发到路由层，决定怎么转发，负责负载均衡</li>
<li>客户端知道分区和节点分配。HBase、Solor、Kafka使用zk跟踪分区分配，mongoDB依赖自身配置服务config server，cassandra使用gossip协议。</li>
</ol>
<h5 id="索引和快照隔离"><a href="#索引和快照隔离" class="headerlink" title="索引和快照隔离"></a>索引和快照隔离</h5><p>索引如何在多版本数据库工作，一种是使索引简单指向对象所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本。当垃圾手机删除任何事务，相应索引条目也可以被删除。实践中许多实现细节决定了多版本并发控制的性能。<br><br>在CouchDB、LMDB，使用的是B树，但是使用的是仅追加/写时拷贝，更新时不覆盖树的页面，而是创建一个副本。从父页面直到树根级联更新。仅追加B树，每个写入事务都会创建一棵新的B树。当创建时，从该特定树根生长的树就是数据库一个一致性快照。没必要根据事务ID过滤对象，因为不能修改现有的B树。这种方法也需要一个负责压缩和垃圾收集的后台进程。</p>
<h4 id="分布式系统的麻烦"><a href="#分布式系统的麻烦" class="headerlink" title="分布式系统的麻烦"></a>分布式系统的麻烦</h4><h5 id="云计算与超级计算机"><a href="#云计算与超级计算机" class="headerlink" title="云计算与超级计算机"></a>云计算与超级计算机</h5><ul>
<li>一种是一端是高性能计算（HPC）。具有数千个CPU的超级计算机，通常用于计算密集型科学计算任务，如天气预报、分子动力学。</li>
<li>另一个极端是云计算，通常与多租户数据中心，连接IP网络的商品计算机，弹性/按需资源分配以及计量计费相关联；</li>
<li>传统企业数据中心位于两个极端之间</li>
</ul>
<p>不同哲学会有不同故障处理方式。超级计算机通常会将计算状态持久化到磁盘，一个节点故障简单的停止整个集群工作。故障修复后，从上一个检查点重新开始。互联网服务系统有很大不同：</p>
<ul>
<li>互联网应用程序都是在线的，需要能够随时以低延迟服务用户。</li>
<li>超级计算机通常由专用硬件构成，每个节点相当可靠，节点通过共享内存、远程直接内存RDMA进行通信。云服务节点是由商品机器构建而成，较低成本提供相同性能，具有较高故障率。</li>
<li>大型数据中心网络通常基于IP和以太网，以闭合拓扑排列，提供更高的二等分带宽。超级计算机通常使用专门的网络拓扑结构，例如多维网格和环面，这为已知通信模式的hPC工作负载提供更好的性能</li>
</ul>
<p><strong>不可靠网络</strong><br><br>分布式系统是无共享系统，通过网络连接一堆机器，一台机器不能访问另一台机器内存或磁盘。无共享并不是构建系统的唯一方式，但是已成为主要方式。相对便宜、不需要特殊的硬件、利用商品化的云计算服务、通过跨多个地理分布的数据中心进行冗余可以实现高可用。</p>
<p>互联网和数据中心中大多数内部网络都是<strong>异步分组网络</strong>，不保证消息可靠送达。</p>
<p>同步网络：即使数据经过多个路由器，也不会受到排队影响，因为呼叫的16位空间已经在网络的下一挑中保留了下来。而且由于没有排队，网络的最大端到端延迟是固定的。电话网络中的电路与TCP连接有很大不同：电路是固定数量预留带宽，电路建立时没有其他人可以使用，而TCP连接的数据包机会性的使用任何网络带宽。可以给TCP一个可变大小的数据块（网页 电子邮件），尽可能在最短的时间内传输，TCP连接空间时，不使用任何带宽（除了keepalive包）。</p>
<p>为什么数据中心和互联网使用分组交换？针对突发流量，进行优化。一个电路适用于音频或视频通话，通话期间传送相当数量的比特；请求网页没有特定的带宽要求，只需要尽快完成即可。<strong>如果想通过电路传输文件，不得不猜测一个带宽分配。太高电路无法建立，太低，会有电路浪费网络容量。相比TCP动态调整数据传输速率以适应可用的网络容量</strong></p>
<p>延迟和资源利用：一般来讲可以将延迟变化为动态资源分区的结果。如果资源是静态分区的，则在某些环境中可以实现延迟保证，但是以降低利用率为代价的。<strong>网络中的可变延迟不是一种自然规律，而只是成本/收益权衡的结果。</strong></p>
<p><strong>不可靠的时钟</strong><br><br>分布式系统中，时间很棘手，因为通信不是即时的，很难确定在涉及多台机器时发生事情的顺序。而且网络上每台机器都有自己的时钟，这是一个硬件设备，通常是石英晶体振荡器。而且是不完全准确的，每台机器都有自己的时间概念。<strong>可以在一定程度上同步时钟，最常用的机制是网络时间协议NTP，允许根据一组服务器报告的时间来调整计算机时钟，更精确的可以使用时间源，如GPS机获取时间</strong></p>
<p><strong>单调钟与时钟</strong><br></p>
<ul>
<li>时钟 根据某个日历（也称为挂钟时间wall-clock time）返回当前日期和时间，如linux上clock_gettime。java中system.currentTImeMills返回自epoch。虽然时钟被称为实时时钟，但它与OS无关。时钟通常与NTP同步，意味着一台机器时间戳与另一台机器时间戳相同。当本地时钟比NTP服务器跑的快，可能会被强制重置，好像跳回了先前的时间点。这些跳跃以及经常忽略闰秒的事实，使时钟不能用于测量经过的时间。</li>
<li>单调钟适用于测量持续时间（时间间隔），如超时或服务响应时间，java中system.nanoTime。具有多个CPU插槽的服务器，每个cpu可能有一个单独计时器，不一定与其他cpu同步。os会补偿所有差异，明智做法不要太信任单调性保证。NTP协议检测到计算机本地石英钟比NTP服务器更快、更慢，可以调整单调钟向前走的频率。NTP允许时钟速率增加或减慢最高至0.05%。NTP不能使单调使用向前向后跳转。</li>
</ul>
<p><strong>时钟同步与准确性</strong><br><br>单调钟不需要同步，始终需要根据NTP服务器或其他外部时间源来设置才有用。硬件时钟和NTP可能变幻莫测，计算机中石英钟不够精确，会漂移drifts。漂移取决与机器温度。google假设其服务器每30s与服务器重新同步一次的时钟漂移为6ms，或者每天重新同步的时钟漂移为17s。</p>
<ul>
<li>如果计算机时钟与NTP服务器时钟差别太大，可能拒绝同步或者本地时钟将被强制重置。</li>
<li>NTP服务器意外阻塞，可能在一段时间内忽略错误配置</li>
<li>NTP同步只能和网络延迟一样。通过互联网同步，35ms的最小误差是可以实现的。较大的网络延迟会导致NTP客户端完全放弃。</li>
<li>闰秒导致59分钟或许有61s。闰秒已经使许多大型系统崩溃说明关于时钟的假设是多么容易溜进系统，处理闰秒的最佳方法是通过在一天中逐渐执行闰秒调整。</li>
<li>虚拟机中，硬件时钟会被虚拟化。当一个cpu核心在虚拟机间共享，每个虚拟机都会暂停几十毫秒，而另一个虚拟机正在运行。从应用角度看，这种停顿表现为时钟突然向前跳跃。</li>
<li>如果在未完全控制的设备上运行软件（移动、嵌入式设备），坑完全不信任该设备硬件时钟。一些用户估计将其硬件时钟设置为不正确日期和时间，例如为了规避游戏中时间限制，时钟可能会被设置到很远的过去或将来。</li>
</ul>
<p>欧洲金融机构要求所有高频交易基金在UTC在时间100微秒内同步时钟，以便调试闪崩等市场异常现象，帮助检测市场操纵。很多东西都会导致时钟同步错误，如果NTP守护进程配置错误，或者防火墙阻止了NTP通信，由漂移引起的时钟误差可能很快就变大。</p>
<h6 id="有序事件的时间戳"><a href="#有序事件的时间戳" class="headerlink" title="有序事件的时间戳"></a>有序事件的时间戳</h6><p>有的分布式系统会依赖时钟，多个节点存在时钟误差的情况下，会发生冲突。有一种解决冲突的策略：最后写入为准LWW。在多领导者、无领导者数据库如cassandra中被广泛使用。有些是在客户端生成时间戳，但是不能改变LWW基本问题：</p>
<ul>
<li>数据库写入神秘消失：具有滞后时钟的节点无法用快速时钟覆盖之前由节点写入的值，直到节点之间的时钟偏差过去</li>
<li>LWW无法区分高频顺序写入（客户端B的增量操作一定发生在客户端A写入滞后）和真正并发写如。需要额外因果关系跟踪机制（版本向量），以防止因果关系冲突。</li>
</ul>
<p>所谓逻辑时钟是基于递增计数器而不是震荡石英晶体，对于排序事件是更安全的选择。逻辑时钟不测量一天中的时间或经过的秒数，而仅测量事件相对顺序。相反用来测量实际经过时间的时钟和单调钟被称为物理时钟。</p>
<p>spanner的trueTime API会报告本地时钟的置信区间，当询问当前时间，会得到【最早，最晚】</p>
<h6 id="全局快照的同步时钟"><a href="#全局快照的同步时钟" class="headerlink" title="全局快照的同步时钟"></a>全局快照的同步时钟</h6><p>当数据库分布在许多机器上，由于需要协调全局单调递增的事务ID可能很难生成，事务ID必须反映因果关系。在有大量小规模、高频率的事务情景下，分布式系统中创建事务ID成为一个瓶颈。Twitter的snowflake，通过将ID空间的块分配给不同节点近似单调的增加唯一ID。但是无法保证与因果关系一致的排序。</p>
<p>可以使用同步时钟的时间戳作为事务ID，如果能够获得足够好的同步性，这种方法具有很合适的属性，更晚的事务具有更大的时间戳。<strong>spanner以这种方式实现快照隔离，使用TrueTime APi报告时钟置信区间，如果有两个置信区间，每个区间包含最早、最晚时间戳。nodeA=[a,b],nodeb=[c,e]。如果两个区间不重合，肯定有先后顺序。如果重叠，在提交事务时故意等待置信区间长度的时间。</strong>为了保持尽可能短的等待时间，spanner需要保持尽可能小的时钟不确定性。为此google在每个数据中心都部署的一个GPS接收器或原子钟，允许时钟在大约7ms内同步。</p>
<p><strong>暂停进程</strong><br><br>假设一个数据库，每个分区只有一个领导者，只有领导允许接受写入，一个节点如何知道它仍是领导者，并且可以安全的接受写入。</p>
<ul>
<li>一种选择是领导者从其他节点获得一个租约lease，类似一个带超时的锁。任一时刻只有一个节点可以持有该租约。租约类就是leader，到期后节点必须周期性续约；<strong>这样的设计会依赖同步时钟：租约到期时间由另一台机器设置（如当前时间加上30s，计算到期时间）。并将其与本地系统时钟进行比较，如果时钟超过几秒不同步，就开始做奇怪的事情。</strong> 如果颁发者的时钟比接收者的时钟慢，则当接收者认为 lease 已经过期的时候，颁发者依旧认为 lease 有效。接收者可以用在 lease 到期前申请新的 lease 的方式解决这个问题。<br>如果颁发者的时钟比接收者的时钟快，则当颁发者认为 lease 已经过期的时候，接收者依旧认为 lease 有效，颁发者可能将 lease颁发给其他节点，造成承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是将颁发者的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对 lease 的有效性的影响</li>
<li>即使协议改为使用本地单调时钟，存在的问题：代码假定在执行剩余时间检查currentTimeMills和实际执行请求process中时间间隔非常短，10s足够确保租约在请求处理到一半不会过期，但是程序执行中出现意外停顿，假如lease.isValid周围停止15s，然后终止。这种情况下，在请求被处理的时候，租约可能已经过期，另一个节点已经接管了leader。直到循环到下一个迭代，可能已经做了一些不安全处理请求。引起线程暂停的原因：gc、虚拟化环境中可以挂起虚拟机并恢复，这个暂停可以在进程执行的任何时候发生，可以持续任意长时间，这个功能可用于虚拟机从一个主机写到另一个主机的实时迁移，不需重启。暂停长度取决于进程写入内存的速率；笔记本关盖子；OS上下文切换；程序同步访问磁盘，等待IO完成；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    request=getRequest()</span><br><span class="line">    if(lease.expireTIme-currentTImeMills&lt;10000)</span><br><span class="line">&#123;</span><br><span class="line">    lease.renew()</span><br><span class="line">&#125;</span><br><span class="line">    if(lease.isValid())&#123;</span><br><span class="line">        process(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="响应时间保证"><a href="#响应时间保证" class="headerlink" title="响应时间保证"></a>响应时间保证</h6><p>某些软件运行环境要求很高，如飞机主控计算机，火箭、机器人。在这些系统中，软件必须有一个特定截止时间，如果截止时间不满足，可能导致整个系统故障，这就是所谓的硬实时。实时操作系统允许在指定时间间隔内保证cpu时间分配，库函数必须记录最坏情况下的执行时间；动态内存分配可能受到限制或完全不允许（实时垃圾收集器存在，但是应用程序仍然必须确保它不会给GC太多负担），必须进行大量测试和测量；这些都需要大量额外的工作，严重限制了可以使用的编程语言、库和工具范围。</p>
<p>限制垃圾收集的影响<br><br>语言运行在计算垃圾回收时有一定灵活性，可以跟踪对象分配的速度和随着时间的推移剩余的空闲内存。新型的想法是将GC暂停视为一个节点的短暂计划中断，并让其他节点处理来自客户端的请求，同时一个节点正在收集垃圾。一些对延迟敏感的金融交易系统使用这种方法。</p>
<h6 id="知识、真相与谎言"><a href="#知识、真相与谎言" class="headerlink" title="知识、真相与谎言"></a>知识、真相与谎言</h6><p>分布式系统与单机不同：没有共享内存，只能通过不可靠网络传递消息，系统可能遭受部分失效，不可靠的时钟和处理暂停。</p>
<p>网络中一个节点无法确切的知道任何事情，只能根据网络接收到的消息进行猜测。节点只能通过交换消息来找出另一个节点所处的状态（存储了哪些数据、是否正确运行）。</p>
<p>这些系统的讨论与哲学有关：系统中什么是真什么是假？如果感知和测量的机制都不可靠，那么关于这些知识又能有多少确定。软件系统应该遵循对物理世界所期望的法则、因果关系么</p>
<p>分布式系统中，可以陈诉关于行为的假设，并以满足这些假设的方式设计实际系统。算法可以被证明在某个系统模型中正确运行。意味底层系统模型提供很少保证也可以实现可靠行为。</p>
<p>分布式算法要具有安全性和活性。唯一性、单调序列就是安全属性，可用性就是活性。安全性和活性对于推理分布式算法的正确性非常有用。</p>
<h6 id="兰伯特时间戳"><a href="#兰伯特时间戳" class="headerlink" title="兰伯特时间戳"></a>兰伯特时间戳</h6><p>这种方法可以产生因果关系一致的时间戳。基本思想：每个节点和客户端都跟踪迄今为止见到的最大计数器的值，并在每个请求中包含这个最大计数器的值。一个节点收到最大计数器值大于自身计数器值得请求或响应时，它立即将自己的计数器设置为这个最大值。</p>
<p>光有时间戳排序还不够，比如两个人不能建相同的账户，但是确保全局唯一，还得知道全序何时落地。正确的全序广播算法必须始终保证可靠性、有序性，即使节点或网络出现故障，网络中断，消息无法传递，但是算法可以重试，或者网络修复时，消息能及时送达。</p>
<p>etcd和zk这样的共识服务实现了全序广播，这正是数据库复制所需的，每个消息都代表一次数据库写入，每个副本按相同顺序处理相同写入，副本间保持一致。这个原理是状态机复制。</p>
<h3 id="3、-衍生数据"><a href="#3、-衍生数据" class="headerlink" title="3、 衍生数据"></a>3、 衍生数据</h3><p>从高层次看，存储和处理数据的系统可以分为两大类：</p>
<ul>
<li>记录系统（System of record）。也被称为source of truth，持有数据的权威版本。当新的数据进入首先会记录在这里。</li>
<li>衍生数据系统derived data system。通常是另一个系统中现有数据以某种方式进行转换或处理的结果。如果丢失衍生数据，可以从原始源重新创建。</li>
</ul>
<p>从技术上讲，衍生数据是冗余的，因为重复了已有信息。但是衍生数据对于获得良好的只读性能通常很重要。大多数数据库、存储引擎和查询语言，本质上既不是记录系统也不是衍生系统。数据库只是一个工具，如何使用取决于个人；记录系统和衍生系统之间区别不在于工具，而在于应用程序的使用方式。</p>
<h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p>有三种不同系统：</p>
<ul>
<li>服务（在线系统）。服务等待客户请求或指令到达，每收到一个，服务会试图尽快处理，并发回一个响应。响应时间通常是服务性能的主要衡量指标，可用性非常重要。</li>
<li>批处理系统（离线系统）。一个批处理系统有大量输入数据，跑一个作业job来处理，并生成一些输出数据，往往需要一段时间。批量作业通常会定期运行。批处理作业的主要性能衡量标准通常是吞吐量。</li>
<li>流处理系统（准实时系统）。像批处理系统一样，流处理消费输入并产生输出，但是流式作业在事件发生后不久就会对事件进行操作，而批处理作业则需要等待固定一组输入数据。</li>
</ul>
<p>批处理是一种很古老的计算方式，早在可编程数字计算机出现前，打孔卡制表机实现了半机械化的批处理形式。MapReduce和其他一些批处理算法和框架，并探索在现代数据系统中的作用。Unix的思想和经验教训可以迁移到大规模、异构的分布式数据库系统中。</p>
<p>Unix中cat、awk、head等工具能在积分中内处理几GB日志文件。另一方面如果作业工作集大于可用内存，则排序方法的优点是可以高效使用磁盘。与在SSTable和LSM树种讨论的原理一样；数据块可以在内存中排序作为段文件写入磁盘，灾后合并为一个更大的排序文件。归并排序具有在磁盘上运行酿好的顺序访问模式。linux中sort通过溢出至磁盘的方式来自动应对大于内存的数据集，并同时使用多个CPU核进行并行排序。意味着unix命令很容易扩展到大数据集，且不会耗尽内存。瓶颈可能是从磁盘读取输入文件的速度。</p>
<h6 id="Unix哲学"><a href="#Unix哲学" class="headerlink" title="Unix哲学"></a>Unix哲学</h6><p>Unix管道的发明者描述：当需要将消息从一个程序传递到另一个程序时，需要一种类似水管的拼接程序的方式。I/O也应该按照这种方式进行。Unix哲学：</p>
<ul>
<li>每个程序做好一件事。要做一件新的工作，写一个新程序，而不是通过添加功能让老程序复杂化；</li>
<li>期待每个程序的输出称为另一个程序的输入。不要将无关信息混入输出，避免使用严格的列数据或二进制输入格式，不要坚持交互式输入；</li>
<li>设计和构建软件、OS，要尽早尝试，最好几周内完成。扔掉笨拙的部分。</li>
<li>优先使用工具来减轻编程任务。即使必须曲线救国编写工具。</li>
</ul>
<p>这种自动化、快速原型设计、增量式迭代、对试验友好，将大型项目分解成可管理的块，很像现在的敏捷开发、DevOps。</p>
<h6 id="统一的接口"><a href="#统一的接口" class="headerlink" title="统一的接口"></a>统一的接口</h6><p>如果想要一个程序的输出称为另一个程序的输入，意味这些程序必须使用相同的数据格式–一个兼容的接口。如果想要将任何程序的输出连接到任何程序的输入，意味所有程序都必须使用相同IO接口。Unix中这种接口是一个文件file（一个文件描述符）。一个文件只是一串有序的字节序列。统一接口的另一个例子是URL和HTTP。</p>
<h6 id="MapReduce和分布式文件系统"><a href="#MapReduce和分布式文件系统" class="headerlink" title="MapReduce和分布式文件系统"></a>MapReduce和分布式文件系统</h6><p>和大多数Unix工具一样，运行MapReduce作业通常不会修改输入，除了生成输出外没有任何副作用。虽然unix使用stdin和stout作为输入、输出，但是MR在HDFS上读写文件，一个google文件系统GFS的开源实现。<strong>与网络连接存储NAS和存储区域网络SAN架构等的共享磁盘方案相比，HDFS基于无共享原则。共享磁盘存储由集中式存储设备实现，通常使用定制硬件和专用网络基础设施(光纤通信到)，而无共享不需要特殊硬件</strong></p>
<p><strong>处理倾斜</strong><br><br>如果存在与单个键关联的大量数据，在单个reducer中收集与某个名流相关的所有活动可能导致严重倾斜，也称为热点hot spot。由于MR作业只有在所有Mapper和Reducer都完成时才完成，所以后续作业必须等待最慢的Reducer才能进行。</p>
<ul>
<li>Pig中首先运行一个抽样作业来确定哪些是热键。Mapper会将热键关联记录随机到几个reducer之一，与热键相关的记录需要被复制到所有处理该键的reducer上。这样可以更好的并行化，代价是需要连接另一侧的输入记录复制到多个reducer上。</li>
<li>Hive采用另一个方法，在表格元数据中显示指定热键，并将与这些键相关的记录单独存放，与其他文件分开，对于热键，使用Map端连接。</li>
</ul>
<h6 id="Map端连接"><a href="#Map端连接" class="headerlink" title="Map端连接"></a>Map端连接</h6><p>Mapper扮演着预处理输入数据的角色：从每个输入记录中提取键值，将键值对分配给reducer分区，按键值排序。Reduce端的优点是不需要对输入数据做任何假设，无论其属性如何，mapper都可以对其预处理以备连接。不利的是，排序、复制至reducer以及合并reducer输入，开销巨大。</p>
<p>如果能对输入数据做出某些假设，通过使用所谓的map端连接加快连接速度是可行的，这种方法使用了一个阉掉reduce与排序Mapreduce作业，每个mapper只是简单从分布式文件系统读取一个输入文件快，然后将输出文件写入文件系统。</p>
<h6 id="广播散列连接"><a href="#广播散列连接" class="headerlink" title="广播散列连接"></a>广播散列连接</h6><p>适用于Map端连接的最简单的场景是最大数据集与小数据集连接的情况。小数据集需要足够小，可以将其全部加载到每个Mapper的内存中。参与连接的较大输入的每个文件各有一个Mapper。这种简单有效的连接叫做广播散列连接：每个连接较大输入端分区的Mapper都会将较小输入端数据集整个读入内存。Pig中是复制链接，hive中叫MapJoin。也被Impala的数据仓库查询引擎使用。<strong>另一种方法是将较小输入存储在本地磁盘上的只读索引中，索引中经常使用的部分保留在OS的页面缓存中，几乎可以提供与内存散列表几乎一样的随机查找性能</strong></p>
<h6 id="广播散列连接-1"><a href="#广播散列连接-1" class="headerlink" title="广播散列连接"></a>广播散列连接</h6><p>如果map端连接的输入以相同的方式进行区分，则散列连接方法可以独立应用于每个分区。比如可以用根据用户ID最后一位十进制数字来对活动事件和用户数据库进行分区，如Mapper3首先将所有具有3结尾的ID的用户加载到散列表中，然后扫描ID为3的每个用户活动事件。如果分区无误，可能需要连接的记录都落在同一个编号的分区中。因此每个Mapper只需要从输入两端各读取一个分区就足够，好处是每个Mapper都可以在内存散列表中少放点数据。这种方法只有连接两端输入有相同的分区树，且两侧记录使用相同的键和相同哈希函数才使用。</p>
<h6 id="Map端合并连接"><a href="#Map端合并连接" class="headerlink" title="Map端合并连接"></a>Map端合并连接</h6><p>如果输入数据集不仅以相同的方式进行分区，而且还基于相同的键进行排序，还可以使用另一种map端连接的变体。这种情况下，输入是否小到能放入内存并不重要，因为这时候Mapper同样可以执行归并操作：按键递增的顺序依次读取两个输入文件，将具有相同键的记录配对。如果能进行Map端合并连接，通常意味着前一个MR作业可能一开始已经把输入数据做了分区并进行排序。</p>
<h6 id="MR工作流与Map端连接"><a href="#MR工作流与Map端连接" class="headerlink" title="MR工作流与Map端连接"></a>MR工作流与Map端连接</h6><p>当下游作业使用MR连接的输出时，选择map端连接或reduce端连接会影响输出的结构，reduce端连接的输出是按照连接键进行分区和排序的，而map端连接的输出则按照与较大输入相同的方式进行分区和排序。（无论是使用分区连接还是广播连接，连接较大输入端的每个文件块都会启动一个map任务）</p>
<p><strong>Map端连接也对输入集的大小、有序性和分区做出了很多假设。在优化连接策略时，了解分布式文件系统中数据集的物理布局很重要，仅仅知道编码格式和数据存储目录是不够的，还必须知道数据是按哪些键做的分区和排序、以及分区的数量。</strong></p>
<h5 id="批处理工作流的输出"><a href="#批处理工作流的输出" class="headerlink" title="批处理工作流的输出"></a>批处理工作流的输出</h5><p>批处理不属于事务处理，也不是分析，批处理通常会扫过输入数据集绝大部分，输出的通常不是报表而是一些其他类型的结构。</p>
<ul>
<li>建立搜索引擎。google最初使用MR为其搜索引擎建索引，至今MR仍是为Lucene/Solr构建索引的好方法。如果索引文档集合发生改变，一种选择是定期重跑整个索引工作流，并在完成后用新的索引文件批量替换以前的索引文件。优点：文档进、索引出。另一种选择，增量建立索引，如果在索引中添加、删除、更新文档，lucene会写新的段文件，并在后台异步合并压缩段文件。</li>
<li>键值存储作为批处理输出。另一个用途是构建机器学习系统，比如分类器（垃圾邮件过滤、异常检测、图像识别）与推荐系统。</li>
</ul>
<h6 id="批处理输出的哲学"><a href="#批处理输出的哲学" class="headerlink" title="批处理输出的哲学"></a>批处理输出的哲学</h6><p>Unix哲学中鼓励以显示指明数据流的方式进行试验，程序读取输入并写入输出。这一过程中，输入保持不变，任何先前的输出都被新输出完全替换，没有其他副作用。</p>
<p>MR作业输出处理遵循同样的原理，通过将输入视为不可变且避免副作用，批处理作业不仅实现良好的性能，而且更容易维护：</p>
<ul>
<li>代码中引入了错误，输出错误，简单回滚到先前版本重新运行该作业即可。</li>
<li>由于回滚容易，这种最小化不可逆性的原则有利于敏捷软件开发。</li>
<li>如果Map或Reduce任务失败，MR框架会自动重新调度，并在同样的输入上再次运行。如果是代码错误，会在几次重试后失败。</li>
<li>同一组文件可用作各种不同作业的输入，包括计算指标的监控作业可以评估作业的输出。</li>
<li>与Unix类似，MR作业将逻辑与布线（配置输入和输出目录）分离，使得关注点分离，可以重用代码。</li>
</ul>
<h6 id="存储多样性"><a href="#存储多样性" class="headerlink" title="存储多样性"></a>存储多样性</h6><p>数据库要求根据特定的模型（关系或文档）来构造数据，而分布式文件系统中文件只是字节序列，可以使用任何数据模型和编码来编写，可以使记录的集合、文本、图像、视频、稀疏矩阵、特征向量。</p>
<p>Hadoop开放了将数据不加区分的存储到HDFS的可能性，允许后续进一步处理，相比将数据导入数据库专有存储格式前，MPP数据库通常需要对数据和查询模式进行仔细的前期建模。</p>
<p>Hadoop这种方式与数据仓库类似，将大型组织各个部分的数据集中在一起是很有价值的，可以跨越以前分离的数据集进行连接，mapp数据库要求的谨慎模式设计拖慢了集中式数据收集速度。以原始形式收集数据，再操心模式的设计，能使数据收集速度加快，有时也被称为数据湖data lake或企业数据中心。</p>
<h6 id="处理模型多样性"><a href="#处理模型多样性" class="headerlink" title="处理模型多样性"></a>处理模型多样性</h6><p>MPP数据库是单体的、紧密集成的软件，负责磁盘上的存储布局、查询计划、调度和执行。</p>
<p>另一方面，并非所有类型的处理都可以合理的表达为SQL查询，比如要构建机器学习、推荐系统或者使用相关性排名模型的全文搜索索引、或者图像分析，很可能需要更一般的数据处理模型。</p>
<p>针对直接使用MR的困难，MR上有很多高级编程模型被创造出来如Pig、Hive、Cascading、Crunch。但是MR执行模型本身也有一些问题，这些问题并没有通过增加另一个抽象层次而解决，对于某些类型的处理，表现的很差经。</p>
<ul>
<li>一方面，MR非常稳健，可以使用它在任务会频繁终止的多租户系统上处理几乎任意大量级的数据。</li>
<li>另外对于某些类型的处理而言1，其他工具有时会快几个数量级</li>
</ul>
<p>很多情况下，知道一个作业的输出只能用作另一个作业的输入，这些作业由一个团队维护，这种情况下，HDFS上的文件只是中间状态：一种将数据从一个作业传递到下一个作业的方式，一个构建推荐系统的作业可能由50-100个MR作业组成的复杂工作流，存在很多中间状态。将这个中间状态写入文件的过程称为物化，<strong>意味着对某个操作结果立即求职并写出来，而不是请求时按需计算。</strong>Unix管道讲一个命令的输出与另一个命令输入连接起来，管道并没有完全物化中间状态，而只是使用一个小的内存缓冲区，将输出增量地流向输出。</p>
<p>与Unix管道相比，MR完全物化中间状态的不足之处：</p>
<ul>
<li>MR只有在前驱作业所有任务完成才能启动，而unix管道连接的进行会同时启动，输出一旦生成就会被消费。不同机器上的数据倾斜会拖慢整个工作流的执行</li>
<li>Mapper通常是多余的，仅仅是读取刚刚由reducer写入的同样的文件，为下一个阶段的分区和排序做准备。许多情况下，Mapper可能是前驱reducer一部分，如果reducer和mapper输出有着相同的分区和排序方式，那么reducer就可以直接串在一起，而不用与mapper相互交织。</li>
<li>中间状态存储在HDFS中，意味着要复制到多个节点，完全没必要</li>
</ul>
<h6 id="数据流引擎"><a href="#数据流引擎" class="headerlink" title="数据流引擎"></a>数据流引擎</h6><p>为了解决MR这些问题，几种用于分布式批处理的新执行引擎被开发出来，spark、Tez、Flink，设计方式有很多区别，但是有一个共同点：把整个工作流作为单个作业来处理，而不是把它分解为独立子作业。</p>
<p>由于它们将工作流显示建模为数据从几个处理阶段穿过，所以这些系统被称为数据流引擎，<strong>像MR它们在一条线上通过反复调用用户定义的函数来处理记录，通过分区来并行化载荷，通过网络将一个函数的输出复制到另一个函数的输入。</strong></p>
<p>与MR不同，这些功能不需要严格扮演交织的Map与Reduce的角色，而是可以用更灵活的方式进行组合。<strong>称这些函数为算子operators，数据流引擎提供了几种不同的选项来将一个算子的输出连接到另一个算子的输入：</strong></p>
<ul>
<li>一种选项是对记录按键重新分区并排序，就像在MR的混洗阶段一样，这种功能可用于实现排序合并连接和分组，就像在MR中一样</li>
<li>另一种是接受多个输入，以相同方式进行分区，但跳过排序。当记录的分区重要但顺序无关紧要时，省去了分区散列连接的工作，因为构建散列表会把顺序随机打乱；</li>
<li>对于广播散列连接，可以将一个算子的输出发送到连接算子的所有分区；</li>
</ul>
<p>这种类型的处理引擎与MR模型相比，有几个优点：</p>
<ul>
<li>排序等昂贵的工作只需要在实际需要的地方执行，而不是默认在每个map和reduce阶段之间出现</li>
<li>没有不必要的map任务，因为Mapper所做的工作通常可以合并到前面的reduce算子中（因为Mapper不会更改数据集的分区）</li>
<li>由于工作流中所有连接和数据依赖都是显示声明的，因此调度程序能够纵览全局，知道哪里需要哪些数据，因而能够利用局部性进行优化。例如可以尝试将消费某些数据的任务放在与生成这些数据的任务的相同机器上，从而数据可以通过共享内存缓冲区传输，不必通过网络复制；</li>
<li>算子的中间状态足以保存在内存或写入本地磁盘，比写入HDFS需要更少的IO（复制到多台机器）。MR已经对Mapper的输出做了这种优化，但是数据流引擎将这种思想推广至所有的中间状态；</li>
<li>算子可以在输入就绪后立即开始执行；后续阶段无需等待前驱阶段整个完成再开始；</li>
<li>与MR（为每个任务启动一个新的jvm）相比，现有jvm进程可以重用来运行新算子，减少启动开销；</li>
</ul>
<p>可以使用数据流引擎执行与MR工作流同样的计算，由于所做的优化速度也会快很多；既然算子是Map和reduce的泛化，那么相同的处理代码可以在任一执行引擎上运行。</p>
<h6 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h6><p>完全物化中间状态是分布式文件系统的一个优点：具有持久性，使得MR的容错很容易，一个任务失败，可以在另一台机器上重启，并从文件系统重新读取相同的输入。spark、flink、tez避免将中间状态写入HDFS，采取了不同策略容错，如果一台机器发生故障，会从其他可用的数据重新计算。</p>
<p>为了实现这种重新计算，框架必须跟踪一个给定的数据是如何计算的–使用了哪些分区、应用哪些算子。spark使用弹性分布式数据集RDD的抽象来跟踪数据的谱系，flink对算子的状态存档，允许恢复运行在执行过程中遇到的错误算子。</p>
<p>在重新计算数据时，重要的是要知道计算是否是确定性的：<strong>给定相同的输入数据，算子是否始终产生相同的输出，如果一些丢失的数据已经发送给下游算子，这个问题就很重要。如果算子重新启动，重新计算的数据与原有的丢失数据不一致，下游算子很难解决新旧数据之间的矛盾。对于不确定的算子，解决方法：通常是杀死下游算子，再重跑新数据。</strong></p>
<p>为了避免这种级联故障，最好让算子具有确定性，非确定性行为如：迭代哈希表的元素时不能对顺序做出保证、许多概率和统计算法显示依赖于使用随机数，以及用到系统时钟或外部数据源，这些都是不确定行为。为了能可靠的从故障中恢复，需要消除这种不确定因素，比如使用固定种子生成伪随机数。</p>
<p>通过重计算数据来从故障中恢复并不总是正确的答案：如果中间状态数据比源数据小得多或者计算量非常大，那么中间数据物化为文件可能要比重新计算廉价的多。</p>
<h6 id="关于物化的讨论"><a href="#关于物化的讨论" class="headerlink" title="关于物化的讨论"></a>关于物化的讨论</h6><p>MR就像是将每个命令的输出写入临时文件，而数据流引擎更像是Unix管道，尤其Flink是基于管道执行的思想而建立的，即将算子的输出增量的传递给其他算子，不待输入完成就开始处理。</p>
<p>排序算子需要消费全部输入后才能生成任何输入，因为输入中最后一条输入记录可能具有最小的键，因此需要作为第一条记录输出。因此任何需要排序的算子都需要至少暂时的累计状态，工作流的许多其他部分都可以以流水线方式执行。</p>
<h6 id="图与迭代处理"><a href="#图与迭代处理" class="headerlink" title="图与迭代处理"></a>图与迭代处理</h6><p>批处理上下文的图很有趣，目标是在整个图上执行某种离线处理或分析。这种需求经常出现在机器学习应用或排序系统中。如最著名的图形分析算法之一的PageRank，试图根据链接到某个网页的其他网页来估计该网页的流行度，作为配方的一部分，用于确定网络搜索引擎呈现结果的排序。</p>
<p>像Spark、Flink、Tez这样的数据流引擎通常将算子作为有向无环图DAG的一部分安排在作业中，与图处理不一样：在数据流引擎中，从一个算子到另一个算子的数据流被构造成一个图，而数据本身通常由关系型元祖构成，在图处理中，数据本身具有图的形式。</p>
<p>许多图算法是通过一次遍历一条边来表示，将一个顶点与近邻的顶点连接起来，以传播一些信息不断重复，直到满足一些条件为止，如直到没有更多的边要跟进或直到一些指标收敛。比如重复跟进标明地点归属关系的边，生成数据库中北美包含的所有地点列表。（这种算法也被称为闭包传递）</p>
<p>可以在分布式文件系统中存储图（包含顶点和边的列表的文件），但是这种重复至完成的想法不能用MR表示，因为只扫过一趟数据，通常以迭代风格实现：</p>
<ul>
<li>外部调度程序运行批处理来计算算法的一个步骤</li>
<li>当批处理过程完成时，调度器检查它是否完成（基于完成条件，如没有更多的边要跟进，或与上次迭代相比的变化低于某个阈值）</li>
<li>如果尚未完成，则调度程序返回到步骤1运行另一轮批处理</li>
</ul>
<p>这种方法有效但是MR实现往往很低效，因为MR没考虑迭代性质：它总是读取整个输入数据集，即使与上次迭代相比改变的仅仅是图中一小部分。</p>
<h6 id="Pregel处理模型"><a href="#Pregel处理模型" class="headerlink" title="Pregel处理模型"></a>Pregel处理模型</h6><p>针对图批处理的优化—批量同步并行BSP计算模型已经开始流行起来，其中Apache Giraph、Spark的Graph X和Flink的Gelly API实现了它，也被称为Pregel模型，因为google的pregel论文推广了这种处理图的方法。</p>
<p>MR中，mapper在概念上向reducer的特定调用发送消息，因为框架将所有具有相同键的mapper输出集中在一起，Pregel后面有一个类似想法：<strong>一个顶点可以向另一个顶点发送消息，通常这些消息是沿着图的边发送的</strong></p>
<p>每次迭代中，为买个顶点调用一个函数，将所有发送给它的消息传递给它，就像调用reducer一样，与MR不同之处在于，在Pregel模型中，顶点在一次迭代到下一次迭代过程中会记住它的状态，所以这个函数只需要处理新的传入消息。如果图的某个部分没有被发送消息，那里就不需要做任何工作。</p>
<p>与Actor模型有些相似，除了顶点状态和顶点之间的消息具有容错性和耐久性，且通信以固定的方式进行：在每次迭代中，框架递送上次迭代中发送的所有消息，actor通常没有这样的时间保证。</p>
<h6 id="容错-1"><a href="#容错-1" class="headerlink" title="容错"></a>容错</h6><p>顶点只能通过消息传递有助于提高pregel作业的性能，因为消息可以批处理。唯一的等待是在迭代之间：由于pregel模型保证所有在一轮迭代中发送的消息都在下轮迭代中送达，所以在下一轮迭代开始前，先前的迭代必须完全完成，而所有消息必须在网络上完成复制。即使底层网络可能丢失、重复或任意延迟消息，pregel的实现能保证在后续迭代中，消息在其目标顶点恰好处理一次。即使底层网络可能丢失、重复、任意延迟，也能保证在后续迭代中消息在其目标顶点恰好处理一次。像MR一样，框架能从故障中透明的恢复，以简化在pregel上实现算法的编程模型。</p>
<p>这种容错通过在迭代结束，定期存档所有顶点状态实现，即将其全部状态写入持久化存储。如果某个节点发生故障且其内存中状态丢失，简单的解决方法是将整个图计算回滚到上一个存档点</p>
<h6 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h6><p>顶点不需要知道它在哪台物理机器上执行，当它向其他顶点发送消息时，只是简单将消息发往某个顶点ID。图的分区取决于框架，即哪个顶点运行在哪台机器上，以及如何通过网络路由消息。理想情况需要大量通信，最好能被分区到同一台机器上，实践中经常按照任意分配顶点ID分区，图算法通常会有跨机通信的额外开销，而中间状态往往比原始图大，通过网络发送消息的开销会显著拖慢分布式图算法速度。</p>
<h6 id="声明式查询语言"><a href="#声明式查询语言" class="headerlink" title="声明式查询语言"></a>声明式查询语言</h6><p>与硬写连接代码相比，指定连接关系算子的优点：框架可以分析连接输入的属性，并自动决定哪种上述连接算法最适合当前任务。甚至可以改变连接顺序，最小化中间状态的数量。</p>
<p>MR及其后继者数据流在其他方面与SQL的完全声明式查询模型有很大区别，MR是围绕着回调函数的概念产生的：对于每条记录或一组记录，调用一个用户定义的函数，并且该函数可以自由的调用任意代码来决定输出什么。优点：可以基于大量已有库的生态系统创作：解析、自然语言分析、图像分析以及运行数值算法或统计计算法。</p>
<p><strong>自由运行任意代码长期以来都是传统MR批处理系统与MPP数据库的区别所在。</strong>虽然数据库具有编写用户定义函数的功能，但是使用麻烦，而且与大多数编程语言中广泛使用的程序包管理器和依赖管理系统兼容不佳。（java的mvn js的npm ruby的gems）</p>
<p>数据流引擎支持除连接之外的更多声明特性还有其他优势，如果一个回调函数只包含一个简单过滤条件、或者只是从一条记录选择一些字段，那么在为每条记录调用函数时会有相当大CPU开销。如果以声明式方式表示这些简单的过滤和映射操作，那么查询优化器可以利用面向列的存储布局，只从磁盘读取所需的列。hive、spark dataframes和Impala还使用了向量化执行，在对cpu缓存友好的内部循环中迭代数据，避免函数调用。Spark生成jvm字节码，impala使用LLVM为这些内部循环生成本机代码。<br>通过在高级API引入声明式部分，批处理框架看起来越来越像MPP数据库了；同时通过拥有运行任意代码和以任意格式读取数据的可扩展性，保持了灵活性的优势。</p>
<h4 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h4><p>“流”是指随着时间推移可用的数据，这个概念出现在很多的地方：Unix的stdin、stdout，编程语言的惰性列表、文件系统API（如java的FileInputStream）、Tcp连接，通过互联网传递音频和视频。将事件流event stream视为一种数据管理机制：<strong>无界限 增量处理。</strong></p>
<p>发布/订阅模式中，不同系统采取各种各样方法，并没有针对所有的目的的通用答案：</p>
<ul>
<li>如果生产者发送消息的速度比消费者处理的速度快，有三种选择：系统丢掉消息，将消息放入缓冲队列或使用背压(backpressure)【也称为流量控制flow control】，即阻塞生产者，以免发送更多消息。例如Unix和TCP使用背压：它们有一个固定大小的小缓冲区，如果填满，发送者会被阻塞，直到接收者从缓冲区取出数据。</li>
<li>如果节点崩溃或暂时脱机，是否有消息丢失？与数据库一样，持久性可能需要写入磁盘/或复制的某种组合。如果能接受有时消息会丢失，则可能在同一硬件上获得更高的吞吐量和更低的延迟。</li>
</ul>
<p>直接从生产者传递给消费者（不通过中间节点）：</p>
<ul>
<li>UDP组播广泛用于金融行业，例如股票市场，其中低时延很重要，虽然UDP本身不可靠，但应用层协议可以恢复丢失的数据包</li>
<li>无代理的消息库，如ZeroMQ和nanomsg采取类似的方法，通过TCP或IP多播实现发布/订阅消息传递；</li>
<li>StatsD和Brubeck使用不可靠的UDP消息传递来收集网络中所有机器的指标并对其进行监控。</li>
<li>如果消费者在网络上公开了服务，生产者可以直接发送HTTP或RPC请求。</li>
</ul>
<p>尽管这些直接消息传递在设计它们的环境中运行良好，但是它们通常要求应用代码意识到消息丢失的可能性。容错程度极为有限：即使协议检测到并重传在网络中丢失的数据包，它们通常也只是假设生产者和消费者始终在线。如果消费者处于脱机状态，可能会丢失其不可达时发送的消息。</p>
<h6 id="消息代理"><a href="#消息代理" class="headerlink" title="消息代理"></a>消息代理</h6><p>一种广泛的替代方法是通过消息代理发送消息，消息代理实质上是一种针对处理消息流而优化的数据库。排队的结果是，消费者通常是异步的，会有一定的延迟。</p>
<p>周期性的完整数据转储过于缓慢，有时会使用双写double write，其中应用代码在数据变更时明确写入每个系统，例如先写入数据库，再更新搜索引擎，然后使缓存失效。双写会产生竞争条件。</p>
<h6 id="变更数据捕获"><a href="#变更数据捕获" class="headerlink" title="变更数据捕获"></a>变更数据捕获</h6><p>数十年来，许多数据库根本没有记录在档的，获取变更日志的方式。由于这个原因，捕获数据库中的所有变更，然后将其复制到其他存储引擎中（搜索索引、缓存、数据仓库）。</p>
<p>处理流以产生其它衍生流，处理这样的流的代码片段，被称为算法operator或作业job。数据流的模式是相似的：一个流出器以只读的方式使用输入流，并将其输出已追加的方式写入一个不同的位置。</p>
<p>流处理的应用，一直用于监控目的，如果某个事件发生，单位希望得到警报：</p>
<ul>
<li>欺诈检测</li>
<li>交易系统的价格变化</li>
<li>制造系统需要监控工厂机器的状态</li>
<li>军事和情报系统需要跟踪潜在的侵略者活动</li>
</ul>
<h6 id="流分析"><a href="#流分析" class="headerlink" title="流分析"></a>流分析</h6><p>使用流处理的另一个领域是对流进行分析，CEP(complex event and processing)符合事件处理与流分析的边界是模糊的，分析往往对找出特定事件序列并不关心，而更关注大量事件上的聚合和统计指标：</p>
<ul>
<li>测量某种类型事件的速率</li>
<li>滚动计算一段时间窗口内某个值得平均值</li>
<li>将当前统计值与先前的时间区间的值对比（如检测趋势 当指标与上周同比异常偏离或偏低时报警）</li>
</ul>
<p>这些统计值通常是在固定时间区间内进行计算的，如过去5min内服务每秒查询次数的均值，以及此时间段内响应时间的第99百分位点，<strong>有时系统会使用概率算法，如Bloom filter、HyperLogLog用于基数估计以及各种百分比估计算法。</strong>概率算法产出近似值的结果，比起精确算法的优点是内存使用要少得多。</p>
<h6 id="窗口的类型"><a href="#窗口的类型" class="headerlink" title="窗口的类型"></a>窗口的类型</h6><ul>
<li>滚动窗口Tumbling window。滚动窗口有着固定长度，比如10:00和10:05都会被分组到一个窗口</li>
<li>跳动窗口(Hopping Window)。跳动窗口也有着固定的长度，但允许窗口重叠以提供一些平滑。窗口之间有交叉。</li>
<li>滑动窗口。并不断从窗口移除过期的旧事件。</li>
<li>会话窗口。将同一用户出现时间相近的所有时间分组在一起。</li>
</ul>
<p>流式连接（窗口连接）：在流中搜索结果。<br>流表连接，如用户活动事件和用户档案数据库。表表连接。</p>
<h4 id="数据系统的未来"><a href="#数据系统的未来" class="headerlink" title="数据系统的未来"></a>数据系统的未来</h4><p>数据集成的目标，确保数据最终能在所有正确的地方表现出正确的形式。需要消费输入、转换、连接、过滤、聚合、训练模型、评估。批处理和流处理的输出是衍生数据集，例如搜索索引、物化视图，向用户显示的建议，聚合指标等等；</p>
<p>spark在批处理引擎上执行流处理，将流分解为微批次，flink则在流处理引擎上执行批处理。原则上一种类型的处理可以用另一种类型来模拟，但是性能特征会有所不同。</p>
<h5 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h5><p>Lambda架构的核心思想是通过将不可变事件附加到不断增长的数据集来记录传入数据，这类似于时间溯源。为了从这些事件中衍生出读取优化的视图，Lambda架构建议并行运行两个不同系统：批处理系统和独立的流处理系统。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/01/18/kotlin协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/kotlin协程/" itemprop="url">kotlin协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T22:18:36+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-协程基础"><a href="#1-协程基础" class="headerlink" title="1. 协程基础"></a>1. 协程基础</h4><h5 id="1-1-第一个coroutine程序"><a href="#1-1-第一个coroutine程序" class="headerlink" title="1.1 第一个coroutine程序"></a>1.1 第一个coroutine程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line">    GLobalScope.launch&#123;</span><br><span class="line">        delay(1000L) //后台建一个全局协程</span><br><span class="line">        println(&quot;world,&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)//主线程不会被delay阻塞</span><br><span class="line">    Thread.sleep(2000L)//阻塞主线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,</span><br><span class="line">world</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-将阻塞和非阻塞桥接起来"><a href="#1-2-将阻塞和非阻塞桥接起来" class="headerlink" title="1.2 将阻塞和非阻塞桥接起来"></a>1.2 将阻塞和非阻塞桥接起来</h5><p>上面一个示例将非阻塞方法(non-blocking)和阻塞方法Thread.sleep写在一个方法块中，很容易混淆哪一部分是阻塞，哪一部分不是阻塞。可以利用runblocking这种协程的builder使阻塞更加明确。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(vararg args: String) &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)//主线程立即执行</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        delay(2000L)//延迟2s，使jvm保持活跃</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果相同，但是这块代码只使用了非阻塞delay。主线程执行runBlocking，内部阻塞了协程，直到runblocking完成。<br>也可以使用更加符合语言习惯的写法，利用runBlocking包括主函数的执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt;&#123; //启动main协程</span><br><span class="line">    GLobalScope.launch&#123; //新建一个协程</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;) //主协程立即执行</span><br><span class="line">    delay(2000L) //延迟2s，使jvm保持活跃</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-3-等待一个job"><a href="#1-3-等待一个job" class="headerlink" title="1.3 等待一个job"></a>1.3 等待一个job</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch &#123; //新建一个协程</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)</span><br><span class="line">    job.join() //等到子协程完成 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-4-结构化并发"><a href="#1-4-结构化并发" class="headerlink" title="1.4 结构化并发"></a>1.4 结构化并发</h5><p>GlobalScope.launch是一个top-level协程，虽然是一个轻量级的，但是运行时仍然会消耗内存。如果创建太多，仍然会很消耗性能。<br>有一个更好的方法，就是在代码中结构化并发的代码。不在GlobalScope范围内新建协程，可以在一个明确范围内启动一个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; //CoroutineScope</span><br><span class="line">    launch &#123; //在runBlocking范围内新建一个协程</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;world&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;hello,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-5-Scope-builder"><a href="#1-5-Scope-builder" class="headerlink" title="1.5 Scope builder"></a>1.5 Scope builder</h5><p>除了不同的builder已经提供的协程范围，我们自己定义coroutineScope也是可以的。创建一个新的携程范围，直到所有子协程执行完毕，它才会结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; // this CoroutineScope</span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;first&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineScope &#123; //新建一个coroutine范围</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(500)</span><br><span class="line">            println(&quot;second&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        delay(100)</span><br><span class="line">        println(&quot;third&quot;) //嵌套的执行完，这一行才会输出</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;over&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-6-抽取阻塞的代码块"><a href="#1-6-抽取阻塞的代码块" class="headerlink" title="1.6 抽取阻塞的代码块"></a>1.6 抽取阻塞的代码块</h5><p>我们可以将launch{}代码块放进独立的方法，当你使用这种方式时，需要在重构的方法前面加上suspend，这种方法可以在协程内部调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doWorld() &#123;</span><br><span class="line">    delay(1000L)</span><br><span class="line">    println(&quot;World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>coroutine是更加轻量的，一个线程可以轻而易举创建上百万协程。速度比线程更快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&#123;</span><br><span class="line">    repeat(100_000)&#123;</span><br><span class="line">        launch&#123;</span><br><span class="line">            delay(1000)</span><br><span class="line">            print(.)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-7-global-coroutines就像是守护线程"><a href="#1-7-global-coroutines就像是守护线程" class="headerlink" title="1.7 global coroutines就像是守护线程"></a>1.7 global coroutines就像是守护线程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 回退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-协程的取消和超时"><a href="#2-协程的取消和超时" class="headerlink" title="2. 协程的取消和超时"></a>2. 协程的取消和超时</h4><h5 id="2-1-取消协程的执行"><a href="#2-1-取消协程的执行" class="headerlink" title="2.1 取消协程的执行"></a>2.1 取消协程的执行</h5><p>在一个运行时间很长的应用中，在运行完后，需要将任务取消掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        repeat(1000) &#123;</span><br><span class="line">            println(&quot;sleep $it&quot;)</span><br><span class="line">            delay(500)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(2300)</span><br><span class="line">    job.cancel() //将任务取消</span><br><span class="line">    job.join() //等待任务完毕</span><br><span class="line">    println(&quot;quit now&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-协程的取消应该是协作式的"><a href="#2-2-协程的取消应该是协作式的" class="headerlink" title="2.2 协程的取消应该是协作式的"></a>2.2 协程的取消应该是协作式的</h5><p>协程的取消应该是协作式的。所有suspend方法都是可以取消的。如果一个还在工作的协程被取消，那么它是不会被取消的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    //任务开始</span><br><span class="line">    val startTime = System.currentTimeMillis()</span><br><span class="line">    val job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        var nextPrintTime = startTime</span><br><span class="line">        var i = 0</span><br><span class="line">        while (i &lt; 5) &#123; // 执行一个计算逻辑</span><br><span class="line">            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;)</span><br><span class="line">                nextPrintTime += 500L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 延迟一会</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() //等待任务完成</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3-内置的isActive判断协程执行状态"><a href="#2-3-内置的isActive判断协程执行状态" class="headerlink" title="2.3 内置的isActive判断协程执行状态"></a>2.3 内置的isActive判断协程执行状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val startTime = System.currentTimeMillis()</span><br><span class="line">    val job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        var nextPrintTime = startTime</span><br><span class="line">        var i = 0</span><br><span class="line">        while (isActive) &#123; // cancellable computation loop</span><br><span class="line">            // print a message twice a second</span><br><span class="line">            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(&quot;I&apos;m sleeping $&#123;i++&#125; ...&quot;)</span><br><span class="line">                nextPrintTime += 500L</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4-finally取消任务"><a href="#2-4-finally取消任务" class="headerlink" title="2.4 finally取消任务"></a>2.4 finally取消任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">                delay(500L)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;I&apos;m running finally&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-NonCancellable使任务变为不可取消"><a href="#2-5-NonCancellable使任务变为不可取消" class="headerlink" title="2.5 NonCancellable使任务变为不可取消"></a>2.5 NonCancellable使任务变为不可取消</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">                delay(500L)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(&quot;I&apos;m running finally&quot;)</span><br><span class="line">                delay(1000L)</span><br><span class="line">                println(&quot;And I&apos;ve just delayed for 1 sec because I&apos;m non-cancellable&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // delay a bit</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancelAndJoin() // cancels the job and waits for its completion</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-6-超时"><a href="#2-6-超时" class="headerlink" title="2.6 超时"></a>2.6 超时</h5><p>给一个协程任务设置超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    withTimeout(1300L) &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会发现withTimeout会抛出timeoutCancellationException。我们可以使用try catch或者使用withTimeoutOrNull返回一个空值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val result = withTimeoutOrNull(1300L) &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;Done&quot; // will get cancelled before it produces this result</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Result is $result&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-编写suspend函数"><a href="#3-编写suspend函数" class="headerlink" title="3. 编写suspend函数"></a>3. 编写suspend函数</h4><h5 id="3-1-串行执行"><a href="#3-1-串行执行" class="headerlink" title="3.1 串行执行"></a>3.1 串行执行</h5><p>假设我们有两个suspend函数，需要两个协程按顺序执行。想要获得A函数和B函数的和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val time = measureTimeMillis&#123;</span><br><span class="line">        val sum1 = sum1()</span><br><span class="line">        val sum2 = sum2()</span><br><span class="line">        println(&quot;sum is $&#123;sum1+sum2&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;time cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun sum1():Int&#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 12</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum2():Int&#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-并发使用async"><a href="#2-2-并发使用async" class="headerlink" title="2.2 并发使用async"></a>2.2 并发使用async</h5><p>有些方法间是没有相关性的，想要更快的得到结果，可以使用async提高性能。async类似launch，也是一个轻量级的线程。不同点是launch返回一个job，async返回一个非阻塞的future。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val sum1 = async &#123; sum1() &#125;</span><br><span class="line">        val sum2 = async &#123; sum2() &#125;</span><br><span class="line">        println(&quot;sum is $&#123;sum1.await() + sum2.await()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;time cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum1(): Int &#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 12</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sum2(): Int &#123;</span><br><span class="line">    delay(1000)</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-3-延迟启动async"><a href="#2-3-延迟启动async" class="headerlink" title="2.3 延迟启动async"></a>2.3 延迟启动async</h5><p>可以设置async在调用start或async的时候，才执行async中的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        // some computation</span><br><span class="line">        one.start() // start the first one</span><br><span class="line">        two.start() // start the second one</span><br><span class="line">        println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here, too</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不调用start，和串行执行等价。</p>
<h5 id="2-4-异步执行的方法"><a href="#2-4-异步执行的方法" class="headerlink" title="2.4 异步执行的方法"></a>2.4 异步执行的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun somethingUsefulOneAsync() = GlobalScope.async &#123;</span><br><span class="line">    doSomethingUsefulOne()</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-用async结构化并发"><a href="#2-5-用async结构化并发" class="headerlink" title="2.5 用async结构化并发"></a>2.5 用async结构化并发</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        println(&quot;The answer is $&#123;concurrentSum()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br><span class="line">suspend fun concurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    val two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">     one.await() + two.await()</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // pretend we are doing something useful here, too</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的方法和exception结合在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        failedConcurrentSum()</span><br><span class="line">    &#125; catch(e: ArithmeticException) &#123;</span><br><span class="line">        println(&quot;Computation failed with ArithmeticException&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">suspend fun failedConcurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            delay(Long.MAX_VALUE) // Emulates very long computation</span><br><span class="line">            42</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;First child was cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val two = async&lt;Int&gt; &#123;</span><br><span class="line">        println(&quot;Second child throws an exception&quot;)</span><br><span class="line">        throw ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-协程的上下文和调度器"><a href="#3-协程的上下文和调度器" class="headerlink" title="3. 协程的上下文和调度器"></a>3. 协程的上下文和调度器</h4><h5 id="3-1-调度器和线程"><a href="#3-1-调度器和线程" class="headerlink" title="3.1 调度器和线程"></a>3.1 调度器和线程</h5><p>协程上下文包括了协程调度器，其决定了用哪个线程去执行。协程调度器限制了了指定线程去执行，由某个线程、线程池或无限制。<br>所有的协程builder像launch、async都会接受一个CoroutineContext的参数，这个参数可以明确的指定这个调度器为这个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch &#123; // context of the parent, main runBlocking coroutine</span><br><span class="line">        println(&quot;main runBlocking      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread</span><br><span class="line">        println(&quot;Unconfined            : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; // will get dispatched to DefaultDispatcher</span><br><span class="line">        println(&quot;Default               : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) &#123; // will get its own new thread</span><br><span class="line">        println(&quot;newSingleThreadContext: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>launch{…}</strong> 这种无参使用，默认集成启动的CoroutineScope的上下文，或者main函数的runBlocking。</p>
<p><strong>Dispatcher.Unconfined</strong> 是一个特殊的调度器，也会出现在main线程中。</p>
<p>默认的调度器<strong>default</strong>，当协程以GlobalScope方式启时， 而且以Dispatchers.Default表示，用的是共享的后台线程池，因此<strong>launch(Dispatchers.Default){…}</strong>用的是和GlobalScope.launch{…}的方式。</p>
<h5 id="3-2-约束性和非约束的调度"><a href="#3-2-约束性和非约束的调度" class="headerlink" title="3.2 约束性和非约束的调度"></a>3.2 约束性和非约束的调度</h5><p>非约束性调度器适合不消耗CPU、也不会更新共享数据的协程，这种协程会指定给特定的线程。约束性调度器在遇到第一个暂停点(suspend)之前，执行的都是调用者线程。遇到suspend函数后，用的是suspend方法决定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // not confined -- will work with main thread</span><br><span class="line">        println(&quot;Unconfined      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;Unconfined      : After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123; // context of the parent, main runBlocking coroutine</span><br><span class="line">        println(&quot;main runBlocking: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;main runBlocking: After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unconfined      : I&apos;m working in thread main [遇到delay前]</span><br><span class="line">main runBlocking: I&apos;m working in thread main</span><br><span class="line">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor [遇到delay后]</span><br><span class="line">main runBlocking: After delay in thread main</span><br></pre></td></tr></table></figure></p>
<h5 id="3-3-协程和线程的调试"><a href="#3-3-协程和线程的调试" class="headerlink" title="3.3 协程和线程的调试"></a>3.3 协程和线程的调试</h5><p>协程可以在一个线程中挂起，或者在另一线程中恢复。即使使用单线程调度程序，也很难确定协程何时、何地做了什么。<br>启动程序的时候加上：<strong>-Dkotlinx.coroutines.debug</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    val a = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing a piece of the answer&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    val b = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing another piece of the answer&quot;)</span><br><span class="line">        7</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer is $&#123;a.await() * b.await()&#125;&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#2] I&apos;m computing a piece of the answer</span><br><span class="line">[main @coroutine#3] I&apos;m computing another piece of the answer</span><br><span class="line">[main @coroutine#1] The answer is 42</span><br></pre></td></tr></table></figure></p>
<p>可以看出日志会输出线程名称、协程名称。</p>
<h5 id="3-4-在线程间跳跃"><a href="#3-4-在线程间跳跃" class="headerlink" title="3.4 在线程间跳跃"></a>3.4 在线程间跳跃</h5><p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    newSingleThreadContext(&quot;Ctx1&quot;).use &#123; ctx1 -&gt;</span><br><span class="line">        newSingleThreadContext(&quot;Ctx2&quot;).use &#123; ctx2 -&gt;</span><br><span class="line">            runBlocking(ctx1) &#123;</span><br><span class="line">                log(&quot;Started in ctx1&quot;)</span><br><span class="line">                withContext(ctx2) &#123;</span><br><span class="line">                    log(&quot;Working in ctx2&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">                log(&quot;Back to ctx1&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>展示了两种技术，一个是使用runBlocking给其指定上下文，另外一个就是使用withContext，改变一个协程的上下文，但是仍然在一个协程内。</p>
<h5 id="3-5-上下文中的job"><a href="#3-5-上下文中的job" class="headerlink" title="3.5 上下文中的job"></a>3.5 上下文中的job</h5><p>协程的job是上下文的一部分，协程可以使用coroutineContext。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    println(&quot;My job is $&#123;coroutineContext[Job]&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-6-协程的子协程"><a href="#3-6-协程的子协程" class="headerlink" title="3.6 协程的子协程"></a>3.6 协程的子协程</h5><p>当在另一个协程中的CoroutineScope中启动一个协程，它继承了其coroutineContext。当父协程取消，子协程也会被递归的取消。<br>当GlobalScope被用来启动一个协程，这种启动方式时独立启动,不被父协程影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    // launch a coroutine to process some kind of incoming request</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        // it spawns two other jobs, one with GlobalScope</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(&quot;job1: I run in GlobalScope and execute independently!&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job1: I am not affected by cancellation of the request&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        // and the other inherits the parent context</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            println(&quot;job2: I am a child of the request coroutine&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(500)</span><br><span class="line">    request.cancel() // cancel processing of the request</span><br><span class="line">    delay(1000) // delay a second to see what happens</span><br><span class="line">    println(&quot;main: Who has survived request cancellation?&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-7-父协程等待子协程"><a href="#3-7-父协程等待子协程" class="headerlink" title="3.7 父协程等待子协程"></a>3.7 父协程等待子协程</h5><p>父协程会等待所有子协程执行完毕，父协程不用显示的追踪子协程，也不用使用job.join，如果想要保证在job完成后执行某个逻辑，可以使用job.join。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // launch a coroutine to process some kind of incoming request</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        repeat(3) &#123; i -&gt; // launch a few children jobs</span><br><span class="line">            launch  &#123;</span><br><span class="line">                delay((i + 1) * 200L) // variable delay 200ms, 400ms, 600ms</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;request: I&apos;m done and I don&apos;t explicitly join my children that are still active&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    request.join() // wait for completion of the request, including all its children</span><br><span class="line">    println(&quot;Now processing of the request is complete&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-8-协程的命名"><a href="#3-8-协程的命名" class="headerlink" title="3.8 协程的命名"></a>3.8 协程的命名</h5><p>为了方便协程的追踪，也可以给协程命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking(CoroutineName(&quot;main&quot;)) &#123;</span><br><span class="line">    log(&quot;Started main coroutine&quot;)</span><br><span class="line">    // run two background value computations</span><br><span class="line">    val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) &#123;</span><br><span class="line">        delay(500)</span><br><span class="line">        log(&quot;Computing v1&quot;)</span><br><span class="line">        252</span><br><span class="line">    &#125;</span><br><span class="line">    val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        log(&quot;Computing v2&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer for v1 / v2 = $&#123;v1.await() / v2.await()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-9-将上下文连起来"><a href="#3-9-将上下文连起来" class="headerlink" title="3.9 将上下文连起来"></a>3.9 将上下文连起来</h5><p>有时我们需要为协程的上线定义很多成分，我们可以使用+符号。例如我们用一个显示指定的调度器和一个显示指定的名启动一个协程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Default + CoroutineName(&quot;test&quot;)) &#123;</span><br><span class="line">        println(&quot;I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-10-显示job的取消"><a href="#3-10-显示job的取消" class="headerlink" title="3.10 显示job的取消"></a>3.10 显示job的取消</h5><p>将上下文、子协程、任务综合在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Activity : CoroutineScope &#123;</span><br><span class="line">    lateinit var job: Job</span><br><span class="line"></span><br><span class="line">    fun create() &#123;</span><br><span class="line">        job = Job()</span><br><span class="line">    &#125;</span><br><span class="line">    fun destroy() &#123;</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    // to be continued ...</span><br><span class="line"></span><br><span class="line">    // class Activity continues</span><br><span class="line">    override val coroutineContext: CoroutineContext</span><br><span class="line">        get() = Dispatchers.Default + job</span><br><span class="line">    // to be continued ...</span><br><span class="line">    // class Activity continues</span><br><span class="line">    fun doSomething() &#123;</span><br><span class="line">        // launch ten coroutines for a demo, each working for a different time</span><br><span class="line">        repeat(10) &#123; i -&gt;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay((i + 1) * 200L) // variable delay 200ms, 400ms, ... etc</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // class Activity ends</span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    //sampleStart</span><br><span class="line">    val activity = Activity()</span><br><span class="line">    activity.create() // create an activity</span><br><span class="line">    activity.doSomething() // run test function</span><br><span class="line">    println(&quot;Launched coroutines&quot;)</span><br><span class="line">    delay(500L) // delay for half a second</span><br><span class="line">    println(&quot;Destroying activity!&quot;)</span><br><span class="line">    activity.destroy() // cancels all coroutines</span><br><span class="line">    delay(1000) // visually confirm that they don&apos;t work</span><br><span class="line">//sampleEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Launched coroutines</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Destroying activity!</span><br></pre></td></tr></table></figure></p>
<h5 id="3-11-Thread-local"><a href="#3-11-Thread-local" class="headerlink" title="3.11 Thread-local"></a>3.11 Thread-local</h5><p>多线程中有thread-local，但是对协程而言，并不和特定的线程绑定。<br>对于ThreadLocal，扩展方法asContextElement就是来解决这种问题的。它创建一个额外的上下文环境组件，每次协程切换上下文，将会恢复它的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val threadLocal = ThreadLocal&lt;String?&gt;() // declare thread-local variable</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">//sampleStart</span><br><span class="line">    threadLocal.set(&quot;main&quot;)</span><br><span class="line">    println(&quot;Pre-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">    val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = &quot;launch&quot;)) &#123;</span><br><span class="line">       println(&quot;Launch start, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">        yield()</span><br><span class="line">        println(&quot;After yield, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    println(&quot;Post-main, current thread: $&#123;Thread.currentThread()&#125;, thread local value: &apos;$&#123;threadLocal.get()&#125;&apos;&quot;)</span><br><span class="line">//sampleEnd    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，使用Dispatchers.Default新启动了一个协程，因此它在一个线程池里不同的线程中工作。使用了threadLocal.asContextElement(value=”launch”)不管协程怎么切换线程，输出结果都是不变的。<br>其中有一个关键的限制：当threadlocal是发生突变，一个新的值并不会传播到协程调用者，因为上下文不能跟踪所有的threadLocal对象访问，并且更新的值将会在下一个暂停点丢失，使用withContext去更新协程中的threadLocal.</p>
<h4 id="4-处理异常与监控"><a href="#4-处理异常与监控" class="headerlink" title="4. 处理异常与监控"></a>4. 处理异常与监控</h4><h5 id="4-1-异常的继承"><a href="#4-1-异常的继承" class="headerlink" title="4.1 异常的继承"></a>4.1 异常的继承</h5><p>协程构建有两种风格，自动继承（launch actor）或者将其暴露给用户（async produce）。前者将异常视为未处理，类似java中Thread.uncaughtExceptionHandler，后者依赖用户执行报错，比如去消费、调用。通过await或者receive的方式。</p>
<h5 id="4-2-取消和异常"><a href="#4-2-取消和异常" class="headerlink" title="4.2 取消和异常"></a>4.2 取消和异常</h5><p>取消和异常严格绑定在一起的，协程中使用cancellationException处理cancellation。这些异常可以被handler忽略。可以通过catch块捕获。</p>
<h5 id="4-3-异常聚合"><a href="#4-3-异常聚合" class="headerlink" title="4.3 异常聚合"></a>4.3 异常聚合</h5><p>多个子协程都抛错，第一个异常将会被捕获。这样可能会导致丢失一些异常，例如一个协程在finally中抛异常，但是额外的异常被抑制了。</p>
<h5 id="4-4-监控"><a href="#4-4-监控" class="headerlink" title="4.4 监控"></a>4.4 监控</h5><p>取消是协程层次结构传播的双向关系，如果需要单向取消，该如何处理。<br>很好的示例是一个服务器进程，生成多个子作业，并且需要监视他们的执行、跟踪故障，并重新启动已经失败的子作业。</p>
<h5 id="4-5-监控范围"><a href="#4-5-监控范围" class="headerlink" title="4.5 监控范围"></a>4.5 监控范围</h5><p>对于作用域的并发，可以使用supervisorScope代替coroutineScope。只是单向传播取消，只有主进程失败，所有子协程才会被取消。</p>
<h4 id="5-channel"><a href="#5-channel" class="headerlink" title="5. channel"></a>5. channel</h4><p>deferred values（延迟值）提供了一种方便的方式在协程间传递单个的值。channels提供一种传输流的方法。</p>
<h5 id="5-1-channel基础概念"><a href="#5-1-channel基础概念" class="headerlink" title="5.1 channel基础概念"></a>5.1 channel基础概念</h5><p>channel和blockingQueue非常像，一个关键的不同点是：suspend -&gt; put，suspend receive -&gt; take</p>
<h5 id="5-2-channel的关闭和迭代"><a href="#5-2-channel的关闭和迭代" class="headerlink" title="5.2 channel的关闭和迭代"></a>5.2 channel的关闭和迭代</h5><p>和队列不同，通道的关闭表明没有更多的元素。receiver端，可以使用for循环从channel中取元素。<br>channel的关闭就像是给channel发送一个特殊的token，表示channel已经关闭了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;Int&gt;()</span><br><span class="line">    launch &#123;</span><br><span class="line">        for (x in 1..5) channel.send(x * x)</span><br><span class="line">        channel.close() // we&apos;re done sending</span><br><span class="line">    &#125;</span><br><span class="line">    // here we print received values using `for` loop (until the channel is closed)</span><br><span class="line">    for (y in channel) println(y)</span><br><span class="line">    println(&quot;Done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-3-build一个channel的producer"><a href="#5-3-build一个channel的producer" class="headerlink" title="5.3 build一个channel的producer"></a>5.3 build一个channel的producer</h5><p>并发场景中的生产/消费模式，下面就抽象出一个producer模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.produceSquares(): ReceiveChannel&lt;Int&gt; = produce &#123;</span><br><span class="line">    for (x in 1..5) send(x * x)</span><br><span class="line">&#125;</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val squares = produceSquares()</span><br><span class="line">    squares.consumeEach &#123; println(it) &#125;</span><br><span class="line">    println(&quot;Done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-4-pipelines"><a href="#5-4-pipelines" class="headerlink" title="5.4 pipelines"></a>5.4 pipelines</h5><p>pipeline是一种协程生产的模式，可能是无限的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val numbers = produceNumbers() // produces integers from 1 and on</span><br><span class="line">    val squares = square(numbers) // squares integers</span><br><span class="line">    for (i in 1..5) println(squares.receive()) // print first five</span><br><span class="line">    println(&quot;Done!&quot;) // we are done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; &#123;</span><br><span class="line">    var x = 1</span><br><span class="line">    while (true) send(x++) // infinite stream of integers starting from 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.square(numbers: ReceiveChannel&lt;Int&gt;): ReceiveChannel&lt;Int&gt; = produce &#123;</span><br><span class="line">    for (x in numbers) send(x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比如有一个流水线过滤器，对生产的数字进行一系列处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbersFrom(2) -&gt; filter(2) -&gt; filter(3) -&gt; filter(5) -&gt; filter(7) ...</span><br></pre></td></tr></table></figure></p>
<p>比如有一个过滤器的流水线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    var cur = numbersFrom(2)</span><br><span class="line">    for (i in 1..10) &#123;</span><br><span class="line">        val prime = cur.receive()</span><br><span class="line">        println(prime)</span><br><span class="line">        cur = filter(cur, prime)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel all children to let main finish</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.numbersFrom(start: Int) = produce &#123;</span><br><span class="line">    var x = start</span><br><span class="line">    while (true) send(x++) // infinite stream of integers from start</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.filter(numbers: ReceiveChannel&lt;Int&gt;, prime: Int) = produce &#123;</span><br><span class="line">    for (x in numbers) if (x % prime != 0) send(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流水线也可以使用标准库中的buildIterator，yield代替send，next代替receive，Iterator代替ReceiveChannel，去掉coroutine scope，不需要使用runBlocking。</p>
<h5 id="5-5-fan-out-单生产-gt-多消费模式"><a href="#5-5-fan-out-单生产-gt-多消费模式" class="headerlink" title="5.5 fan-out 单生产-&gt;多消费模式"></a>5.5 fan-out 单生产-&gt;多消费模式</h5><p>代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val producer = produceNumbers()</span><br><span class="line">    repeat(5) &#123; launchProcessor(it, producer) &#125;</span><br><span class="line">    delay(950)</span><br><span class="line">    producer.cancel() // cancel producer coroutine and thus kill them all</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.produceNumbers() = produce &#123;</span><br><span class="line">    var x = 1 // start from 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        send(x++) // produce next</span><br><span class="line">        delay(100) // wait 0.1s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch &#123;</span><br><span class="line">    for (msg in channel) &#123;</span><br><span class="line">        println(&quot;Processor #$id received $msg&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种模式下不像<strong>consumeEach</strong>，这种for循环的使用完全是线程安全的。如果其中一个processor失败，其他的协程会继续处理。然而通过consumeEach编写的的处理器在正常、异常完成时总是消费底层channel。</p>
<h5 id="5-6-多生产-gt-单消费"><a href="#5-6-多生产-gt-单消费" class="headerlink" title="5.6 多生产-&gt;单消费"></a>5.6 多生产-&gt;单消费</h5><p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;String&gt;()</span><br><span class="line">    launch &#123; sendString(channel, &quot;foo&quot;, 200L) &#125;</span><br><span class="line">    launch &#123; sendString(channel, &quot;BAR!&quot;, 500L) &#125;</span><br><span class="line">    repeat(6) &#123; // receive first six</span><br><span class="line">        println(channel.receive())</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel all children to let main finish</span><br><span class="line">&#125;</span><br><span class="line">suspend fun sendString(channel: SendChannel&lt;String&gt;, s: String, time: Long) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        delay(time)</span><br><span class="line">        channel.send(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-7-缓冲通道-buffered-channel"><a href="#5-7-缓冲通道-buffered-channel" class="headerlink" title="5.7 缓冲通道[buffered channel]"></a>5.7 缓冲通道[buffered channel]</h5><p>上面介绍的channel都没有缓冲区，发送方、接收方相遇时，未缓冲通道会传输元素。如果先调用send，则会挂起，直到receive执行；如果先调用receive，则其也会挂起，直到调用send。</p>
<p>channel facotry和producer都可以选择一个参数来指定缓冲区大小。缓冲区允许发送方挂起前发送多个元素，类似指定容量的BlockingQueue，缓冲区满的时候会被阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val channel = Channel&lt;Int&gt;(10) // create buffered channel</span><br><span class="line">    val sender = launch &#123; // launch sender coroutine</span><br><span class="line">        repeat(10) &#123;</span><br><span class="line">            println(&quot;Sending $it&quot;) // print before sending each element</span><br><span class="line">            channel.send(it) // will suspend when buffer is full</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // don&apos;t receive anything... just wait....</span><br><span class="line">    delay(1000)</span><br><span class="line">    sender.cancel() // cancel sender coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-8-channels是公平的"><a href="#5-8-channels是公平的" class="headerlink" title="5.8 channels是公平的"></a>5.8 channels是公平的</h5><p>对通道的send和receive操作对于多个协程调用顺序是公平的,以先进先出的顺序提供。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val table = Channel&lt;Ball&gt;() // a shared table</span><br><span class="line">    launch &#123; player(&quot;ping&quot;, table) &#125;</span><br><span class="line">    launch &#123; player(&quot;pong&quot;, table) &#125;</span><br><span class="line">    table.send(Ball(0)) // serve the ball</span><br><span class="line">    delay(1000) // delay 1 second</span><br><span class="line">    coroutineContext.cancelChildren() // game over, cancel them</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun player(name: String, table: Channel&lt;Ball&gt;) &#123;</span><br><span class="line">    for (ball in table) &#123; // receive the ball in a loop</span><br><span class="line">        ball.hits++</span><br><span class="line">        println(&quot;$name $ball&quot;)</span><br><span class="line">        delay(300) // wait a bit</span><br><span class="line">        table.send(ball) // send the ball back</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-9-ticker信道"><a href="#5-9-ticker信道" class="headerlink" title="5.9 ticker信道"></a>5.9 ticker信道</h5><p>ticker信道是一种特殊的集合信道，从上次从通道中消费后，在指定的延迟，会返回一个Unit。虽然这种方式看起来像一种无用的、独立的，但是它是创建复杂的基于时间的生产pipepiles和其他基于窗口和时间独立的处理进程。ticker channel</p>
<h4 id="6-共享可变状态和并发性"><a href="#6-共享可变状态和并发性" class="headerlink" title="6 共享可变状态和并发性"></a>6 共享可变状态和并发性</h4><p>协程也可以在多线程中运行，所以也会产生并发性问题。主要问题是访问共享可变状态的同步，在协程中，有些解决方案和多线程领域类似，但有些是独一无二。</p>
<h5 id="6-1-细粒度线程限制"><a href="#6-1-细粒度线程限制" class="headerlink" title="6.1 细粒度线程限制"></a>6.1 细粒度线程限制</h5><p>线程限制指接触到共享变量的地方都用一个线程访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val counterContext = newSingleThreadContext(&quot;CounterContext&quot;)</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.massiveRun &#123; // run each coroutine with DefaultDispathcer</span><br><span class="line">        withContext(counterContext) &#123; // but confine each increment to the single-threaded context</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码非常慢，因为其执行细粒度线程限制，每次做加法，都会从多线程调度器切换，默认使用withContext切换到单线程上下文。</p>
<h5 id="6-2-粗粒度线程限制"><a href="#6-2-粗粒度线程限制" class="headerlink" title="6.2 粗粒度线程限制"></a>6.2 粗粒度线程限制</h5><p>实际运用中，线程限制以大块执行的。比如，状态更新的业务逻辑被限制当个线程中。下面的示例就是这么做的，在单线程上下文运行每个协程，使用coroutineScope.相比上个例子，性能提升很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val counterContext = newSingleThreadContext(&quot;CounterContext&quot;)</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    CoroutineScope(counterContext).massiveRun &#123; // run each coroutine in the single-threaded context</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-3-使用互斥访问"><a href="#6-3-使用互斥访问" class="headerlink" title="6.3 使用互斥访问"></a>6.3 使用互斥访问</h5><p>互斥解决方案是保护共享状态的修改，关键部分不会并发执行。多线程中，通常会使用synchronized或reentrantlock，coroutine中另一个选择是mutex。具有加锁、解锁来执行关键部分。mutex.lock是一个挂起函数，不会阻塞线程。加锁的方式也是细粒度的。在某些场景中，你需要周期性修改共享变量，但是没有任何天然的线程限制这种状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line">val mutex = Mutex()</span><br><span class="line">var counter = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    GlobalScope.massiveRun &#123;</span><br><span class="line">        mutex.withLock &#123;</span><br><span class="line">            counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Counter = $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-4-actor模型"><a href="#6-4-actor模型" class="headerlink" title="6.4 actor模型"></a>6.4 actor模型</h5><p>actor是一个实体，由一个协程、和被限制并封装在这个协程中的状态，也是一个channel，和其他协程通信。一个简单的actor，可以是一个函数，如果有更复杂的状态，一个类更适合。<br>一个actor协程builder，可以很方便的将actor的信箱组合到其作用域，用来接收消息，并将发送通道组合到生成的作业对象中，这样可以将对actor的单个引用作为句柄携带。<br>第一步是定义actor要处理的消息类。kotlin中sealed class非常适合这个场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Message types for counterActor</span><br><span class="line">sealed class CounterMsg</span><br><span class="line">object IncCounter : CounterMsg() // one-way message to increment counter</span><br><span class="line">class GetCounter(val response: CompletableDeferred&lt;Int&gt;) : CounterMsg() // a request with reply</span><br><span class="line"></span><br><span class="line">// This function launches a new counter actor</span><br><span class="line">fun CoroutineScope.counterActor() = actor&lt;CounterMsg&gt; &#123;</span><br><span class="line">    var counter = 0 // actor state</span><br><span class="line">    for (msg in channel) &#123; // iterate over incoming messages</span><br><span class="line">        when (msg) &#123;</span><br><span class="line">            is IncCounter -&gt; counter++</span><br><span class="line">            is GetCounter -&gt; msg.response.complete(counter)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val counter = counterActor() // create the actor</span><br><span class="line">    GlobalScope.massiveRun &#123;</span><br><span class="line">        counter.send(IncCounter)</span><br><span class="line">    &#125;</span><br><span class="line">    // send a message to get a counter value from an actor</span><br><span class="line">    val response = CompletableDeferred&lt;Int&gt;()</span><br><span class="line">    counter.send(GetCounter(response))</span><br><span class="line">    println(&quot;Counter = $&#123;response.await()&#125;&quot;)</span><br><span class="line">    counter.close() // shutdown the actor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>actor在什么上下文中执行并不重要，actor就是一个协程，按照顺序执行。因此将状态限制到指定的协程可以解决共享可变状态的问题。</p>
<h4 id="7-选择表达式"><a href="#7-选择表达式" class="headerlink" title="7. 选择表达式"></a>7. 选择表达式</h4><p>选择表达式可以同时等待多个挂起函数，并选择第一个可用的函数。<br>选择表达式是kotlinx.coroutines的一个实验特性。其中的API在接下来的版本中，可能会有比较大的改变。</p>
<h5 id="7-1-从channel中选择"><a href="#7-1-从channel中选择" class="headerlink" title="7.1 从channel中选择"></a>7.1 从channel中选择</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">suspend fun CoroutineScope.massiveRun(action: suspend () -&gt; Unit) &#123;</span><br><span class="line">    val n = 100  // number of coroutines to launch</span><br><span class="line">    val k = 1000 // times an action is repeated by each coroutine</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val jobs = List(n) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                repeat(k) &#123; action() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jobs.forEach &#123; it.join() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed $&#123;n * k&#125; actions in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.fizz() = produce &#123;</span><br><span class="line">    while (true) &#123; // sends &quot;Fizz&quot; every 300 ms</span><br><span class="line">        delay(300)</span><br><span class="line">        send(&quot;Fizz&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.buzz() = produce &#123;</span><br><span class="line">    while (true) &#123; // sends &quot;Buzz!&quot; every 500 ms</span><br><span class="line">        delay(500)</span><br><span class="line">        send(&quot;Buzz!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">suspend fun selectFizzBuzz(fizz: ReceiveChannel&lt;String&gt;, buzz: ReceiveChannel&lt;String&gt;) &#123;</span><br><span class="line">    select&lt;Unit&gt; &#123; // &lt;Unit&gt; means that this select expression does not produce any result</span><br><span class="line">        fizz.onReceive &#123; value -&gt;  // this is the first select clause</span><br><span class="line">            println(&quot;fizz -&gt; &apos;$value&apos;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        buzz.onReceive &#123; value -&gt;  // this is the second select clause</span><br><span class="line">            println(&quot;buzz -&gt; &apos;$value&apos;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val fizz = fizz()</span><br><span class="line">    val buzz = buzz()</span><br><span class="line">    repeat(7) &#123;</span><br><span class="line">        selectFizzBuzz(fizz, buzz)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren() // cancel fizz &amp; buzz coroutines</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-2-通道关闭"><a href="#7-2-通道关闭" class="headerlink" title="7.2 通道关闭"></a>7.2 通道关闭</h5><p>当通道关闭时，select中onReceive会失败，导致相应select发生异常；当通道关闭时，可以使用onReceiveOrNull执行特定操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">suspend fun selectAorB(a: ReceiveChannel&lt;String&gt;, b: ReceiveChannel&lt;String&gt;): String =</span><br><span class="line">        select &#123;</span><br><span class="line">            a.onReceiveOrNull &#123; value -&gt;</span><br><span class="line">                if (value == null)</span><br><span class="line">                    &quot;Channel &apos;a&apos; is closed&quot;</span><br><span class="line">                else</span><br><span class="line">                    &quot;a -&gt; &apos;$value&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            b.onReceiveOrNull &#123; value -&gt;</span><br><span class="line">                if (value == null)</span><br><span class="line">                    &quot;Channel &apos;b&apos; is closed&quot;</span><br><span class="line">                else</span><br><span class="line">                    &quot;b -&gt; &apos;$value&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val a = produce &#123;</span><br><span class="line">        repeat(4) &#123; send(&quot;Hello $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val b = produce &#123;</span><br><span class="line">        repeat(4) &#123; send(&quot;World $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(8) &#123; // print first eight results</span><br><span class="line">        println(selectAorB(a, b))</span><br><span class="line">    &#125;</span><br><span class="line">    coroutineContext.cancelChildren()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>select偏向于第一个子句，当多个子句可以选择时，其中第一个子句将会被选择。当channel关闭时，onReceiveOrNull会立马得到响应。</p>
<h5 id="7-3-选择发送"><a href="#7-3-选择发送" class="headerlink" title="7.3 选择发送"></a>7.3 选择发送</h5><p>select的onSend表达式，可以结合有偏向的特性使用。<br>下面的例子是，通道消费者无法跟上生成速度，会把值发送到一个侧通道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.produceNumbers(side: SendChannel&lt;Int&gt;) = produce&lt;Int&gt; &#123;</span><br><span class="line">    for (num in 1..10) &#123; // produce 10 numbers from 1 to 10</span><br><span class="line">        delay(100) // every 100 ms</span><br><span class="line">        select&lt;Unit&gt; &#123;</span><br><span class="line">            onSend(num) &#123;&#125; // Send to the primary channel</span><br><span class="line">            side.onSend(num) &#123;&#125; // or to the side channel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val side = Channel&lt;Int&gt;() // allocate side channel</span><br><span class="line">    launch &#123; // this is a very fast consumer for the side channel</span><br><span class="line">        side.consumeEach &#123; println(&quot;Side channel has $it&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    produceNumbers(side).consumeEach &#123;</span><br><span class="line">        println(&quot;Consuming $it&quot;)</span><br><span class="line">        delay(250) // let us digest the consumed number properly, do not hurry</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Done consuming&quot;)</span><br><span class="line">    coroutineContext.cancelChildren()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-4-选择延迟的值（deferred-value）"><a href="#7-4-选择延迟的值（deferred-value）" class="headerlink" title="7.4 选择延迟的值（deferred value）"></a>7.4 选择延迟的值（deferred value）</h5><p>延迟的值可以使用onAwait接收到。以下例子说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun CoroutineScope.asyncString(time: Int) = async &#123;</span><br><span class="line">    delay(time.toLong())</span><br><span class="line">    &quot;Waited for $time ms&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun CoroutineScope.asyncStringsList(): List&lt;Deferred&lt;String&gt;&gt; &#123;</span><br><span class="line">    val random = Random(3)</span><br><span class="line">    return List(12) &#123; asyncString(random.nextInt(1000)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val list = asyncStringsList()</span><br><span class="line">    val result = select&lt;String&gt; &#123;</span><br><span class="line">        list.withIndex().forEach &#123; (index, deferred) -&gt;</span><br><span class="line">            deferred.onAwait &#123; answer -&gt;</span><br><span class="line">                &quot;Deferred $index produced answer &apos;$answer&apos;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">    val countActive = list.count &#123; it.isActive &#125;</span><br><span class="line">    println(&quot;$countActive coroutines are still active&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数等待第一个函数完成，并计算仍处于活跃状态的延迟值的数量。select是kotlin的一个kotlin dsl表达式，可以使用任意代码为其提供子句，这种情况下，迭代一个延迟值列表，为每个延迟值提供onWait子句。</p>
<h5 id="7-5-切换延迟值的通道"><a href="#7-5-切换延迟值的通道" class="headerlink" title="7.5 切换延迟值的通道"></a>7.5 切换延迟值的通道</h5><p>例子是producer会消费通道中的延迟值，等待每个接收到的延迟值，直到下一个值到来，或者通道关闭。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@ExperimentalCoroutinesApi</span><br><span class="line">fun CoroutineScope.switchMapDeferreds(input: ReceiveChannel&lt;Deferred&lt;String&gt;&gt;) = produce &#123;</span><br><span class="line">    var current = input.receive() // start with first received deferred value</span><br><span class="line">    while (isActive) &#123; // loop while not cancelled/closed</span><br><span class="line">        val next = select&lt;Deferred&lt;String&gt;?&gt; &#123; // return next deferred value from this select or null</span><br><span class="line">            input.onReceiveOrNull &#123; update -&gt;</span><br><span class="line">                update // replaces next value to wait</span><br><span class="line">            &#125;</span><br><span class="line">            current.onAwait &#123; value -&gt;</span><br><span class="line">                send(value) // send value that current deferred has produced</span><br><span class="line">                input.receiveOrNull() // and use the next deferred from the input channel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            println(&quot;Channel was closed&quot;)</span><br><span class="line">            break // out of loop</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            current = next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun CoroutineScope.asyncString(str: String, time: Long) = async &#123;</span><br><span class="line">    delay(time)</span><br><span class="line">    str</span><br><span class="line">&#125;</span><br><span class="line">@ExperimentalCoroutinesApi</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val chan = Channel&lt;Deferred&lt;String&gt;&gt;() // the channel for test</span><br><span class="line">    launch &#123; // launch printing coroutine</span><br><span class="line">        for (s in switchMapDeferreds(chan))</span><br><span class="line">            println(s) // print each received string</span><br><span class="line">    &#125;</span><br><span class="line">    chan.send(asyncString(&quot;BEGIN&quot;, 100))</span><br><span class="line">    delay(200) // enough time for &quot;BEGIN&quot; to be produced</span><br><span class="line">    chan.send(asyncString(&quot;Slow&quot;, 500))</span><br><span class="line">    delay(100) // not enough time to produce slow</span><br><span class="line">    chan.send(asyncString(&quot;Replace&quot;, 100))</span><br><span class="line">    delay(500) // give it time before the last one</span><br><span class="line">    chan.send(asyncString(&quot;END&quot;, 500))</span><br><span class="line">    delay(1000) // give it time to process</span><br><span class="line">    chan.close() // close the channel ...</span><br><span class="line">    delay(500) // and wait some time to let it finish</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/11/29/gradle使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/gradle使用/" itemprop="url">gradle使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T21:08:26+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="常见规则语法"><a href="#常见规则语法" class="headerlink" title="常见规则语法"></a>常见规则语法</h4><h5 id="1-1-buildscript"><a href="#1-1-buildscript" class="headerlink" title="1.1 buildscript"></a>1.1 buildscript</h5><p>这个语法常常会在项目根目录的build.gradle中出现。</p>
<blockquote>
<p>这个声明是gradle自身所需要的资源，如maven仓库地址、依赖项、第三方插件。执行脚本时，会优先执行buildscript代码块中的内容，然后执行剩下的内容。</p>
</blockquote>
<p>如下使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = &apos;1.2.51&apos;</span><br><span class="line">    ext.slf4j_version = &apos;1.7.25&apos;</span><br><span class="line">    ext.testng_version = &apos;6.9.6&apos;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/nexus/content/repositories/central/&apos; &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-2-ext"><a href="#1-2-ext" class="headerlink" title="1.2 ext"></a>1.2 ext</h5><p>定义全局变量<br><br>使用方法1：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ext&#123;</span><br><span class="line">    kotlin_version = 1.2.61</span><br><span class="line">    targetVersion = 1.8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext.kotlin_version = &apos;1.2.51&apos;</span><br><span class="line">ext.slf4j_version = &apos;1.7.25&apos;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-3-classpath"><a href="#1-3-classpath" class="headerlink" title="1.3 classpath"></a>1.3 classpath</h5><p>build.gradle中buildscript下面有classpath 码块中你可以对dependencies使用classpath声明。</p>
<h5 id="1-4-调整gradle编译参数"><a href="#1-4-调整gradle编译参数" class="headerlink" title="1.4 调整gradle编译参数"></a>1.4 调整gradle编译参数</h5><p>配置gradle.properties<br><br>配置最大内存</p>
<blockquote>
<p>org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=1024m</p>
</blockquote>
<p>守护进程：</p>
<blockquote>
<p>org.gradle.daemon=true</p>
</blockquote>
<p>并行编译：</p>
<blockquote>
<p>org.gradle.parallel=true</p>
</blockquote>
<p>开启缓存：</p>
<blockquote>
<p>android.enableBuildCache=true</p>
</blockquote>
<h5 id="1-5-死库写法不推荐"><a href="#1-5-死库写法不推荐" class="headerlink" title="1.5 死库写法不推荐"></a>1.5 死库写法不推荐</h5><blockquote>
<p>dependencies{<br>    compile ‘com.google.grpc:1.2+’<br>}</p>
</blockquote>
<p>虽然可以保证每次库都是最新的，也会带来如下问题：</p>
<ul>
<li>build网络检查 速度慢</li>
<li>库更新带来bug</li>
<li>开发者得到不同版本的包<br>推荐写为固定版本</li>
</ul>
<h5 id="1-6-全局设定编码"><a href="#1-6-全局设定编码" class="headerlink" title="1.6 全局设定编码"></a>1.6 全局设定编码</h5><blockquote>
<p>allprojects{<br>    repositories{<br>        MavenCenter()<br>    }<br>}</p>
</blockquote>
<h5 id="1-7-依赖其他module和jar"><a href="#1-7-依赖其他module和jar" class="headerlink" title="1.7 依赖其他module和jar"></a>1.7 依赖其他module和jar</h5><blockquote>
<p>dependencies{<br>    compile project(‘module1’)<br>    compile files(‘libs/commons.jar’)<br>}</p>
</blockquote>
<h5 id="1-8-exclude关键字"><a href="#1-8-exclude关键字" class="headerlink" title="1.8 exclude关键字"></a>1.8 exclude关键字</h5><p>剔除一些组织库<br></p>
<blockquote>
<p>compile(‘com.google.avg’){<br>    exclude group: ‘com.google.avg.util’ //组织名称<br>}</p>
</blockquote>
<p>剔除某个库：</p>
<blockquote>
<p>compile(‘com.android.support:appcompat-v7:23.2.0’) {<br>    exclude group: ‘com.android.support’, module: ‘support-annotations’ // 写全称<br>    exclude group: ‘com.android.support’, module: ‘support-compat’<br>}</p>
</blockquote>
<h5 id="1-9-subprojects"><a href="#1-9-subprojects" class="headerlink" title="1.9 subprojects"></a>1.9 subprojects</h5><p>多模块项目之间有重复的配置，可以使用这个配置</p>
<blockquote>
</blockquote>
<p>subprojects {</p>
<pre><code>version &apos;1.0.0-SNAPSHOT&apos;
group &apos;hcyxy.tech&apos;

apply plugin: &apos;idea&apos;
apply plugin: &apos;java&apos;
apply plugin: &apos;kotlin&apos;

sourceCompatibility = 1.8

compileKotlin {
    kotlinOptions.jvmTarget = &quot;1.8&quot;
}
compileTestKotlin {
    kotlinOptions.jvmTarget = &quot;1.8&quot;
}


repositories {
    mavenLocal()
    mavenCenter()
}

dependencies {

    testCompile &quot;org.testng:testng:${testng_version}&quot;

    //kotlin
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version&quot;

    //log4j
    compile group: &apos;org.apache.logging.log4j&apos;, name: &apos;log4j-api&apos;, version: &apos;2.8&apos;
    compile group: &apos;org.apache.logging.log4j&apos;, name: &apos;log4j-core&apos;, version: &apos;2.8&apos;

    //log
    compile &apos;ch.qos.logback:logback-classic:1.1.7&apos;
    compile &quot;org.slf4j:slf4j-api:${slf4j_version}&quot;
    compile &quot;org.slf4j:jul-to-slf4j:${slf4j_version}&quot;
}
//noinspection GroovyAssignabilityCheck
tasks.withType(JavaCompile) {
    options.encoding = &quot;UTF-8&quot;
}}
</code></pre><h5 id="1-20-sourceSets"><a href="#1-20-sourceSets" class="headerlink" title="1.20 sourceSets"></a>1.20 sourceSets</h5><p>通过修改SourceSets中的属性，可以指定哪些源文件（或文件夹下的源文件）要被编译，哪些源文件要被排除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java &#123;</span><br><span class="line">            srcDir &apos;src/java&apos; // 指定源码目录</span><br><span class="line">        &#125;</span><br><span class="line">        resources &#123;</span><br><span class="line">            srcDir &apos;src/resources&apos; //资源目录</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2、实践"><a href="#2、实践" class="headerlink" title="2、实践"></a>2、实践</h4><p>多模块项目中，根目录一半就配置好subprojects buildscript就基本OK了。还会有一些常用插件，比如querydsl grpc的插件配置。<br><br>google的protobuf配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        proto &#123;</span><br><span class="line">            srcDir &apos;src/main/proto&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        java &#123;</span><br><span class="line">            srcDirs &apos;src/main/java&apos;, &quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/java&quot;, &quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/grpc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">protobuf &#123;</span><br><span class="line">    generatedFilesBaseDir = &quot;$&#123;projectDir&#125;/src/generated&quot;</span><br><span class="line">    protoc &#123;</span><br><span class="line">        artifact = &quot;com.google.protobuf:protoc:3.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        grpc &#123;</span><br><span class="line">            artifact = &quot;io.grpc:protoc-gen-grpc-java:$grpc_version&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    generateProtoTasks &#123;</span><br><span class="line">        all()*.plugins &#123;</span><br><span class="line">            grpc &#123;</span><br><span class="line">                option &apos;enable_deprecated=false&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idea &#123;</span><br><span class="line">    module &#123;</span><br><span class="line">        sourceDirs += file(&quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/java&quot;)</span><br><span class="line">        sourceDirs += file(&quot;$&#123;protobuf.generatedFilesBaseDir&#125;/main/grpc&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">publishing &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            name &quot;snapshots&quot;</span><br><span class="line">            url &quot;&quot;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username = &quot;&quot;</span><br><span class="line">                password = &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publications &#123;</span><br><span class="line">        mavenJava(MavenPublication) &#123;</span><br><span class="line">            pom.withXml &#123;</span><br><span class="line">                asNode().dependencies.&apos;*&apos;.findAll() &#123;</span><br><span class="line">                    it.scope.text() == &apos;runtime&apos; &amp;&amp; project.configurations.compile.allDependencies.find &#123; dep -&gt;</span><br><span class="line">                        dep.name == it.artifactId.text()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.each() &#123;</span><br><span class="line">                    it.scope*.value = &apos;compile&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (project != rootProject) &#123;</span><br><span class="line">                artifactId &quot;$&#123;rootProject.name&#125;-$&#123;project.name&#125;&quot;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                artifactId &quot;$&#123;project.name&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            from components.java</span><br><span class="line">            if (!project.getTasksByName(&quot;sourceJar&quot;, false).isEmpty()) &#123;</span><br><span class="line">                artifact sourceJar &#123;</span><br><span class="line">                    classifier &quot;sources&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/11/28/paxos学习小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/28/paxos学习小结/" itemprop="url">Paxos小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T22:50:36+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、paxos解决什么问题？"><a href="#1、paxos解决什么问题？" class="headerlink" title="1、paxos解决什么问题？"></a>1、paxos解决什么问题？</h4><p><strong>三个人在不同的城市现在要达成一个协议：去哪个城市聚会？</strong><br><br>使用的工具：<strong>微信 QQ 电话 飞鸽传书</strong> <br><br>但是：可能会断网 飞鸽迷路<br><br>如何保证三个人能决定出一个一致的城市，这就是paxos算法，pasox是一个算法族，包括basic-paxos，multi-paxos，fast-paxos等。<br><br>paxos算法在工程应用里主要解决日志复制问题，如主备库的日志同步。</p>
<h4 id="2、一致性需要满足三个条件"><a href="#2、一致性需要满足三个条件" class="headerlink" title="2、一致性需要满足三个条件"></a>2、一致性需要满足三个条件</h4><ol>
<li>v达成一致时的值由某个进程提出。防止作弊方式：无论如何，最终都令每个进程的v为同一个预先设置的值</li>
<li>一旦v就某个值达成一致，v不会对另一个值再次达成一致，这是<strong>安全性</strong></li>
<li>一致总能达成，v总会被决定为某个值，不会无休止的等待，这称为<strong>活性</strong></li>
</ol>
<h4 id="3、paxos约束"><a href="#3、paxos约束" class="headerlink" title="3、paxos约束"></a>3、paxos约束</h4><ol>
<li>P1 acceptor必须接受收到的第一个提案</li>
<li>P2 如果一个value=v的提案被选择了，那么被批准的拥有更高proposalId的提案proposal的value=v<br>（P2a 一旦一个具有value v的提案被批准(chosen)，那么之后任何Acceptor 再次接受(accept)的提案必须具有value v）<br>（一旦一个具有value v的提案被批准(chosen)，那么以后任何 Proposer 提出的提案必须具有value v）<br>（P2c <strong>如果一个编号为n的提案具有value=v，那么存在一个多数派，要么他们中所有人都没有accept编号小于n的任何提案，要么他们已经accpet的所有编号小于n的提案中编号最大的那个提案具有value v</strong>）<br><br>P2c -&gt; P2b -&gt; P2c -&gt; P2a</li>
</ol>
<h4 id="4、basic-paxos算法"><a href="#4、basic-paxos算法" class="headerlink" title="4、basic-paxos算法"></a>4、basic-paxos算法</h4><p>先摆上算法流程：<br></p>
<h5 id="1、第一阶段Prepare"><a href="#1、第一阶段Prepare" class="headerlink" title="1、第一阶段Prepare"></a>1、第一阶段Prepare</h5><h5 id="P1a：Proposer发送Prepare"><a href="#P1a：Proposer发送Prepare" class="headerlink" title="P1a：Proposer发送Prepare"></a>P1a：Proposer发送Prepare</h5><p>proposer生成全局唯一且递增的提案ID，无需携带提案内容</p>
<h5 id="P1b：Acceptor应答Prepare"><a href="#P1b：Acceptor应答Prepare" class="headerlink" title="P1b：Acceptor应答Prepare"></a>P1b：Acceptor应答Prepare</h5><p>Acceptor收到PrepareRequest。<br>做出一个Response，两个Promise<br><br>一个Reponse：<br></p>
<ul>
<li>返回Accept的提案中PropalId最大的提案的内容，没有则返回空值</li>
</ul>
<p>两个Promise：<br></p>
<ul>
<li>不再应答PropalId&lt;=当前请求的PrepareRequest</li>
<li>不再应答PropoalId&lt;当前请求的AcceptRequest</li>
</ul>
<p>注意<br></p>
<ul>
<li>应答当前请求前，先检查是否违背承诺</li>
<li>应答前先在本地持久化当前ProposalId</li>
</ul>
<h5 id="2、第二阶段"><a href="#2、第二阶段" class="headerlink" title="2、第二阶段"></a>2、第二阶段</h5><h5 id="P2a：Proposer发送Accept"><a href="#P2a：Proposer发送Accept" class="headerlink" title="P2a：Proposer发送Accept"></a>P2a：Proposer发送Accept</h5><p>“提案生成规则”：Proposer收集到多数派应答的PrepareResponse，选择proposalId最大的提案内容，作为要发起Accept的提案，如果提案为空值，则可以随意决定提案内容，带上当前ProposalID，向集群发送AcceptRequest</p>
<ul>
<li>回复数量&gt;一半acceptor数量，且所有value为空，Proposer发出accept请求，带上指定value</li>
<li>回复数量&gt;一半acceptor，且有的回复value不为空，则Proposer发出accept请求，带上回复中ProposalId最大的value作为提案内容</li>
<li>回复数量&lt;=一半accept数量，尝试生成更大的ProposalId，转P1a执行</li>
</ul>
<h5 id="P2b-Accept应答Accept"><a href="#P2b-Accept应答Accept" class="headerlink" title="P2b:Accept应答Accept"></a>P2b:Accept应答Accept</h5><p>Acceptor收到AcceptRequest检查两个承诺，持久化当前ProposalId和提案内容，最后Proposer收集到多数派应答的AcceptResponse后，形成决议。<br><br>Acceptor收到Accept请求后：<br></p>
<ul>
<li>收到ProposalId&gt;=Max_ProposalId【一般情况是等于】，则回复提交成功，持久化ProposalId和value</li>
<li>收到ProposalId&lt;Max_proposalId，则不回复或者回复提交失败</li>
</ul>
<p>Proposer统计投票，propose收集到一些Accept：<br></p>
<ul>
<li>回复数量&gt;一半acceptor数量，则表示提交value成功。可以发一个广播给所有Proposer、Learner，通知已commit的value</li>
<li>回复数量 &lt;= 一半的Acceptor数量，尝试生成更大的 ProposalID，转P1a</li>
<li>收到提交失败的回复，生成更大ProposalId，转P1a</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>A、proposalId不要求全局唯一，本可以随机生成ProposalId，但是无法通过P1b约束概率很高<br><br>B、paxos流程为了每条日志生成全局唯一递增logId。如果有办法生成全局唯一递增logId，就不需要paxos了，每条日志accept一遍就OK了。<br></p>
<h4 id="5、multi-paxos算法"><a href="#5、multi-paxos算法" class="headerlink" title="5、multi-paxos算法"></a>5、multi-paxos算法</h4><p>basic-paxos针对每条redolog至少存在三次网络交互（1. 产生logId 2.prepare阶段 3.accept阶段）</p>
<ul>
<li>产生logId，集群内有很多proposer，任意server发起redolog同步，进行分布式协商产生全局唯一有序logId</li>
<li>prepare阶段，paxos instance进行redolog投票</li>
<li>accept阶段 对prepare的议案进行投票</li>
</ul>
<p>server应答prepare和accept前都要持久化本地redolog，最终basic-paxos进行redolog同步的延迟包括了3次网络交互和2次本地写盘。<br></p>
<h5 id="leader的产生"><a href="#leader的产生" class="headerlink" title="leader的产生"></a>leader的产生</h5><p>multi-paxos协议并不假设全局必须只能有唯一的leader来生成日志，允许有多个自认为是leader的server来并发生成日志，这样的场景退化为basic-paxos。<br><br>可以简单理解为经过一轮basic-paxos,成功得到多数派accept的proposer成为leader【leader elect】，只有通过lease机制，在leader任期内，不必每次向多数派询问logId，也不必执行prepare阶段，直接accept。<br><br>另一个问题：多个server并发执行leader elect，可能出现两个server在相近的时间内，先后leader elect都成功，因此当选leader在开始以leader身份提供服务之前，要使用leaer proposalId写一条日志（StartWorking日志） 得到多数派确认后，再开始提供服务。因为根绝basic-paxos约束，可以推断：先执行leader elect成功的leaer（L1)，它的proposalId(p1)一定会小于后执行leader elect成功的leader（L2）的proposalId（p2),而经过两轮leader Elect，集群多数派持久化的proposalId一定是P2，而此时L1使用P1执行accept，由于P1&lt; p2，将无法得到集群内多数派的accept。<br></p>
<p>顺势引出日志同步逻辑的简化，我们将 Leader 选主看作 Paxos 的 Prepare 阶段，这个 Prepare 操作在逻辑上一次性的将后续所有即将产生的日志都执行 Prepare，因此在 Leader任期内的日志同步，都使用同一个 Proposalid，只执行 Accept 阶段即可<br></p>
<p>各个备机在执行 Accept 的时候，需要注意什么？<br></p>
<p>把选主的那轮paos看做prepare，对于后续要accept的日志，遵守两个承诺，对于先后胜出选主的多个当选leader，同步日志时携带的proposalId大小是不同的，只有最大的proposalId能同步成功，称为正式leaderf。<br></p>
<p>再进一步简化：当选leader必写一条日志确认leader身份，允许多个当选，本质就是拿到集群两个承诺，选主过程对决议内容没有实际意义，进一步简化为只执行prepare阶段，无需accept<br></p>
<p>再进一步优化，与raft协议不同，multi-paxos不要求新leader拥有全部日志，需要知道补全哪些日志，向多数派查询各个机器maxLogId，确定补全日志结束的Logid。可以将这个操作与prepare一起发出。并非multi-paxos一部分。<br></p>
<p>回放逻辑：对每条形成多数派的日志，异步写出确认日志，回放时如果一条日志有对应的确认日志，不需重新执行paxos，直接回放。对于没有确认日志的，需要执行paxos。工程上为了避免“确认日志”与对应的 Redolog 距离过大而带来回放的复杂度，往往使用滑动窗口机制来控制他们的距离。同时“确认日志”也用来提示备机可以回放收到的日志了。与Raft协议不同，由于 Multi-Paxos 允许日志不连续的确认，以及允许任何成员都可以当选 Leader，因此新任leader需要补全自己本地缺失的日志，以及对未“确认”的日志重新执行 Paxos。我把这个过程叫做日志的“重确认”，本质上就是按照“最大commit原则”，使用当前最新的Proposalid，逐条的对这些日志重新执行Paxos，成功后再补上对应的“确认日志”。<br></p>
<p>功能：自动选主  简化同步逻辑  简化回放逻辑</p>
<h4 id="6、multi-paxos的问题"><a href="#6、multi-paxos的问题" class="headerlink" title="6、multi-paxos的问题"></a>6、multi-paxos的问题</h4><p>6.1 paxos存在永远无法达成一致的可能，就是所谓的活锁问题：</p>
<ul>
<li>被打回的第一阶段再次发起PrepareRequest请求前加入随机等待时间</li>
<li>设置一个超时时间，到达超时时间后，不再接受PrepareRequest请求</li>
<li>proposer选出一个leader，通过leader统一发出PrepareRequest和AcceptRequest</li>
</ul>
<p>6.2 影子日志<br><br>幽灵复现问题的根本原因是leader的乱序提交log<br><br>解决方法：<br>需要leader在完成日志冲确认，开始写入新的redolog之前，写一条StartWorking的日志，这条日志记录了当前leader的EpochId（可以使用ProposalId），leader每写一条日志都在日志内容中携带现任leader的EpochId，回放时，经过了一条StartWorking日志后，再遇到epochId比它小的日志，直接忽略。</p>
<h4 id="7、依赖时钟误差的变种-Paxos-选主协议"><a href="#7、依赖时钟误差的变种-Paxos-选主协议" class="headerlink" title="7、依赖时钟误差的变种 Paxos 选主协议"></a>7、依赖时钟误差的变种 Paxos 选主协议</h4><p>相对MultiPaxos和Raft协议的优势在于，它不需要持久化任何数据，引入选主窗口的概念，使得大部分场景下集群内的所有机器能够几乎同时发起选主请求，便于投票时比对预定的优先级。<br>选主协议规定选主窗口开启是当前时间对一个T取余为0的时间，即只能在第 0，T，2T，3T…N*T 的时间点上开启选主窗口，协议将一次选主划分为三个阶段<br></p>
<ol>
<li>T1 预投票开始即由各个选举组成员向集群里的其他机器发送拉票请求；</li>
<li>一段时间后进入 T2 预投票开始，选举组各个成员根据接受到的拉票请，从中选出优先级最高的，给它投票应答；</li>
<li>一段时间后进入 T3 计票阶段，收到多数派投票的成员成为 leader，并向投票组其他成员发送自己上任的消息。</li>
</ol>
<p>这个选主算法相对Paxos和Raft更加简单，但是对时钟误差有比较强的依赖，时钟误差过大的情况下，会造成投票分裂无法选出主，甚至可能出现双主,但是任何保持Leader身份的Lease机制都得依赖时钟，因此可能仅仅适合 BAT 这种配备了原子钟和 GPS校准时钟，能够控制时钟误差在 100ms 以内的土豪机房</p>
<h4 id="8、raft算法和paxos算法差异"><a href="#8、raft算法和paxos算法差异" class="headerlink" title="8、raft算法和paxos算法差异"></a>8、raft算法和paxos算法差异</h4><p>Raft可以认为是一种简化的Multi-Paxos实现，最大简化之处在于备机接受Leader日志的前提是收到LogID连续的日志，在这个假设前提下，没有“幽灵复现”和“重确认”问题。简化带来的代价是对网络抖动的容忍度稍低一些。raft不允许日志的空洞，这也是为了比较方便和拉平两个节点的日志方便。Raft连续确认更大的一个优势是新主上任过程简单了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/29/矩阵最长上升路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/矩阵最长上升路径/" itemprop="url">矩阵最长上升路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-29T22:12:25+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="矩阵中的最长上升路径"><a href="#矩阵中的最长上升路径" class="headerlink" title="矩阵中的最长上升路径"></a>矩阵中的最长上升路径</h5><p>给出一个数字矩阵，寻找一条最长上升路径，每个位置只能向上下左右四个位置移动。<br>Example：</p>
<p>nums = [</p>
<pre><code>[9, 9, 4],

[6, 6, 8],

[2, 2, 1]
</code></pre><p>]</p>
<p>返回 4，最长上升路径是[1, 2, 6, 9]</p>
<p>可以采用bfs，时间复杂度可能达到O(n^4)，或者dp、记忆化搜索<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">val dx = arrayListOf(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">val dy = arrayListOf(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">var n: Int = <span class="number">0</span></span><br><span class="line">var m: Int = <span class="number">0</span></span><br><span class="line">var dp: Array&lt;IntArray&gt; = Array(<span class="number">3</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line">var flag: Array&lt;IntArray&gt; = Array(<span class="number">3</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line"><span class="function">fun <span class="title">search</span><span class="params">(x: Int, y: Int, A: Array&lt;IntArray&gt;)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][y]</span><br><span class="line">    &#125;</span><br><span class="line">    var ans = <span class="number">1</span></span><br><span class="line">    var nx: Int</span><br><span class="line">    var ny: Int</span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">        nx = x + dx[i]</span><br><span class="line">        ny = y + dy[i]</span><br><span class="line">        <span class="keyword">if</span> (nx in <span class="number">0</span>..(n - <span class="number">1</span>) &amp;&amp; ny in <span class="number">0</span>..(m - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[x][y] &gt; A[nx][ny]) &#123;</span><br><span class="line">                ans = Math.max(ans, search(nx, ny, A) + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[x][y] = <span class="number">1</span></span><br><span class="line">    dp[x][y] = ans</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">longest</span><span class="params">(A: Array&lt;IntArray&gt;)</span>: Int </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.isEmpty()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = A.size</span><br><span class="line">    m = A[<span class="number">0</span>].size</span><br><span class="line">    var ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j in <span class="number">0</span> until m) &#123;</span><br><span class="line">            dp[i][j] = search(i, j, A)</span><br><span class="line">            ans = Math.max(ans, dp[i][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(vararg args: String)</span> </span>&#123;</span><br><span class="line">    val arr: Array&lt;IntArray&gt; = arrayOf(intArrayOf(<span class="number">9</span>, <span class="number">9</span>, <span class="number">4</span>), intArrayOf(<span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span>), intArrayOf(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    println(longest(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/28/复数的意义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/28/复数的意义/" itemprop="url">复数的意义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-28T23:00:19+08:00">
                2018-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转来自知乎ID：Heinrich</p>
<p>链接：<a href="https://www.zhihu.com/question/23234701/answer/26017000" target="_blank" rel="noopener">https://www.zhihu.com/question/23234701/answer/26017000</a></p>
<h5 id="复数（虚数）赋予了旋转的意义。"><a href="#复数（虚数）赋予了旋转的意义。" class="headerlink" title="复数（虚数）赋予了旋转的意义。"></a>复数（虚数）赋予了旋转的意义。</h5><h5 id="比如-4-i-i-4-代表在数轴上旋转了180度"><a href="#比如-4-i-i-4-代表在数轴上旋转了180度" class="headerlink" title="比如 4*i*i=-4 代表在数轴上旋转了180度"></a>比如 <code>4*i*i=-4</code> 代表在数轴上旋转了180度</h5><p><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCEd388d4d126fe37eddf38f5e45bc0147c/23237" alt="image"></p>
<p>来看一个函数<code>$e^t$</code><br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE9ad10deb44c13b2cc6a2dbad96df5354/23233" alt="image"></p>
<p>再加上一个参数i:<br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE0a6d646b45aa3e096a20b3f0c1b77510/23231" alt="image"></p>
<p>变成了一个螺旋线，和电磁场非常像</p>
<h4 id="更重要的意义在于保留了二维信息"><a href="#更重要的意义在于保留了二维信息" class="headerlink" title="更重要的意义在于保留了二维信息"></a>更重要的意义在于保留了二维信息</h4><p>如果分解一个实数8，可以有无数种分解方法，但是计算3+5i的话，可以分解出实部和虚部。可以让电场强度和复数磁场强度相加不损失各自的信息，而且满足电场与磁场垂直要求。<br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE4ba1f885390bb0b2025491366e1b6b74/23235" alt="image"></p>
<p>正弦波可以看做自然数中的1，可以构成其他数字的基础元素。</p>
<h5 id="复数的引入大大方便了涉及到的旋转计算"><a href="#复数的引入大大方便了涉及到的旋转计算" class="headerlink" title="复数的引入大大方便了涉及到的旋转计算"></a>复数的引入大大方便了涉及到的旋转计算</h5><p>比如计算合力，比如一个力是(3+i)，另一个力(1+3i)，求合力是多少？只需简单相加即可(4+4i)</p>
<h5 id="复数涉及乘法的计算"><a href="#复数涉及乘法的计算" class="headerlink" title="复数涉及乘法的计算"></a>复数涉及乘法的计算</h5><p>比如一条船航向（ 3 + 4i）<br>如果该船的航向，逆时针增加45度，新的航向是多少<br><img src="https://note.youdao.com/yws/public/resource/083b6154a87fc9b36abce052e7369c8d/xmlnote/WEBRESOURCE74c87b124fe4f6a37e7db3ac6a086c94/23278" alt="image"></p>
<p>( 3 + 4i ) * ( 1 + i ) = ( -1 + 7i )</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2018/10/27/有趣的条件概率/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/有趣的条件概率/" itemprop="url">条件概率</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-27T21:19:10+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望"><a href="#假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望" class="headerlink" title="假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望"></a>假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的条件下扔骰子次数的期望</h5><h5 id="分析-既然每一次都只能是偶数，也就是只能出现-2-4-6，且出现-6-就停，那么答案就是-3-？但是答案不是-3。-答案是-1-5，这个-1-5-还并不是「扔一个-3-面的骰子」的答案-3-的一半，而是-1-1-1-3-，其中的-1-3-是「在符合条件的前提下继续扔」的概率"><a href="#分析-既然每一次都只能是偶数，也就是只能出现-2-4-6，且出现-6-就停，那么答案就是-3-？但是答案不是-3。-答案是-1-5，这个-1-5-还并不是「扔一个-3-面的骰子」的答案-3-的一半，而是-1-1-1-3-，其中的-1-3-是「在符合条件的前提下继续扔」的概率" class="headerlink" title="分析 既然每一次都只能是偶数，也就是只能出现 2,4,6，且出现 6 就停，那么答案就是 3 ？但是答案不是 3。==答案是 1.5，这个 1.5 还并不是「扔一个 3 面的骰子」的答案 3 的一半，而是 1 / (1 - 1/3)，其中的 1/3 是「在符合条件的前提下继续扔」的概率=="></a>分析 既然每一次都只能是偶数，也就是只能出现 2,4,6，且出现 6 就停，那么答案就是 3 ？但是答案不是 3。==答案是 1.5，这个 1.5 还并不是「扔一个 3 面的骰子」的答案 3 的一半，而是 1 / (1 - 1/3)，其中的 1/3 是「在符合条件的前提下继续扔」的概率==</h5><h5 id="问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1-3-5-6停止。求最后一次扔出-6-的条件下扔骰子次数的期望。"><a href="#问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1-3-5-6停止。求最后一次扔出-6-的条件下扔骰子次数的期望。" class="headerlink" title="问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1,3,5,6停止。求最后一次扔出 6 的条件下扔骰子次数的期望。"></a>问题的关键在于要意识到，扔出奇数后相当于实验马上失败了，而不是这次扔出的奇数无效，重新扔。这个问题等价于：假设你不断扔一个等概率的六面骰子，直到扔出1,3,5,6停止。求最后一次扔出 6 的条件下扔骰子次数的期望。</h5><p>考虑最原始的做法，即直接按照定义算。令概率空间 U 为 [6]∗ 所有无限长的字母表为 [6]∗ 的字符创。令  表示第一个 6 出现之前都是偶数这个事件，有:<br><code>$ \Pr[\mathcal{E}] = \frac{1}{6} \times \left (1 + \frac{1}{3} + \left(  \frac{1}{3}\right)^2 + \cdots \right) = \frac{1}{4}.$</code></p>
<p>令 f(x) 为字符串 x 中第一个 6 出现的位置，直接代入定义有：<br><code>$\mathbb{E}_X[f(X) | \mathcal{E}] = \frac{1}{\Pr[\mathcal{E}]} \int_{x \in \mathcal{E}} \Pr[X = x] f(x) \mathrm{d} x = 4 \times \frac{1}{6} \times \sum_{i=1} \left( \frac{1}{3} \right)^{i-1} i = \frac{3}{2}.$</code></p>
<h5 id="另一种分析方式："><a href="#另一种分析方式：" class="headerlink" title="另一种分析方式："></a>另一种分析方式：</h5><p>这道题有很多人第一反应都是3。因为基于类似的原因，问题看起来和扔一个只有2，4，6三种可能的骰子等价。这么分析错在哪里先按下不表，我们首先求一下：</p>
<p>假设你不断扔一个等概率的六面骰子，直到扔出6停止。求在骰子只出现过偶数的概率是多大？<br>利用上一道题的结论，每次扔骰子有1/6的概率扔出6停止，1/2的概率扔出奇数，余下1/3的概率取决于后面继续扔的结果。所以骰子只出现偶数的概率为 1/6 / (1/6 + 1/2) = 1/4。</p>
<p>有没有发现哪里不对？有1/6的概率第一次就扔出6停止，这个事件占了只出现偶数的概率的2/3，也就是说，在只出现偶数的条件下，有2/3的概率第一次就扔出6！</p>
<p>问题就出在，因为出现6就停止，所以扔出6更有可能让只出现偶数这件事情发生，所以某次扔出6这个事件和只出现偶数这个事件有很强的相关性。</p>
<p>这道题比较取巧的解法是，换一种描述问题的方式：</p>
<p>假设你不断扔一个等概率的六面骰子，直到扔出1, 3, 5, 6停止。求最后一次扔出6的条件下扔骰子次数的期望。在偶数序列情况下，最后一次是6的条件概率，<br>首先这个问题和原题目等价。因为条件概率 P(A|B) = P(AB) / P(B)，比较一下新题目的两个事件和原题目的两个事件完全等价。</p>
<p>然后这是一个系数为2/3的几何分布，期望为3/2。由于1，3，5，6的对称性，条件住6并不会改变期望的值。</p>
<p>所以本题答案为3/2<br>kotlin代码验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">game</span><span class="params">(cnt: Int)</span>: Int </span>&#123;</span><br><span class="line">    var num = cnt</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span>) num = <span class="number">1</span></span><br><span class="line">    val t = (Math.random() * <span class="number">6</span> + <span class="number">1</span>).toInt()</span><br><span class="line">    <span class="keyword">return</span> when &#123;</span><br><span class="line">        t % <span class="number">2</span> == <span class="number">1</span> -&gt; <span class="comment">// 奇</span></span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        t == <span class="number">6</span> -&gt; num</span><br><span class="line">        <span class="keyword">else</span> -&gt; game(++num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">expect</span><span class="params">(n: Int)</span> </span>&#123;</span><br><span class="line">    var fenzi = <span class="number">0.0</span></span><br><span class="line">    var fenmu = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">0</span>..n) &#123;</span><br><span class="line">        val t = game(<span class="number">0</span>) <span class="comment">// 扔出奇数时为 0</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fenzi += t</span><br><span class="line">            fenmu += <span class="number">1</span>  <span class="comment">// 扔出偶数时加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(fenmu / n)</span><br><span class="line">    println(fenzi / fenmu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(vararg args: String)</span> </span>&#123;</span><br><span class="line">    expect(<span class="number">10000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hecy</p>
              <p class="site-description motion-element" itemprop="description">a dreamer</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hecy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
