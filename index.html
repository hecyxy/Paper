<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="a dreamer">
<meta property="og:type" content="website">
<meta property="og:title" content="无病呻吟">
<meta property="og:url" content="http://hcyxy.tech/index.html">
<meta property="og:site_name" content="无病呻吟">
<meta property="og:description" content="a dreamer">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="无病呻吟">
<meta name="twitter:description" content="a dreamer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hcyxy.tech/"/>





  <title>无病呻吟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">无病呻吟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">hcy && xy</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/07/08/递归动态规划案例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/08/递归动态规划案例/" itemprop="url">递归-动态规划案例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-08T21:19:22+08:00">
                2019-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="1、上台阶"><a href="#1、上台阶" class="headerlink" title="1、上台阶"></a>1、上台阶</h5><blockquote>
<p>一个小孩上台阶，每次可以上1步、2步或3步，共有n级台阶，一共有多少种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">fun runStairCase(n: Int): Int &#123;</span><br><span class="line">    if (n == 1) return 1</span><br><span class="line">    if (n == 2) return 2</span><br><span class="line">    val array = IntArray(n + 1)</span><br><span class="line">    array[1] = 1</span><br><span class="line">    for (i in 2 until (n + 1)) &#123;</span><br><span class="line">        if (i - 1 &gt; 0)</span><br><span class="line">            array[i] += array[i - 1]</span><br><span class="line">        else if (i - 1 == 0)</span><br><span class="line">            array[i] += 1</span><br><span class="line">        if (i - 2 &gt; 0)</span><br><span class="line">            array[i] += array[i - 2]</span><br><span class="line">        else if (i - 2 == 0)</span><br><span class="line">            array[i] += 1</span><br><span class="line">        if (i - 3 &gt; 0)</span><br><span class="line">            array[i] += array[i - 3]</span><br><span class="line">        else if (i - 3 == 0)</span><br><span class="line">            array[i] += 1</span><br><span class="line">    &#125;</span><br><span class="line">    return array[n]</span><br><span class="line">&#125;</span><br><span class="line">fun countWays(n: Int): Int &#123;</span><br><span class="line">    val memo = IntArray(n + 1)</span><br><span class="line">    Arrays.fill(memo, -1)</span><br><span class="line">    return countWays(n, memo)</span><br><span class="line">&#125;</span><br><span class="line">fun countWays(n: Int, memo: IntArray): Int &#123;</span><br><span class="line">    return when &#123;</span><br><span class="line">        n &lt; 0 -&gt; 0</span><br><span class="line">        n == 0 -&gt; 1</span><br><span class="line">        memo[n] &gt; -1 -&gt; memo[n]</span><br><span class="line">        else -&gt; &#123;</span><br><span class="line">            memo[n] = countWays(n - 1, memo) + countWays(n - 2, memo) +</span><br><span class="line">                    countWays(n - 3, memo)</span><br><span class="line">            memo[n]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="2、机器人跳方格"><a href="#2、机器人跳方格" class="headerlink" title="2、机器人跳方格"></a>2、机器人跳方格</h5><blockquote>
<p>一个机器在一个方格左上角，每次可以向右或向下，但不能超过方格，从左上角到右下角有多种路</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun grid(row: Int, col: Int): Int &#123;</span><br><span class="line">    val meta = Array(row + 1) &#123;</span><br><span class="line">        IntArray(col + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    for (i in row downTo 1) &#123;</span><br><span class="line">        for (j in col downTo 1) &#123;</span><br><span class="line">            if (i == row &amp;&amp; j == col) &#123;</span><br><span class="line">                meta[i][j] = 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (i + 1 &lt;= row)</span><br><span class="line">                    meta[i][j] += meta[i + 1][j]</span><br><span class="line">                if (j + 1 &lt;= col) &#123;</span><br><span class="line">                    meta[i][j] += meta[i][j + 1]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return meta[1][1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、求所有集合子集"><a href="#3、求所有集合子集" class="headerlink" title="3、求所有集合子集"></a>3、求所有集合子集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">fun getSubsets(data: List&lt;Int&gt;, index: Int): ArrayList&lt;ArrayList&lt;Int&gt;&gt; &#123;</span><br><span class="line">    val allSubSets: ArrayList&lt;ArrayList&lt;Int&gt;&gt;?</span><br><span class="line">    if (data.size == index) &#123;</span><br><span class="line">        allSubSets = arrayListOf()</span><br><span class="line">        allSubSets.add(ArrayList())</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        allSubSets = getSubsets(data, index + 1)</span><br><span class="line">        val item = data[index]</span><br><span class="line">        val moreSubsets = ArrayList&lt;ArrayList&lt;Int&gt;&gt;()</span><br><span class="line">        allSubSets.forEach &#123;</span><br><span class="line">            val newSubset = ArrayList&lt;Int&gt;()</span><br><span class="line">            newSubset.addAll(it)</span><br><span class="line">            newSubset.add(item)</span><br><span class="line">            moreSubsets.add(newSubset)</span><br><span class="line">        &#125;</span><br><span class="line">        allSubSets.addAll(moreSubsets)</span><br><span class="line">    &#125;</span><br><span class="line">    return allSubSets</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun getSubsets(data: List&lt;Int&gt;): ArrayList&lt;ArrayList&lt;Int&gt;&gt; &#123;</span><br><span class="line">    val allSubsets = ArrayList&lt;ArrayList&lt;Int&gt;&gt;()</span><br><span class="line">    val max = 1 shl data.size</span><br><span class="line">    for (i in 0 until max) &#123;</span><br><span class="line">        val subset = convert(i, data)</span><br><span class="line">        allSubsets.add(subset)</span><br><span class="line">    &#125;</span><br><span class="line">    return allSubsets</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun convert(i: Int, data: List&lt;Int&gt;): ArrayList&lt;Int&gt; &#123;</span><br><span class="line">    val subset = ArrayList&lt;Int&gt;()</span><br><span class="line">    var index = 0</span><br><span class="line">    var k = i</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        if (k and 1 == 1) &#123;</span><br><span class="line">            subset.add(data[index])</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        k = k shr 1</span><br><span class="line">    &#125;</span><br><span class="line">    return subset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、计算乘积"><a href="#4、计算乘积" class="headerlink" title="4、计算乘积"></a>4、计算乘积</h5><blockquote>
<p>不使用*操作，只能使用+ - 移位操作计算两数乘积<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fun minProduct(a: Int, b: Int): Int &#123;</span><br><span class="line">    val bigger = if (a &lt; b) b else a</span><br><span class="line">    val smaller = if (a &lt; b) a else b</span><br><span class="line">    val mem = IntArray(smaller + 1)</span><br><span class="line">    return minProductHelper(smaller, bigger, mem)</span><br><span class="line">&#125;</span><br><span class="line">fun minProductHelper(smaller: Int, bigger: Int, mem: IntArray): Int &#123;</span><br><span class="line">    when &#123;</span><br><span class="line">        smaller == 0 -&gt; return 0</span><br><span class="line">        smaller == 1 -&gt; return bigger</span><br><span class="line">        mem[smaller] &gt; 0 -&gt; return mem[smaller]</span><br><span class="line">    &#125;</span><br><span class="line">    val s = smaller shr 1</span><br><span class="line">    val side1 = minProductHelper(s, bigger, mem)</span><br><span class="line">    var side2 = side1</span><br><span class="line">    if (smaller % 2 == 1) &#123;</span><br><span class="line">        side2 = minProductHelper(smaller - s, bigger, mem)</span><br><span class="line">    &#125;</span><br><span class="line">    mem[smaller] = side1 + side2</span><br><span class="line">    return mem[smaller]</span><br><span class="line">&#125;</span><br><span class="line">fun upgradeMinProduct(smaller: Int, bigger: Int): Int &#123;</span><br><span class="line">    if (smaller == 0) return 0</span><br><span class="line">    else if (smaller == 1) return bigger</span><br><span class="line">    val s = smaller shr 1</span><br><span class="line">    val halfProd = minProduct(s, bigger)</span><br><span class="line">    return if (smaller % 2 == 0) &#123;</span><br><span class="line">        halfProd + halfProd</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        halfProd + halfProd + bigger</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="5、boolean-evaluation"><a href="#5、boolean-evaluation" class="headerlink" title="5、boolean evaluation"></a>5、boolean evaluation</h5><blockquote>
<p>0-false，1-true；给出一个表达式，给以目标值true/false,通过加括号，使目标表达式的布尔值=目标布尔值，输出加括号的方式，这种(((0))^(1))是不合理的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">fun countEval(s: String, result: Boolean): Int &#123;</span><br><span class="line">    if (s.isEmpty()) return 0</span><br><span class="line">    if (s.length == 1) return if ((s.toInt() == 1) == result) 1 else 0</span><br><span class="line">    var ways = 0</span><br><span class="line">    var i = 1</span><br><span class="line">    while (i &lt; s.length) &#123;</span><br><span class="line">        val c = s[i]</span><br><span class="line">        val left = s.substring(0, i)</span><br><span class="line">        val right = s.substring(i + 1, s.length)</span><br><span class="line">        val leftTrue = countEval(left, true)</span><br><span class="line">        val leftFalse = countEval(left, false)</span><br><span class="line">        val rightTrue = countEval(right, true)</span><br><span class="line">        val rightFalse = countEval(right, false)</span><br><span class="line">        val total = (leftTrue + leftFalse) * (rightFalse + rightTrue)</span><br><span class="line">        var totalTrue = 0</span><br><span class="line">        when (c) &#123;</span><br><span class="line">            &apos;^&apos; -&gt; totalTrue = leftTrue * rightFalse + leftFalse * rightTrue</span><br><span class="line">            &apos;&amp;&apos; -&gt; totalTrue = leftTrue * rightTrue</span><br><span class="line">            &apos;|&apos; -&gt; totalTrue = leftTrue * rightTrue + leftTrue * rightFalse + leftFalse * rightTrue</span><br><span class="line">        &#125;</span><br><span class="line">        val subWays = if (result) totalTrue else total - totalTrue</span><br><span class="line">        ways += subWays</span><br><span class="line">        i += 2</span><br><span class="line">    &#125;</span><br><span class="line">    return ways</span><br><span class="line">&#125;</span><br><span class="line">fun countEval(s: String, result: Boolean, mem: HashMap&lt;String, Int&gt;): Int &#123;</span><br><span class="line">    if (s.isEmpty()) return 0</span><br><span class="line">    if (s.length == 1) &#123;</span><br><span class="line">        return if ((s.toInt() == 1) == result) 1 else 0</span><br><span class="line">    &#125;</span><br><span class="line">    if (mem.containsKey(result.toString() + s)) return mem[result.toString() + s] ?: 0</span><br><span class="line">    var ways = 0</span><br><span class="line">    var i = 1</span><br><span class="line">    while (i &lt; s.length) &#123;</span><br><span class="line">        val c = s[i]</span><br><span class="line">        val left = s.substring(0, i)</span><br><span class="line">        val right = s.substring(i + 1, s.length)</span><br><span class="line">        val leftTrue = countEval(left, true, mem)</span><br><span class="line">        val leftFalse = countEval(left, false, mem)</span><br><span class="line">        val rightTrue = countEval(right, true, mem)</span><br><span class="line">        val rightFalse = countEval(right, false, mem)</span><br><span class="line">        val total = (leftTrue + leftFalse) * (rightFalse + rightTrue)</span><br><span class="line">        var totalTrue = 0</span><br><span class="line">        when (c) &#123;</span><br><span class="line">            &apos;^&apos; -&gt; totalTrue = leftTrue * rightFalse + leftFalse * rightTrue</span><br><span class="line">            &apos;&amp;&apos; -&gt; totalTrue = leftTrue * rightTrue</span><br><span class="line">            &apos;|&apos; -&gt; totalTrue = leftTrue * rightTrue + leftTrue * rightFalse + leftFalse * rightTrue</span><br><span class="line">        &#125;</span><br><span class="line">        val subWays = if (result) totalTrue else total - totalTrue</span><br><span class="line">        ways += subWays</span><br><span class="line">        i += 2</span><br><span class="line">    &#125;</span><br><span class="line">    mem[result.toString() + s] = ways</span><br><span class="line">    return ways</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6、八皇后问题"><a href="#6、八皇后问题" class="headerlink" title="6、八皇后问题"></a>6、八皇后问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const val gridSize = 8</span><br><span class="line">fun placeQueens(row: Int, columns: Array&lt;Int&gt;, results: ArrayList&lt;Array&lt;Int&gt;&gt;) &#123;</span><br><span class="line">    if (row == gridSize) &#123;</span><br><span class="line">        results.add(columns.clone())</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (col in 0 until gridSize) &#123;</span><br><span class="line">            if (checkValid(columns, row, col)) &#123;</span><br><span class="line">                columns[row] = col</span><br><span class="line">                placeQueens(row + 1, columns, results)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun checkValid(columns: Array&lt;Int&gt;, row1: Int, column1: Int): Boolean &#123;</span><br><span class="line">    for (row2 in 0 until row1) &#123;</span><br><span class="line">        val column2 = columns[row2]</span><br><span class="line">        if (column1 == column2) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        val columnsDistance = Math.abs(column2 - column1)</span><br><span class="line">        val rowDistance = row1 - row2</span><br><span class="line">        if (columnsDistance == rowDistance) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7、硬币组合"><a href="#7、硬币组合" class="headerlink" title="7、硬币组合"></a>7、硬币组合</h5><blockquote>
<p>你有若干硬币1、5、10、25，给你一个目标值，用这些硬币组合成这个目标值，有多少种方案</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun makeChange(n: Int): Int &#123;</span><br><span class="line">    val denoms = listOf(1, 5, 10, 25)</span><br><span class="line">    val map = Array(n + 1) &#123;</span><br><span class="line">        IntArray(denoms.size + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    return makeChange(n, denoms, 0, map)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun makeChange(amount: Int, denoms: List&lt;Int&gt;, index: Int, map: Array&lt;IntArray&gt;): Int &#123;</span><br><span class="line">    if (map[amount][index] &gt; 0) &#123;</span><br><span class="line">        return map[amount][index]</span><br><span class="line">    &#125;</span><br><span class="line">    if (index &gt; denoms.size - 1) return 1</span><br><span class="line">    val denomAmount = denoms[index]</span><br><span class="line">    var ways = 0</span><br><span class="line">    var i = 0</span><br><span class="line">    while (i * denomAmount &lt;= amount) &#123;</span><br><span class="line">        val amountRemaing = amount - i * denomAmount</span><br><span class="line">        ways += makeChange(amountRemaing, denoms, index + 1, map)</span><br><span class="line">        i += 1</span><br><span class="line">    &#125;</span><br><span class="line">    map[amount][index] = ways</span><br><span class="line">    return ways</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8、求括号组合"><a href="#8、求括号组合" class="headerlink" title="8、求括号组合"></a>8、求括号组合</h5><blockquote>
<p>实现所有括号组合，比如输入1，输出();输入2，输出()()、(())</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun paren(n: Int): Set&lt;String&gt; &#123;</span><br><span class="line">    val set = HashSet&lt;String&gt;()</span><br><span class="line">    if (n == 0) &#123;</span><br><span class="line">        set.add(&quot;&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        val prev = paren(n - 1)</span><br><span class="line">        prev.forEach &#123;</span><br><span class="line">            for (i in 0 until it.length) &#123;</span><br><span class="line">                if (it[i] == &apos;(&apos;) &#123;</span><br><span class="line">                    val temp = insert(it, i)</span><br><span class="line">                    set.add(temp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(&quot;()$it&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return set</span><br><span class="line">&#125;</span><br><span class="line">fun insert(str: String, leftIndex: Int): String &#123;</span><br><span class="line">    val left = str.substring(0, leftIndex + 1)</span><br><span class="line">    val right = str.substring(leftIndex + 1, str.length)</span><br><span class="line">    return &quot;$left()$right&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="9、汉诺塔游戏"><a href="#9、汉诺塔游戏" class="headerlink" title="9、汉诺塔游戏"></a>9、汉诺塔游戏</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Tower(private val i: Int) &#123;</span><br><span class="line">    private val disks = Stack&lt;Int&gt;()</span><br><span class="line">    val stack: Stack&lt;Int&gt;</span><br><span class="line">        get() &#123;</span><br><span class="line">            return disks</span><br><span class="line">        &#125;</span><br><span class="line">    val index: Int</span><br><span class="line">        get() &#123;</span><br><span class="line">            return i</span><br><span class="line">        &#125;</span><br><span class="line">    fun add(d: Int) &#123;</span><br><span class="line">        if (disks.isNotEmpty() &amp;&amp; disks.peek() &lt;= d) &#123;</span><br><span class="line">            println(&quot;error placing disk $d&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disks.push(d)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private fun moveTopTo(t: Tower) &#123;</span><br><span class="line">        val top = disks.pop()</span><br><span class="line">        t.add(top)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun moveDisks(n: Int, destination: Tower, buffer: Tower) &#123;</span><br><span class="line">        if (n &gt; 0) &#123;</span><br><span class="line">            moveDisks(n - 1, buffer, destination)</span><br><span class="line">            moveTopTo(destination)</span><br><span class="line">            buffer.moveDisks(n - 1, destination, this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fun main(vararg args: String) &#123;</span><br><span class="line">    val n = 3</span><br><span class="line">    val towers = arrayOfNulls&lt;Tower&gt;(n)</span><br><span class="line">    for (i in 0 until n) &#123;</span><br><span class="line">        towers[i] = Tower(i)</span><br><span class="line">    &#125;</span><br><span class="line">    for (i in n - 1 downTo 0) &#123;</span><br><span class="line">        towers[0]!!.add(i)</span><br><span class="line">    &#125;</span><br><span class="line">    towers[0]!!.moveDisks(n, towers[2]!!, towers[1]!!)</span><br><span class="line">    towers.forEach &#123;</span><br><span class="line">        println(&quot;$&#123;it?.index&#125; $&#123;it?.stack&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10、排列组合问题"><a href="#10、排列组合问题" class="headerlink" title="10、排列组合问题"></a>10、排列组合问题</h5><blockquote>
<p>给一个字符串包含不同的字符，给出所有排列组合方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">fun getPerms(str: String): List&lt;String&gt; &#123;</span><br><span class="line">    val permu = arrayListOf&lt;String&gt;()</span><br><span class="line">    if (str.isEmpty()) &#123;</span><br><span class="line">        permu.add(&quot;&quot;)</span><br><span class="line">        return permu</span><br><span class="line">    &#125;</span><br><span class="line">    val first = str[0]</span><br><span class="line">    val remainder = str.substring(1)</span><br><span class="line">    val words = getPerms(remainder)</span><br><span class="line">    words.forEach &#123; word -&gt;</span><br><span class="line">        var j = 0</span><br><span class="line">        while (j &lt;= word.length) &#123;</span><br><span class="line">            val s = insertCharAt(word, first, j)</span><br><span class="line">            println(&quot;s $s&quot;)</span><br><span class="line">            permu.add(s)</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return permu</span><br><span class="line">&#125;</span><br><span class="line">fun insertCharAt(word: String, c: Char, i: Int): String &#123;</span><br><span class="line">    val start = word.substring(0, i)</span><br><span class="line">    val end = word.substring(i)</span><br><span class="line">    return start + c + end</span><br><span class="line">&#125;</span><br><span class="line">fun getPerms2(str: String): List&lt;String&gt; &#123;</span><br><span class="line">    val result = arrayListOf&lt;String&gt;()</span><br><span class="line">    getPerms2(&quot;&quot;, str, result)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">fun getPerms2(prefix: String, remainder: String, result: ArrayList&lt;String&gt;) &#123;</span><br><span class="line">    if (remainder.isEmpty()) &#123;</span><br><span class="line">        result.add(prefix)</span><br><span class="line">    &#125;</span><br><span class="line">    val len = remainder.length</span><br><span class="line">    var i = 0</span><br><span class="line">    while (i &lt; len) &#123;</span><br><span class="line">        val before = remainder.substring(0, i)</span><br><span class="line">        val after = remainder.substring(i + 1, len)</span><br><span class="line">        val c = remainder[i]</span><br><span class="line">        getPerms2(prefix + c, before + after, result)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>假如这个字符串包含有重复字符呢，该如何处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fun printPerms(s: String): List&lt;String&gt; &#123;</span><br><span class="line">    val result = arrayListOf&lt;String&gt;()</span><br><span class="line">    val map = buildFreqTable(s)</span><br><span class="line">    printPerms(map, &quot;&quot;, s.length, result)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">fun printPerms(map: HashMap&lt;Char, Int&gt;, prefiex: String, remaining: Int, result: ArrayList&lt;String&gt;) &#123;</span><br><span class="line">    if (remaining == 0) &#123;</span><br><span class="line">        result.add(prefiex)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    map.keys.forEach &#123;</span><br><span class="line">        val count = map[it] ?: 0</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            map[it] = count - 1</span><br><span class="line">            printPerms(map, prefiex + it, remaining - 1, result)</span><br><span class="line">            map[it] = count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun buildFreqTable(s: String): HashMap&lt;Char, Int&gt; &#123;</span><br><span class="line">    val map = HashMap&lt;Char, Int&gt;()</span><br><span class="line">    s.forEach &#123;</span><br><span class="line">        map[it] = map.getOrDefault(it, 0) + 1</span><br><span class="line">    &#125;</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/07/01/计算学习理论PAC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/计算学习理论PAC/" itemprop="url">计算学习理论PAC VC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-01T23:37:14+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>看了很多机器学习算法，又看了很多深度学习框架后，又回过头来看PAC的理论支撑。</p>
</blockquote>
<p><strong>PAC结论：同等条件下，模型越复杂泛化误差越大；同一模型，样本满足一定情况且数量越大，泛化误差越小(模型越复杂需要的样本更多)；</strong></p>
<p>PAC可以帮你解释什么？</p>
<ul>
<li>为什么机器学习以后在训练样本之外的数据上有效？</li>
<li>为什么大多数场景不需要深度学习？</li>
<li>为什么深度学习需要大量数据？</li>
</ul>
<h4 id="1-推断未知的数据"><a href="#1-推断未知的数据" class="headerlink" title="1. 推断未知的数据"></a>1. 推断未知的数据</h4><p><code>$\mathcal H$</code>代表Hypothesis set中方程数量,用sample中h(x)!=f(x)的比例推断总体中h(x)!=f(x)概率，h(x)!=f(x)表示一个error，<code>$E_{in}$</code>表示在sample中出现的error期望，总体中出现error期望<code>$E_{out}$</code>，对于h来说：</p>
<ul>
<li><code>$E_{out}=\epsilon[h(x)!=f(x)]$</code></li>
<li><code>$E_{in}(h)=\frac{1}{N}\sum^{N}_{n=1}[h(x_{n}!=y_{n})]$</code></li>
</ul>
<p>霍夫丁不等式：<br></p>
<blockquote>
<p><code>$P[|E_{in}(h)-E_{out}(h)|&gt;\epsilon]&lt;=2exp^{-2\epsilon^2N}$</code></p>
</blockquote>
<p>当右边商界足够小时，可以说h在sample中表现错误率与h在总体中表现是差不多的。</p>
<p>对于一个固定的h，<code>$E_{in}$</code>与<code>$E_{out}$</code>很接近，也不一定是好的learing，因为这两个可能同时很大，代表误差很大，此时需要一个验证流程，使用历史数据判断某个h是不是误差够小；</p>
<h5 id="1-2-误差数据"><a href="#1-2-误差数据" class="headerlink" title="1.2 误差数据"></a>1.2 误差数据</h5><p>由于抽样误差造成样本分布于总体分布相差很大的样本，就是误差数据。比如h1是个很好的预测方程，但是遇到误差数据，就会造成<code>$E_{in}(h1)$</code>很大假如h2是个不好的预测，但遇到误差样本，反而<code>$E_{in}h2$</code>很小，对于误差样本，会造成：</p>
<blockquote>
<p><code>$|E_{in}(h)-E_{out}(h)|&gt;\epsilon$</code></p>
</blockquote>
<p>出现误差数据的概率是：</p>
<blockquote>
<p><code>$P(BAD)&lt;=2Mexp^{-2\epsilon^2N}$</code></p>
</blockquote>
<p>如果假设集合(hypothesis set)中方程数量<code>$|\mathcal{H}|=M$</code>是有限个，并且N足够大时，有很大概率保证不会遇到误差数据,不管<code>$\mathcal{A}$</code>挑选了任意一个g，都可以保证<code>$E_{out}(g)    \approx E_{in}(g)$</code>，learning主要考虑两个问题：</p>
<ul>
<li>能否保证<code>$E_{in}(g)$</code>和<code>$E_{out}(g)$</code>很接近？(hypothesis set中方程个数会不会太多，训练数据量是否足够)</li>
<li>能够使<code>$E_{in}(g) \approx 0$</code>,或者说使其足够小</li>
</ul>
<ol>
<li>如果M很小，第一个问题会做的很好，因为遇到坏的概率很小；但由于选择性很小，很难找到<code>$E_{in}(g)$</code>较小的g；</li>
<li>如果M很大，选择方程的时候自由度很大，更有机会选到<code>$E_{in}$</code>很低的方程，但遇到误差数据的可能性大大增加。</li>
</ol>
<p>由于上述公式中，推算时union bound是基于独立性的假设，<code>$\mathcal H$</code>，遭遇误差数据被明显放大，将公式升级为：<br><br><code>$P[|E_{in}(g)-E_{out}(g)|&gt;\epsilon ]  &lt;= 2effective(N)exp(-2\epsilon^2N)$</code></p>
<h6 id="成长函数"><a href="#成长函数" class="headerlink" title="成长函数"></a>成长函数</h6><p><code>$\mathcal H$</code>作用于D最多产生多少种dichotomy(结果)，这个结果与<code>$\mathcal H$</code>和数量N有关，定义成长函数：<br><br><code>$max|\mathcal H(x_1,x_2,...,x_n)|$</code></p>
<h6 id="打散shatter-突破点break-point"><a href="#打散shatter-突破点break-point" class="headerlink" title="打散shatter 突破点break point"></a>打散shatter 突破点break point</h6><p>当<code>$\mathcal H$</code>作用于有N个inputs的<code>$\mathcal D$</code>时，产生的最大dichotomy是<code>$2^N$</code>，当成长函数<code>$m_{\mathcal H}(N)&lt;2^N$</code>，这个k值就是break point,此时<code>$m_{\mathcal H}(k)$</code>就是其能shatter的数量。</p>
<h5 id="成长函数上界"><a href="#成长函数上界" class="headerlink" title="成长函数上界"></a>成长函数上界</h5><p><code>$B(N,k)=2\alpha+\beta&lt;=B(N-1,k)+B(N-1,k-1)$</code><br>方程数量看上去是无穷的，但真正有效的方程数量却是有限的，可以用成长函数<code>$ m_{\mathcal H}(N)$</code>来描述<code>$\mathcal H$</code>作用于<code>$\mathcal D$</code>会产生多少种有效的方程。</p>
<h4 id="2、VC维"><a href="#2、VC维" class="headerlink" title="2、VC维"></a>2、VC维</h4><p>如果一个<code>$\mathcal H$</code>的vc dimension即为<code>$d_{vc}(\mathcal H)$</code>，是这个<code>$\mathcal H$</code>最多能shatter掉的点的数量，如果无论多少点都能打散，则<code>$d_{vc}(h)=\infty$</code><br></p>
<blockquote>
<p><code>$d_{vc}$</code>和break point的关系:<code>$k=d_{vc}+1$</code>,<code>$m_{\mathcal H} = \sum^{d_{vc}}_{i=0}(N,i)$</code>,利用数学归纳法可得：<code>$m_{\mathcal H}=\sum_{i=0}^{d_{vc}}(N,i)&lt;=N^{d_{vc}+1}$</code></p>
</blockquote>
<h5 id="更一般的vc-bound"><a href="#更一般的vc-bound" class="headerlink" title="更一般的vc bound"></a>更一般的vc bound</h5><p>上面的公式中，<code>$m_{\mathcal H}(N)$</code>描述的是<code>$\mathcal H$</code>作用于数据量为N的资料D的有效方程数，因此<code>$\mathcal H$</code>当中每个h作用都能算出一个<code>$E_{in}$</code>，一共有<code>$m_{\mathcal H}(N)$</code>个，但是在总体中out of sample，<code>$E_{out}$</code>是无限的，不能直接套用union bound，假设我们能从总体当中再获得一份N笔的验证资料<code>$D&#39;$</code>,对于任何一个h可以算出作用于<code>$D&#39;$</code>上的<code>$E_{in}&#39;$</code>，因此如果<code>$E_{in}$</code>和<code>$E_{out}$</code>离很远，有非常大可能<code>$E_{in}$</code>和<code>$E_{in}&#39;$</code>也离很远，当N很大，<code>$E_{in}$</code>和<code>$E_{in}&#39;$</code>可以看错服从以<code>$E_{out}$</code>为中心的近似正态分布。新推出的VC-bound：</p>
<blockquote>
<p><code>$\begin{aligned}
\mathbb{P}[BAD] &amp;= \mathbb{P}[\exists h \in \mathcal{H}\text{ s.t. } |E_{in}(h)-E_{out}(h)|\gt \epsilon] \\\
&amp;\leq 4m_{\mathcal{H}}(2N)exp(-\frac{1}{8}\epsilon^2N)
\end{aligned}$</code></p>
</blockquote>
<p>其中<code>$m_{\mathcal H}(N)是假设集合的成长函数 $</code>：<br></p>
<blockquote>
<p><code>$\begin{aligned}
\\m_{\mathcal{H}}(N)\leq \sum_{i=0}^{d_{vc}}\binom {N}{i}\leq N^{d_{vc}} \\\
\textit{( for }N\geq 2, d_{vc}\geq 2\textit{ )}
\end{aligned}$</code></p>
</blockquote>
<p>因为寻找所有Hypothesis set是困难的，再利用<code>$N^{d_{vc}}$</code>来控制住所有vc dimension的假设集合的成长函数，对于任意一个从<code>$\mathcal H$</code>中的g有：<br></p>
<blockquote>
<p><code>$\begin{aligned}
&amp;\;\;\;\,\mathbb{P}[|E_{in}(g) - E_{out}(g)\gt \epsilon|] \\\
&amp;\leq \mathbb{P}[BAD]\\\
&amp;= \mathbb{P}[\exists h \in \mathcal{H}\text{ s.t. } |E_{in}(h)-E_{out}(h)|\gt \epsilon] \\\
&amp;\leq 4m_{\mathcal{H}}(2N)exp(-\frac{1}{8}\epsilon^2N) \\\
&amp;\leq 4(2N)^{d_{vc}}exp(-\frac{1}{8}\epsilon^2N) \\\
&amp;\textit{( if }d_{vc}\textit{ is finite )}
\end{aligned}$</code></p>
</blockquote>
<p>让机器学习学到东西，有三个条件：</p>
<ul>
<li><code>$\mathcal H$</code>的<code>$d_{vc}$</code>是有限的，vcBound才存在;(good <code>$\mathcal H$</code>)</li>
<li>N足够大(对于特定<code>$d_{vc}$</code>)，这样才能保证上面不等式bound不会太大(good <code>$\mathcal D</code>)</li>
<li>算法<code>$\mathcal A$</code>有办法从<code>$\mathcal H$</code>挑一个使得<code>$E_{in}$</code>最小的方程g(good <code>$\mathcal A$</code>)</li>
</ul>
<p>很多情况都只考虑第三点，忽略了前两点，在traing set表现的还好，在test set表现不好，目前只关注前两点。</p>
<h4 id="3、简单-复杂"><a href="#3、简单-复杂" class="headerlink" title="3、简单 复杂"></a>3、简单 复杂</h4><p>lerning最关注的两个问题：1、能否使<code>$E_{in}$</code>和<code>$E_{out}$</code>很接近；2、能否使<code>$E_{in}$</code>足够小；</p>
<ul>
<li>对于相同的<code>$\mathcal D$</code>而言，<code>$d_{vc}$</code>小的模型，vc bound比较小，容易保证<code>$E_{in}$</code>和<code>$E_{out}$</code>很接近，很难做到较小的<code>$E_{in}$</code>.</li>
<li>对于相同<code>$\mathcal D$</code>而言，<code>$d_{vc}$</code>大的模型，比较容易实现小的<code>$E_{in}$</code>，但是VC Bound很大，很难保证模型对<code>$\mathcal D$</code>之外的世界也能有同样强的预测能力</li>
</ul>
<p>令之前得到的VC Bound为<code>$\delta$</code>,误差数据<code>$[|E_{in}(g)-E_{out}(g)|\gt \epsilon]$</code>发生概率小于<code>$\delta$</code>，则正常数据<code>$[|E_{in}(g)-E_{out}(g)|\leq \epsilon]$</code>发生概率大于置信度<code>$1-\delta$</code><br><br><code>$\begin{aligned}
\text{set}\;\;\;\;\delta &amp;= 4(2N)^{d_{vc}}exp(-\frac{1}{8}\epsilon^2N)\\\
\sqrt{\frac{8}{N}ln(\frac{4(2N)^{d_{vc}}}{\delta})} &amp;= \epsilon
\end{aligned}$</code><br></p>
<p>因此<code>$E_{in}$</code>和<code>$E_{out}$</code>有如下关系：<br><br><code>$E_{in}(g)-\sqrt{\frac{8}{N}ln(\frac{4(2N)^{d_{vc}}}{\delta})} \leq E_{out}(g) \leq E_{in}(g)+\sqrt{\frac{8}{N}ln(\frac{4(2N)^{d_{vc}}}{\delta})}$</code></p>
<p>令<code>$\Omega (N,\mathcal{H},\delta)=\sqrt{...}$</code>，即可得到模型越复杂，<code>$E_{in}$</code>与<code>$E_{out}$</code>离的越远。</p>
<p><img src="https://note.youdao.com/yws/public/resource/09bc4f7ae923faa6ab39481ed0af755f/xmlnote/WEBRESOURCE682053125a48af2ebf41b5bf21f14fc8/32890" alt="image"></p>
<p>随着<code>$d_{vc}$</code>上升<code>$E_{in}$</code>不断降低，<code>$\Omega</code>不断上升，上升与下降的速度在每个阶段都是不同的，因此我们能够寻找一个二者兼顾的，比较合适的<code>$d_{vc}^{*}$</code>，用来决定应该使用多复杂的模型。</p>
<p>反过来，如果我们需要使用 <code>$d_{vc}=3$</code>这种复杂程度的模型，并且想保证 ϵ=0.1 ，置信度 1−δ=90% ，可以通过VC Bound来求得大致需要的数据量 N 。通过简单的计算可以得到理论上，我们需要 N≈10,000<code>$d_{vc}$</code>数据，但VC Bound事实上是一个极为宽松的bound，因为它对于任何演算法<code>$\mathcal{A}$</code>，任何分布的数据，任何目标函数 f 都成立，所以经验上，常常认为 N≈10dvc 就可以有不错的结果。</p>
<p>备用图片地址：<a href="http://beader.me/mlnotebook/section2/images/model_complexity_curve.png" target="_blank" rel="noopener">http://beader.me/mlnotebook/section2/images/model_complexity_curve.png</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/06/24/乘飞机概率题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/24/乘飞机概率题/" itemprop="url">乘飞机概率题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-24T21:34:01+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="丢失的机票"><a href="#丢失的机票" class="headerlink" title="丢失的机票"></a>丢失的机票</h4><blockquote>
<p>一架客机上有100个座位，100个人排队依次登机。第一个乘客把机票搞丢了，但他仍被允许登机。由于他不知道他的座位在哪儿，他就随机选了一个座位坐下。以后每一个乘客登机时，如果他的座位是空着的，那么就在他的座位坐下；否则，他就随机选一个仍然空着的座位坐下。请问，最后一个人登机时发现唯一剩下的空位正好就是他的，其概率是多少？</p>
</blockquote>
<p>当最后一个乘客登机时，最后一个空位要么就是他的，要么就是第一个乘客的。由于所有人选择座位时都是随机选择的，这两个位置的“地位”相等，它们所面对的“命运”是相同的，不存在哪个概率大哪个概率小的问题。因此，它们成为最后一个空位的概率是均等的。也就是说，最后一个人发现剩下的空位正好是他的，其概率为50%</p>
<h4 id="2、重复排列"><a href="#2、重复排列" class="headerlink" title="2、重复排列"></a>2、重复排列</h4><p>从各不相同的m个元素中选n个（可以重复）进行组合，有多少种？公式是：C(n,m+n-1)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/06/22/有趣概率题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/有趣概率题/" itemprop="url">几道有趣的数学题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T21:48:29+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、十个人赛跑第一名和一百人赛跑的第十名谁厉害？"><a href="#1、十个人赛跑第一名和一百人赛跑的第十名谁厉害？" class="headerlink" title="1、十个人赛跑第一名和一百人赛跑的第十名谁厉害？"></a>1、十个人赛跑第一名和一百人赛跑的第十名谁厉害？</h4><blockquote>
<p>等价于：从(0,1)区间上随机抽10个样本，最大值为a，再从(0,100)随机抽100个样本，其中排名第10的样本值为a，在从(0,100)随机抽取100个样本，排名第10的样本为b，在数学期望意义下，a与b大小关系；</p>
</blockquote>
<ul>
<li><p>从(0,1)随机抽10个样本，10个点将线段分为11段，每一条线段长度数学期望为1/11，最长那个点长度数学期望为11/10。</p>
</li>
<li><p>同样从(0,100)取100个样本，每条期望1/101，那么从大到小第10名数学期望91/101，很明显11/10大于91/101.</p>
</li>
</ul>
<h5 id="10人中第一名，相当于100人中第几名？"><a href="#10人中第一名，相当于100人中第几名？" class="headerlink" title="10人中第一名，相当于100人中第几名？"></a>10人中第一名，相当于100人中第几名？</h5><p>10/11 = x/1001,得x=91.818，101-91.818=9.182.</p>
<h4 id="2、抛硬币直到出现连续N次正面为止的期望"><a href="#2、抛硬币直到出现连续N次正面为止的期望" class="headerlink" title="2、抛硬币直到出现连续N次正面为止的期望"></a>2、抛硬币直到出现连续N次正面为止的期望</h4><blockquote>
<p>抛一个硬币，抛出正面/背面概率都是0.5，连续抛硬币知道连续出现三次正面为止，平均要抛多少次才能结束游戏？</p>
</blockquote>
<p>假设已经连续抛出n-1次正面，需要<code>$T_{n-1}$</code>次，想要得到n次正面，再进行一次投掷，则可得到:<br><code>$T_n=T_{n-1}+1+0.5*0+0.5*T_n$</code></p>
<p>通项公式为：<br><code>$T_n=2^{n+1}-2$</code></p>
<h4 id="3、圆上任选三点组成三角形，这个三角形是锐角、钝角和直角三角形的概率分别是多少？"><a href="#3、圆上任选三点组成三角形，这个三角形是锐角、钝角和直角三角形的概率分别是多少？" class="headerlink" title="3、圆上任选三点组成三角形，这个三角形是锐角、钝角和直角三角形的概率分别是多少？"></a>3、圆上任选三点组成三角形，这个三角形是锐角、钝角和直角三角形的概率分别是多少？</h4><p>锐角三角形的概率是1/4，钝角三角形的概率是3/4，直角三角形的概率是0。</p>
<p>一个锐角三角形对应三个钝角三角形：<br><img src="https://note.youdao.com/yws/public/resource/4f22a1ce6c5d0743fdab37b6e4d32094/xmlnote/DA67508B978D47C5A1CEC293A1DFE99F/32596" alt="image"></p>
<p>也可以用积分来运算：<br><code>$\int_0^{\pi}\frac{\alpha}{2\pi}\frac{1}{\pi} =1/4$</code></p>
<p>参考文档：<a href="https://zhuanlan.zhihu.com/p/69530841" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69530841</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/05/14/寻找概率超过一半的数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/寻找概率超过一半的数/" itemprop="url">寻找概率超过一半的数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-14T21:36:02+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="现在有一数组存放int型整数，数字有重复，且有一数字出现的频率超过了50-，请找出这个数字，假如数据量很大。"><a href="#现在有一数组存放int型整数，数字有重复，且有一数字出现的频率超过了50-，请找出这个数字，假如数据量很大。" class="headerlink" title="现在有一数组存放int型整数，数字有重复，且有一数字出现的频率超过了50%，请找出这个数字，假如数据量很大。"></a>现在有一数组存放int型整数，数字有重复，且有一数字出现的频率超过了50%，请找出这个数字，假如数据量很大。</h5><p>这是一道很简单的题，但是怎样在O（N）时间复杂度内解决？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun findMost(num: IntArray): Int &#123;</span><br><span class="line">    var choose = 0</span><br><span class="line">    var count = 0</span><br><span class="line">    for (i in 0 until num.size) &#123;</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            choose = num[i]</span><br><span class="line">            count = 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (choose == num[i])</span><br><span class="line">                count++</span><br><span class="line">            else</span><br><span class="line">                count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return choose</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>体现了计算机科学中一种很普遍的思想，就是把一个问题转化为规模较小的若干个问题。分治、递归、贪心等都是基于这样的思想。转化的效率越高，转化之后问题的规模缩小的越快，则正题的时间复杂度越低。</p>
<blockquote>
<p>现在数组中没有出现频率一半的数字了，但有三个都超过了四分之一,找到它们。仿照上题，每次去掉四个不同的数字即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var chooseA = 0</span><br><span class="line">var chooseB = 0</span><br><span class="line">var chooseC = 0</span><br><span class="line">fun findMost(num: IntArray) &#123;</span><br><span class="line">    var countA = 0</span><br><span class="line">    var countB = 0</span><br><span class="line">    var countC = 0</span><br><span class="line">    for (i in 0 until num.size) &#123;</span><br><span class="line">        if (countA == 0 || countB == 0 || countC == 0) &#123;</span><br><span class="line">            if (countA == 0) &#123;</span><br><span class="line">                if (countB != 0 &amp;&amp; num[i] == chooseB) &#123;</span><br><span class="line">                    countB++</span><br><span class="line">                &#125; else if (countC != 0 &amp;&amp; num[i] == chooseC) &#123;</span><br><span class="line">                    countC++</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    chooseA = num[i]</span><br><span class="line">                    countA++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (countB == 0) &#123;</span><br><span class="line">                if (countA != 0 &amp;&amp; num[i] == chooseA)</span><br><span class="line">                    countA++</span><br><span class="line">                else if (countC != 0 &amp;&amp; num[i] == chooseC)</span><br><span class="line">                    countC++</span><br><span class="line">                else &#123;</span><br><span class="line">                    chooseB = num[i]</span><br><span class="line">                    countB++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (countC == 0) &#123;</span><br><span class="line">                if (countA != 0 &amp;&amp; num[i] == chooseA)</span><br><span class="line">                    countA++</span><br><span class="line">                else if (countB != 0 &amp;&amp; num[i] == chooseB)</span><br><span class="line">                    countB++</span><br><span class="line">                else &#123;</span><br><span class="line">                    chooseC = num[i]</span><br><span class="line">                    countC++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (num[i] == chooseA)</span><br><span class="line">                countA++</span><br><span class="line">            else if (num[i] == chooseB) &#123;</span><br><span class="line">                countB++</span><br><span class="line">            &#125; else if (num[i] == chooseC) &#123;</span><br><span class="line">                countC++</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                countA--</span><br><span class="line">                countB--</span><br><span class="line">                countC--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>来自：<a href="https://www.cnblogs.com/jy02414216/archive/2011/03/04/1970497.html" target="_blank" rel="noopener">https://www.cnblogs.com/jy02414216/archive/2011/03/04/1970497.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/04/13/选方格算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/选方格算法/" itemprop="url">选算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-13T14:15:13+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="在方阵中选取若干个格子使得任意两个不相邻。"><a href="#在方阵中选取若干个格子使得任意两个不相邻。" class="headerlink" title="在方阵中选取若干个格子使得任意两个不相邻。"></a>在方阵中选取若干个格子使得任意两个不相邻。</h5><p>比如有一行数据，3个格子，有多少种方案<br>|编号|状态|二进制|<br>|—|—|—|<br>|1|0 0 0|0|<br>|2|0 0 1|1|<br>|3|0 1 0|2|<br>|4|1 0 0|4|<br>|5|1 0 1|5|</p>
<p><strong>用一个数表示一组数，降低表示状态所需要的维数，就叫状态压缩</strong></p>
<p>考虑了第一行以后，考虑第二行。当第二行和第一行数据一样时：</p>
<ul>
<li>假如第二行三个格子都不放，则就是第一行的方案；</li>
<li>当第二行放格子时，可得到4中可行方案；</li>
</ul>
<p>可以得到状态关系：<br><strong>dp[i][state[j)]来表示对于前i行，第i行第j种状态时可以得到的可行方案总数。</strong></p>
<p>比如：dp[2][1]代表第二行使用(0 1 0)可得的方案数。</p>
<p>可以得到状态转移方程：<br><strong>dp[i][state(j)]=dp[i-1][state(k1)]+dp[i-1][state(k2)]+……+dp[i-1][state(kn)](kn即为上一行可行状态的编号，上一行共有n种可行状态）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//行数</span><br><span class="line">val m = 2</span><br><span class="line">//列数</span><br><span class="line">val n = 2</span><br><span class="line">//共有多少种可行的状态</span><br><span class="line">var top = 0</span><br><span class="line">//state存放每行所有的可行状态（即没有相邻的状态</span><br><span class="line">val state = IntArray(600)</span><br><span class="line">//dp[i][j]:对于前i行数据，每行有前j种可能状态时的解</span><br><span class="line">val dp = Array(20) &#123;</span><br><span class="line">    IntArray(600)</span><br><span class="line">&#125;</span><br><span class="line">//cur[i]表示的是第i行整行的情况</span><br><span class="line">val cur = IntArray(20)</span><br><span class="line"></span><br><span class="line">fun ok(x: Int): Boolean &#123;</span><br><span class="line">    val temp = x and (x shl 1)</span><br><span class="line">    //如果有相邻说明这个状态不行</span><br><span class="line">    if (temp &gt; 0) return false</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun init() &#123;</span><br><span class="line">    top = 0</span><br><span class="line">    val total = 1 shl n //遍历状态上界</span><br><span class="line">    for (i in 0 until total) &#123;</span><br><span class="line">        if (ok(i)) &#123;</span><br><span class="line">            state[++top] = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() &#123;</span><br><span class="line">    init()</span><br><span class="line">    for (i in 1..top) &#123;</span><br><span class="line">        dp[1][i] = 1</span><br><span class="line">    &#125;</span><br><span class="line">    for (i in 2..m) &#123;</span><br><span class="line">        for (k in 1..top) &#123;</span><br><span class="line">            for (j in 1..top) &#123;</span><br><span class="line">                if ((state[k] and state[j]) &gt; 0) continue</span><br><span class="line">                dp[i][k] = (dp[i][k] + dp[i - 1][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var ans = 0</span><br><span class="line">    for (i in 1..top) &#123;</span><br><span class="line">        ans += dp[m][i]</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;sum $ans&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果方格中有部分位置不能选呢，只需要做少量改动即可。</p>
</blockquote>
<p>增加一个curr数组，和fit函数，判断当前状态是否符合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package test.base</span><br><span class="line">//行数</span><br><span class="line">val m = 2</span><br><span class="line">//列数</span><br><span class="line">val n = 2</span><br><span class="line">//共有多少种可行的状态</span><br><span class="line">var top = 0</span><br><span class="line">//state存放每行所有的可行状态（即没有相邻的状态</span><br><span class="line">val state = IntArray(600)</span><br><span class="line">//dp[i][j]:对于前i行数据，每行有前j种可能状态时的解</span><br><span class="line">val dp = Array(20) &#123;</span><br><span class="line">    IntArray(600)</span><br><span class="line">&#125;</span><br><span class="line">//cur[i]表示的是第i行整行的情况</span><br><span class="line">val cur = IntArray(20)</span><br><span class="line"></span><br><span class="line">fun ok(x: Int): Boolean &#123;</span><br><span class="line">    val temp = x and (x shl 1)</span><br><span class="line">    //如果有相邻说明这个状态不行</span><br><span class="line">    if (temp &gt; 0) return false</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun init() &#123;</span><br><span class="line">    top = 0</span><br><span class="line">    val total = 1 shl n //遍历状态上界</span><br><span class="line">    for (i in 0 until total) &#123;</span><br><span class="line">        if (ok(i)) &#123;</span><br><span class="line">            state[++top] = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun fit(x: Int, k: Int): Boolean &#123;  //判断状态x 与第k行的实际状态的逆是否有‘重合’</span><br><span class="line">    if ((x and (cur[k]) &gt; 0)) return false //若有重合 x不符合要求</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    init()</span><br><span class="line">    for (i in 1..top) &#123;</span><br><span class="line">        if (fit(state[i],1)) &#123;</span><br><span class="line">            dp[1][i] = 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(i in 2..m)&#123;</span><br><span class="line">        for(k in 1..top)&#123;</span><br><span class="line">            if(!fit(state[k],i)) continue</span><br><span class="line">            for(j in 1..top)&#123;</span><br><span class="line">                if(!fit(state[j],i-1)) continue</span><br><span class="line">                if((state[k] and state[j])&gt;0) continue</span><br><span class="line">                dp[i][k] = (dp[i][k]+dp[i-1][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var ans = 0</span><br><span class="line">    for(i in 1..top)&#123;</span><br><span class="line">        ans += dp[m][i]</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;sum $ans&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>来自 <a href="https://blog.csdn.net/harrypoirot/article/details/23163485" target="_blank" rel="noopener">https://blog.csdn.net/harrypoirot/article/details/23163485</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/25/骑士拨号器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/骑士拨号器/" itemprop="url">骑士拨号器算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T22:49:02+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="题目，一个拨打电话的面板，每次只能按照“L”形状移动，水平两步-gt-垂直一步-或水平一步-gt-垂直两步，方向不限制。那么在N跳范围内，能够拨打多少种不同的号码？"><a href="#题目，一个拨打电话的面板，每次只能按照“L”形状移动，水平两步-gt-垂直一步-或水平一步-gt-垂直两步，方向不限制。那么在N跳范围内，能够拨打多少种不同的号码？" class="headerlink" title="题目，一个拨打电话的面板，每次只能按照“L”形状移动，水平两步-&gt;垂直一步,或水平一步-&gt;垂直两步，方向不限制。那么在N跳范围内，能够拨打多少种不同的号码？"></a>题目，一个拨打电话的面板，每次只能按照“L”形状移动，水平两步-&gt;垂直一步,或水平一步-&gt;垂直两步，方向不限制。那么在N跳范围内，能够拨打多少种不同的号码？</h5><p><code>$\begin{matrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 &amp;\\  &amp; 0 &amp;  \end{matrix}$</code></p>
<h5 id="第一种，递归"><a href="#第一种，递归" class="headerlink" title="第一种，递归"></a>第一种，递归</h5><p>用map存储跳数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val map = mapOf(1 to listOf(6, 8),</span><br><span class="line">        2 to listOf(7, 9),</span><br><span class="line">        3 to listOf(4, 8),</span><br><span class="line">        4 to listOf(3, 9, 0),</span><br><span class="line">        5 to emptyList(),</span><br><span class="line">        6 to listOf(1,7,0),</span><br><span class="line">        7 to listOf(2,6),</span><br><span class="line">        8 to listOf(1,3),</span><br><span class="line">        9 to listOf(2,4),</span><br><span class="line">        0 to listOf(4,6)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p>
<p>算法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private val map = mapOf(1 to listOf(6, 8),</span><br><span class="line">        2 to listOf(7, 9),</span><br><span class="line">        3 to listOf(4, 8),</span><br><span class="line">        4 to listOf(3, 9, 0),</span><br><span class="line">        5 to emptyList(),</span><br><span class="line">        6 to listOf(1, 7, 0),</span><br><span class="line">        7 to listOf(2, 6),</span><br><span class="line">        8 to listOf(1, 3),</span><br><span class="line">        9 to listOf(2, 4),</span><br><span class="line">        0 to listOf(4, 6)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fun getSequence(start: Int, count: Int, sequence: String?, list: ArrayList&lt;String&gt;) &#123;</span><br><span class="line">    var temp = count</span><br><span class="line">    var result = sequence</span><br><span class="line">    if (result == null) result = &quot;$start&quot;</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">        list.add(result)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    val neighbors = map[start] ?: return</span><br><span class="line">    temp--</span><br><span class="line">    for (neighbor in neighbors) &#123;</span><br><span class="line">        getSequence(neighbor, temp, result + neighbor, list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val list = arrayListOf&lt;String&gt;()</span><br><span class="line">    getSequence(6,2,null,list)</span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">    println(list.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="第二种-不通过计算得到号码个数"><a href="#第二种-不通过计算得到号码个数" class="headerlink" title="第二种 不通过计算得到号码个数"></a>第二种 不通过计算得到号码个数</h5><p>其实完全不需要统计这些不同的电话号码，可以节省部分空间复杂度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun getSequence(start: Int, count: Int, sequence: String?): Int &#123;</span><br><span class="line">    var total = 0</span><br><span class="line">    var temp = count</span><br><span class="line">    var result = sequence</span><br><span class="line">    if (result == null) result = &quot;$start&quot;</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    val neighbors = map[start] ?: return 0</span><br><span class="line">    temp--</span><br><span class="line">    for (neighbor in neighbors) &#123;</span><br><span class="line">        total += getSequence(neighbor, temp, result + neighbor)</span><br><span class="line">    &#125;</span><br><span class="line">    return total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(getSequence(6, 2, null))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="第三种-记忆化"><a href="#第三种-记忆化" class="headerlink" title="第三种 记忆化"></a>第三种 记忆化</h5><p>当时间复杂度很高，考虑以空间换时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun getSequence(start: Int, count: Int, cache: HashMap&lt;Pair&lt;Int,Int&gt;, Long&gt;): Long &#123;</span><br><span class="line">    var total = 0L</span><br><span class="line">    var temp = count</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    val neighbors = map[start] ?: return 0</span><br><span class="line">    temp--</span><br><span class="line">    for (neighbor in neighbors) &#123;</span><br><span class="line">        val meta = cache[Pair(neighbor,temp)]</span><br><span class="line">        if (meta == null) &#123;</span><br><span class="line">            val number = getSequence(neighbor, temp, cache)</span><br><span class="line">            cache[Pair(neighbor,temp)] = number</span><br><span class="line">            total += number</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            total += meta</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val cache = HashMap&lt;Pair&lt;Int,Int&gt;, Long&gt;()</span><br><span class="line">    println(getSequence(6, 25, cache))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="第四种-动态规划"><a href="#第四种-动态规划" class="headerlink" title="第四种 动态规划"></a>第四种 动态规划</h5><p>记忆化搜索，内存空间会线性增长，仍然不是最高效的，可以换一种新方法，先计算N-1，再计算N挑，从后往前算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fun getSequence(start: Int, count: Int): Long &#123;</span><br><span class="line">    var current = 1</span><br><span class="line">    var currentCase = Array(10) &#123;</span><br><span class="line">        0L</span><br><span class="line">    &#125;</span><br><span class="line">    var priorCase = Array(10) &#123; 1L &#125;</span><br><span class="line">    while (current &lt;= count) &#123;</span><br><span class="line">        currentCase = Array(10) &#123; 0L &#125;</span><br><span class="line">        current++</span><br><span class="line">        for (position in 0..9) &#123;</span><br><span class="line">            val meta = map[position]</span><br><span class="line">            if (meta != null) &#123;</span><br><span class="line">                for (neighbor in meta)</span><br><span class="line">                    currentCase[position] += priorCase[neighbor]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        priorCase = currentCase</span><br><span class="line">    &#125;</span><br><span class="line">    return currentCase[start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val begin = System.nanoTime()</span><br><span class="line">    println(getSequence(6, 55))</span><br><span class="line">    val end = System.nanoTime()</span><br><span class="line">    println((end - begin) / (1000 * 1000))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相比上一种方案时间复杂度是差不多的，但是也有优点：非递归，可以运行非常大跳数，不会崩溃；使用固定内存，缓存不会增长。</p>
<p>在面试中设计和实现线性时间、恒定空间的解决方案是一个非常好的结果。总是会给那些能够提供动态规划解决方案的候选人一个很好的评价。</p>
<h5 id="第五种-矩阵快速幂"><a href="#第五种-矩阵快速幂" class="headerlink" title="第五种 矩阵快速幂"></a>第五种 矩阵快速幂</h5><p>这种计算幂指数的，可以利用快速幂来计算，矩阵的幂表示无向图中的步数。</p>
<blockquote>
<p><code>$B^m$</code>(2≤m≤n)中位于 i 行 j 列(0≤i，j≤n-1)的非零元素的含义是:图中从顶点 i 到顶点 j 长度为 m 的路径条数</p>
</blockquote>
<p>python写的函数如下（来自<a href="https://leetcode.com/problems/knight-dialer/discuss/189252/O" target="_blank" rel="noopener">https://leetcode.com/problems/knight-dialer/discuss/189252/O</a>(logN）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def knightDialer(self, N):</span><br><span class="line">        mod = 10**9 + 7</span><br><span class="line">        if N == 1: return 10</span><br><span class="line">        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],</span><br><span class="line">                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],</span><br><span class="line">                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],</span><br><span class="line">                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],</span><br><span class="line">                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],</span><br><span class="line">                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span><br><span class="line">                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],</span><br><span class="line">                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],</span><br><span class="line">                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],</span><br><span class="line">                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])</span><br><span class="line">        res, N = 1, N - 1</span><br><span class="line">        while N:</span><br><span class="line">            if N % 2: res = res * M % mod</span><br><span class="line">            M = M * M % mod</span><br><span class="line">            N /= 2</span><br><span class="line">        return int(np.sum(res)) % mod</span><br></pre></td></tr></table></figure></p>
<p>节选自：知乎用户tom pareto<br>这道题，挺有意思的，正好说明计算机算法和设计计算机算法是怎么一回事：</p>
<p>（1）讨论：解决小规模问题，找到模式和边界情况。这是什么意思，要怎么做？数字序列又是什么？——数量化。如果不进行数量化，就没有办法使计算机工作，计算机只能进行数量的计算。</p>
<p>（2）下一跳：占位符、空函数、函数桩、map等等，为什么要这样做？计算机擅长于有明显规律的重复性的工作。在我们还没找到重复性规律之前，不妨先假设存在这么一种重复性规律好了。然后，我们再进行观察、猜测、归纳这种重复性规律。显然：</p>
<p>（3）编程实现与优化。这就很“常规”了。</p>
<p>算法设计与实现，没有什么神秘的。一切在于数字电子计算机的最基本的物理器件——基于布尔代数的加法器。只要计算机的物理基础还是线性运算的加法器，那么计算机的基本计算方式方法就只能是反复地进行重复性工作。而我们人类，就是先从问题中抽取数量，或者量化问题，然后观察、猜测、归纳这些数量之间的递推关系（就是高中学过的数学归纳法）。然后再编程实现。在编程实现中，进一步优化。而要优化，那么就会利用计算机的器件特性。只要经过大量的科学训练，一个高中数学学得还可以的人，就能够进入算法的殿堂。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/24/矩阵快速幂/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/矩阵快速幂/" itemprop="url">矩阵快速幂</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T21:33:13+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="1、如何有效提高指数幂的时间复杂度？比如计算-2-100-，有人肯定会说时间复杂度是O-N-，但是最好的快速幂算法是O-logN-，运用到矩阵中就是矩阵快速幂算法。"><a href="#1、如何有效提高指数幂的时间复杂度？比如计算-2-100-，有人肯定会说时间复杂度是O-N-，但是最好的快速幂算法是O-logN-，运用到矩阵中就是矩阵快速幂算法。" class="headerlink" title="1、如何有效提高指数幂的时间复杂度？比如计算$2^{100}$，有人肯定会说时间复杂度是O(N)，但是最好的快速幂算法是O(logN)，运用到矩阵中就是矩阵快速幂算法。"></a>1、如何有效提高指数幂的时间复杂度？比如计算<code>$2^{100}$</code>，有人肯定会说时间复杂度是O(N)，但是最好的快速幂算法是O(logN)，运用到矩阵中就是矩阵快速幂算法。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun quickPow(a: Int, b: Int): Long &#123;</span><br><span class="line">    var ans = 1L</span><br><span class="line">    var temp = a</span><br><span class="line">    var base = b</span><br><span class="line">    while (base != 0) &#123;</span><br><span class="line">        if (base and 1 != 0) &#123;</span><br><span class="line">            ans *= temp</span><br><span class="line">        &#125;</span><br><span class="line">        temp *= temp</span><br><span class="line">        base = base shr 1</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(quickPow(2, 10))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>比如之前计算<code>$2^{10}$</code>，要计算10次，现在首先计算<code>$2*2=2^2$</code>,第二次<code>$2^2*2^2=2^4$</code>，第三次<code>$2^4*2^4=2^8$</code>，这样就大大减少了时间复杂度。</p>
</blockquote>
<h5 id="2、从快速幂到矩阵快速幂"><a href="#2、从快速幂到矩阵快速幂" class="headerlink" title="2、从快速幂到矩阵快速幂"></a>2、从快速幂到矩阵快速幂</h5><p>本质上就是讲算式转化为矩阵形式，比如下题：</p>
<p><code>$F(i)=F(i-1)+F(i-2)+i^3+i^2+i+1,i&gt;1,F(0)=0,F(1)=1$</code></p>
<p>我们就需要找到一个矩阵A，使<code>$A^{n-1}F(1)=F(n)$</code>,其实矩阵A为：</p>
<p><code>$\left[ \begin{matrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 3 &amp; 3 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 2 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \end{matrix} \right]$</code></p>
<p>当指数为0时，初始化一个单位矩阵，任何矩阵乘以单位矩阵都是其本身。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/20/数据流中位数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/数据流中位数/" itemprop="url">数据流中位数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T22:03:14+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="如何从数据流得到一个中位数？"><a href="#如何从数据流得到一个中位数？" class="headerlink" title="如何从数据流得到一个中位数？"></a>如何从数据流得到一个中位数？</h5><ul>
<li>数组/链表忽略</li>
<li>二叉搜索树，可以把插入新数据平均时间降到O(logN)，当极度不平衡时，插入新数据仍是O(N)；可以将其升级为平衡二叉树AVL，可以在O(logN)时间往AVL添加一个新结点，用O(1)得到中位数；</li>
<li>可以用两个堆实现。如果能保证数据容器左边的数据小于右边数据，即使两边没有排序，也能根据左边最大和右边最小的数得到中位数。往堆中插入数据时间复杂度为O(logN)。</li>
</ul>
<p>利用堆实现的步骤：</p>
<blockquote>
<p>将新数据插入到最大堆，把最大堆的最大数字拿出来插入到最小堆。由于最终插入到最小堆的数字是原最大堆中最大的数字，就保证最小堆大于最大堆数字。</p>
</blockquote>
<p>堆的实现代码：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> cmp: Comparator&lt;T&gt;) &#123;</span><br><span class="line">    <span class="comment">//堆中存放的数据集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span> = ArrayList&lt;T&gt;(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向上调整堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 被上移元素位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">shiftUp</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> idx = index</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= <span class="keyword">data</span>.size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"<span class="variable">$idx</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> intent = <span class="keyword">data</span>[idx]</span><br><span class="line">        <span class="comment">//如果不是根元素 需要上移</span></span><br><span class="line">        <span class="keyword">while</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> parentIdx = (idx - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> parent = <span class="keyword">data</span>[parentIdx]</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(intent, parent) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">data</span>[idx] = parent</span><br><span class="line">                idx = parentIdx</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">data</span>[idx] = intent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 向下调整堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">shiftDown</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> idx = index</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt; <span class="keyword">data</span>.size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"<span class="variable">$idx</span> error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> intent = <span class="keyword">data</span>[idx]</span><br><span class="line">        <span class="keyword">var</span> leftIdx = idx * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (leftIdx &lt; <span class="keyword">data</span>.size) &#123;</span><br><span class="line">            <span class="keyword">var</span> maxChild = <span class="keyword">data</span>[leftIdx]</span><br><span class="line">            <span class="keyword">var</span> maxIdx = leftIdx</span><br><span class="line">            <span class="keyword">val</span> rightIdx = leftIdx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (rightIdx &lt; <span class="keyword">data</span>.size) &#123;</span><br><span class="line">                <span class="keyword">val</span> rightChild = <span class="keyword">data</span>[rightIdx]</span><br><span class="line">                <span class="keyword">if</span> (cmp.compare(rightChild, maxChild) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    maxChild = rightChild</span><br><span class="line">                    maxIdx = rightIdx</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(maxChild, intent) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">data</span>[idx] = maxChild</span><br><span class="line">                idx = maxIdx</span><br><span class="line">                leftIdx = <span class="number">2</span> * idx + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">data</span>[idx] = intent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 添加一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(item: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.add(item)</span><br><span class="line">        shiftUp(<span class="keyword">data</span>.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 删除堆顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteTop</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"the heap is empty"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> first = <span class="keyword">data</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">val</span> last = <span class="keyword">data</span>.removeAt(<span class="keyword">data</span>.size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">data</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            last</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">data</span>[<span class="number">0</span>] = last</span><br><span class="line">            shiftDown(<span class="number">0</span>)</span><br><span class="line">            first</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 获取堆顶元素 不删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTop</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">data</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"the heap is empty"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 获取堆大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">size</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 堆是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 清空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 获取堆中数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getData</span><span class="params">()</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Median</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> max = Heap&lt;<span class="built_in">Int</span>&gt;(Comparator &#123; p0, p1 -&gt;</span><br><span class="line">        p0 - p1</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> min = Heap&lt;<span class="built_in">Int</span>&gt;(Comparator &#123; p0, p1 -&gt;</span><br><span class="line">        p1 - p0</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="keyword">data</span></span><br><span class="line">        <span class="comment">//已经有偶数个数据 or 0</span></span><br><span class="line">        <span class="comment">//数据是偶数个 把数据插到小堆里面</span></span><br><span class="line">        <span class="keyword">if</span> ((min.size() + max.size()) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//大堆有数据 并且插入的元素比大堆元素小</span></span><br><span class="line">            <span class="keyword">if</span> (max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max.getTop()) &#123;</span><br><span class="line">                <span class="comment">//将num放入大堆</span></span><br><span class="line">                max.add(num)</span><br><span class="line">                num = max.deleteTop()</span><br><span class="line">            &#125;</span><br><span class="line">            min.add(num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//数据总数是奇数 数据插到大堆</span></span><br><span class="line">            <span class="comment">//小堆有数据 并且插入的元素比小堆中元素大</span></span><br><span class="line">            <span class="keyword">if</span> (min.size() &gt; <span class="number">0</span> &amp;&amp; num &gt; min.getTop()) &#123;</span><br><span class="line">                min.add(num)</span><br><span class="line">                num = min.deleteTop()</span><br><span class="line">            &#125;</span><br><span class="line">            max.add(num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMedian</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> size = max.size() + min.size()</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"no numbers"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> ((size and <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            min.getTop().toDouble()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            (max.getTop() + min.getTop()) / <span class="number">2.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(<span class="keyword">vararg</span> args: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> array = Median()</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">34</span>,<span class="number">42</span>)</span><br><span class="line">    list.forEach &#123;</span><br><span class="line">        array.insert(it)</span><br><span class="line">        println(array.getMedian())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hcyxy.tech/2019/03/16/系统上运行程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hecy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无病呻吟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/系统上运行程序/" itemprop="url">计算机系统(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T21:14:20+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index">
                    <span itemprop="name">计算机系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第二部分-系统上运行程序"><a href="#第二部分-系统上运行程序" class="headerlink" title="第二部分 系统上运行程序"></a>第二部分 系统上运行程序</h3><h4 id="7、链接"><a href="#7、链接" class="headerlink" title="7、链接"></a>7、链接</h4><p>将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载到内存并执行。链接可用于编译时(源代码-&gt;机器代码)，加载时，加载到内存并执行；执行于运行时，由应用执行。</p>
<h5 id="7-1-静态链接"><a href="#7-1-静态链接" class="headerlink" title="7.1 静态链接"></a>7.1 静态链接</h5><p>静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。链接器必须完成两个任务：</p>
<ul>
<li>符号解析。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。</li>
<li>重定位。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，重定位这些节，修改对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件。包含二进制代码和数据，在编译时与其他可重定位文件合并起来，创建一个可执行目标文件</li>
<li>可执行目标文件。包含二进制代码和数据，可以直接复制到内存执行；</li>
<li>共享目标文件。特殊的可重定位目标文件，可以在加载或者运行时被动态的加载进内存并链接。</li>
</ul>
<p>编译器和汇编器可重定位目标文件(包括共享目标文件)，链接器生成可执行目标文件。</p>
<h5 id="7-2-与静态库链接"><a href="#7-2-与静态库链接" class="headerlink" title="7.2 与静态库链接"></a>7.2 与静态库链接</h5><p>之前都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上所有编译系统都提供一种机制将所有相关目标模块打包成一个单独文件，称为<strong>静态库，可以用做链接器的输入</strong>。当链接器构造一个输出的可执行文件，只复制静态库里被应用程序引用的目标模块。</p>
<p><strong>为什么OS要支持库的概念？</strong><br><br>定义了一组广泛的标准I/O、字符串操作和整数数学函数。如果不适用静态库，如何向用户提供这些函数。一：让编译器辨认出对标准函数的调用，并直接生成响应代码，对c不适合，因为c标准定义了大量标准函数，这种方法给编译器增加了复杂性，每次添加删除或修改标准函数，就需要一个新的编译器版本。</p>
<p>另一种方法：将所有标准C函数放在一个单独可重定位目标模块中，应用程序可以把这个模块链接到可执行文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc min.c /usr/lib/libc.o</span><br></pre></td></tr></table></figure></p>
<p>这种方法优点：将编译器的实现与标准函数实现分离开来，很大缺点是系统中每个可执行文件都包含一份标准函数集合副本，对磁盘空间是很大浪费。另一个缺点：对任何标准函数的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件。</p>
<p>可以通过为每个标准函数创建一个独立的可重定位文件，把它们存放在一个公共目录，要求应用程序显示链接合适的目标模块到可执行文件中，耗时且容易出错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c /usr/lib/printf.o /usr/lib/scanf.o</span><br></pre></td></tr></table></figure></p>
<p>静态库用来解决这些缺点，相关函数被编译为独立目标模块，封装成一个单独静态库文件，应用程序可以通过在命令行上治理领单独的文件名来使用这些在库中定义的函数。</p>
<p>然后进行重定位：</p>
<ul>
<li>重定位条目：汇编器生成一个目标模块时，并不知道数据和代码最终放在内存什么位置，不知道这个模块引用任何外部定义的函数或者全局变量的位置。汇编器遇到对最终位置未知的目标引用，会生成一个<strong>重定位条目。</strong> 告诉链接器在将目标文件合并成可执行文件时如何修改这个引用；</li>
<li>重定位符号引用。1）重定位PC相对引用；2）重定位绝对引用，相对简单；</li>
</ul>
<h5 id="7-3-可执行目标文件"><a href="#7-3-可执行目标文件" class="headerlink" title="7.3 可执行目标文件"></a>7.3 可执行目标文件</h5><p>将ASCII文本文件转化为一个二进制文件，且二进制文件包含加载程序到内存并运行所需的所有信息，包括只读内存段(代码段)、读/写内存段(数据段)、不加载到内存的符号表和调试信息。</p>
<h5 id="7-4-加载可执行目标文件"><a href="#7-4-加载可执行目标文件" class="headerlink" title="7.4 加载可执行目标文件"></a>7.4 加载可执行目标文件</h5><p>比如执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ./start</span><br></pre></td></tr></table></figure></p>
<p>start不是一个内置的shell命令，shell会认为start是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器loader的OS代码来运行它。任何linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序第一条指令或入口点来运行该程序，将程序复制到内存并运行的过程叫加载。</p>
<p>动态链接共享库：静态库缺点需要定期维护和更新，另一个问题是每个c程序都使用标准IO函数，比如pritnf、scanf。运行时将这些函数代码复制到进程的文本段中，是堆内存资源的浪费。</p>
<p>共享库是致力于解决静态库缺陷的一个产物，共享库是一个目标模块，运行加载时，可以加载到任意内存地址，并和一个在内存中的程序链接起来，这个过程称为动态链接。linux中常用.so后缀来表示，windows中的共享库，被称为DLL。内存中一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。</p>
<h5 id="7-5-从应用程序中加载和链接共享库"><a href="#7-5-从应用程序中加载和链接共享库" class="headerlink" title="7.5 从应用程序中加载和链接共享库"></a>7.5 从应用程序中加载和链接共享库</h5><p>应用程序可能在其运行时要求动态链接器加载和链接某个共享库，无需在编译时将那些库链接到应用中。思路是：将每个生成动态内容的函数打包在共享库中，当一个来自web请求到达，服务器动态加载和链接适当函数，直接调用，而不是使用fork和execve在自己进程上下文中运行函数。</p>
<p><strong>共享库和java本地接口</strong><br><br>java定义了一个标准调用规则，叫做java本地接口，允许java调用本地c和c++函数，基本思想是将本地c函数编译到共享库中，当一个正在运行的java程序试图调用函数时，java解释器利用dlopen接口动态链接和加载xx.so，再调用具体函数。</p>
<h5 id="7-6-位置无关代码"><a href="#7-6-位置无关代码" class="headerlink" title="7.6 位置无关代码"></a>7.6 位置无关代码</h5><p>多个进程如何共享程序的一个副本。一种方法给每个共享库分配一个事先预备的专用地址空间片，然后要求加载器在这个低智商加载共享库，会使地址空间使用效率不高，因为一个进程即使不使用这个库，部分空间还是被分配出来，难以管理，必须保证没有片会重叠。当一个库修改了之后，必须确认已分配给它的片还适合它的大小。不适合必须找一个新的片。</p>
<p>要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置无需链接器修改，使用这种方法无限多个进程可以共享一个共享模块的代码的单一副本。可以加载无需定位的代码称为位置无关代码PIC。</p>
<ul>
<li>PIC数据引用。编译器通过：无论在内存何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总保持不变。因此代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置无关。需要引入一个全局偏移量表GOT。</li>
<li>PIC函数调用。假设程序调用一个共享库定义的函数，编译器没办法预测这个函数的运行时地址，因为共享模块可以加载到任意位置。GUN编译系统使用延迟绑定lazy binding，将过程地址绑定推迟到第一次调用该过程时。比如libc.so包含上千个函数，只会使用其中部分，将函数地址解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。</li>
</ul>
<h4 id="8、异常控制流"><a href="#8、异常控制流" class="headerlink" title="8、异常控制流"></a>8、异常控制流</h4><p>系统需要一些机制对由程序变量表示的内部程序状态中的变化做出反应。这些系统状态不是被内部程序变量捕获的，也不一定要和程序的执行相关。比如一个硬件定时器定期产生信号，这个事件必须得到处理；包到达网络适配器后，必须放在内存中；程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。OS通过异常控制流ECF，对这些突变做出反应。</p>
<ul>
<li>ECF是OS实现IO、进程、虚拟内存的基本机制；</li>
<li>ECF可以理解应用程序如何与OS交互；应用程序通过使用trap、系统调用的ECF形式，向OS请求服务；</li>
<li>ECF帮助理解并发。</li>
</ul>
<p>在任何情况下，当处理器检测到有事件发生，就会通过异常表exception table的跳转表，进行一个间接过程调用(异常)到一个专门设计用来处理这类事件的操作系统子程序。异常处理完成后，会进行：</p>
<ul>
<li>处理程序将控制返回给当前指令<code>$I_{curr}$</code></li>
<li>将控制返回给<code>$I_{next}</code>，没有发生异常执行下一条指令</li>
<li>处理程序终止被中断的程序</li>
</ul>
<h6 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h6><p>系统中每种类型的异常都分配了唯一的非负整数的异常号，一些号码由处理器设计者分配(包括被零除、缺页、内存访问违例、断点以及算术运算溢出)，其他号码由OS内核设计者分配(包括系统调用和来自外部I/O设备信号)。</p>
<p>系统启动时OS分配和初始化一张称为异常表的跳转表。运行时，处理器检测到发生一个事件，并且确定相应异常号k。随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应处理程序。异常表起始地址放在异常表基址寄存器的特殊CPU寄存器中。</p>
<p>异常类似于过程调用，有一些不同之处：</p>
<ul>
<li>过程调用，在跳转到处理程序前，处理器将返回地址压入栈中。根据异常类型，返回地址是当前指令或者是下一挑指令。</li>
<li>处理器也把一些额外处理器状态压到栈中，处理程序返回时，重新开始执行被中断的程序。</li>
<li>如果控制从用户程序转移到内核，所有项目都被压到内核栈中，而不是压到用户栈中；</li>
<li>异常处理程序运行在内核模式下，对所有系统资源都有完全访问权限。</li>
</ul>
<p>一旦硬件触发异常，由异常处理程序在软件中完成，处理完成后，通过执行一条特殊“从中断返回”指令，返回到被中断的程序，该指令将适当状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，状态恢复为用户模式。</p>
<p>异常类别：<br>|类别|原因|异步/同步|返回行为|<br>|—|—|—|—|<br>|中断|来自I/O设备信号|异步|返回到下一条指令|<br>|陷阱|有意的异常|同步|返回到下一条指令|<br>|鼓掌|潜在可恢复的错误|同步|可能返回到当前指令|<br>|终止|不可恢复的错误|同步|不会返回|</p>
<ul>
<li>中断：来自处理器外部的I/O设备信号结果，不是由任何一条专门指令造成的。I/O设备，如网络适配器、磁盘控制器、定时器芯片，通过向处理器芯片上一个引脚发信号，并将异常号放到系统总线上，触发中断；当前指令完成执行后，处理器注意到中断引脚电压变高，就从系统总线读取异常号，调用适当的中断处理程序；剩下的叫故障指令。</li>
<li>陷阱和系统调用。陷阱最重要的用途是在用户程序和内核之间提供一个过程一样的接口，叫做系统调用。用户程序经常向内核请求服务，如读文件read、创建新进程fork、加载新程序execve、终止进程exit。</li>
<li>故障。由错误情况引起，能够被故障处理程序修正，故障发生时，处理器将控制转移给故障处理程序。如缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出，就会发生故障。</li>
<li>终止。不可恢复的致命错误，如DRAM或SRAM位被损坏发生的奇偶错误。</li>
</ul>
<h6 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h6><p>异常是允许OS内核提供进程概念的基本构造块，进程也是OS最深刻、最成功概念之一。</p>
<p>系统中每个程序都运行在某个进程上下文中，上下文是由程序正确运行所需状态组成，包括存放在内存中的程序代码和数据，它的栈、通用目的寄存器的内容、PC、环境变量以及打开文件描述符的集合。</p>
<p>进程提供给应用程序的抽象：</p>
<ul>
<li>一个独立逻辑控制流，好像是独占的使用处理器；</li>
<li>一个私有地址空间，好像是独占使用内存系统。</li>
</ul>
<p>处理器通常是用某个控制寄存器中的一个模式位来提供用户态/内核态功能。设置了模式位，进程就运行在内核模式中。linux提供一种聪明的机制，叫做/proc文件系统，允许用户模式进程访问内核数据结构内容，比如cpu类型/proc/cpuinfo，某个特殊进程使用的内存段/proc/{pid}/maps。</p>
<h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><p>OS内核使用一种称为上下文切换的较高层形式的异常控制流实现多任务。内核为每个进程维护一个上下文，包括通用目的寄存器、浮点寄存器、PC、用户栈、状态寄存器、内核栈、各种内核数据结构(地址空间页表、进程表、打开文件的信息文件表)</p>
<p>执行系统调用（read）、sleep系统调用、中断都有可能引发系统调用</p>
<h6 id="8-3-进程控制"><a href="#8-3-进程控制" class="headerlink" title="8.3 进程控制"></a>8.3 进程控制</h6><p>父进程通过fork函数创建一个新的运行的子进程，子进程得到父进程用户级虚拟地址空间相同的一份副本，包括代码、数据段、堆、共享库以及用户栈、相同文件描述符副本。意味着子进程可以读写父进程中打开的任何文件。fork调用一次返回两次，在调用进程(父进程)返回子进程pid，在子进程返回o。</p>
<p>父进程和子进程相同但是独立的地址空间，每个进程都有相同用户栈、本地变量值、堆、全局变量值、相同的代码。但是都有各自私有的地址空间。</p>
<h6 id="8-3-2-回收子进程"><a href="#8-3-2-回收子进程" class="headerlink" title="8.3.2 回收子进程"></a>8.3.2 回收子进程</h6><p>一个进程由于某种原因终止，内核不是立即把它从系统清楚，而是保持一种已终止的状态，直到被父进程回收。当父进程回收已终止的子进程，内核将子进程的退出状态传递给父进程，抛弃已终止的进程。一个终止但未被回收的进程称为僵死进程。</p>
<p>如果父进程终止，内核会安排init进程称为孤儿进程的养父，init进程pid为1，系统启动时由内核创建的，不会终止，是所有进程祖先。如果父进程没有回收它的僵死子进程就终止了，内核会安排init进程去回收。</p>
<h6 id="8-3-3-让进程休眠"><a href="#8-3-3-让进程休眠" class="headerlink" title="8.3.3 让进程休眠"></a>8.3.3 让进程休眠</h6><p>sleep让一个进程挂起一段指定时间，sleep返回0，或者剩下要休眠的时间。</p>
<p>加载并运行程序：<br>execve函数加载并运行可执行目标文件filename。</p>
<p><strong>程序与进程</strong><br><br>程序是一堆代码和数据，可作为目标文件存于磁盘上，或者作为段存在地址空间中。进程是执行程序的一个具体实例，程序总是运行在某个进程上下文中。fork函数是在新的子进程中运行相同的程序，新的子进程是父进程一个复制品，execve是在当前进程上下文加载并运行一个新的程序，它会覆盖当前进程的地址空间，但没有创建新的进程。</p>
<h6 id="8-4-信号"><a href="#8-4-信号" class="headerlink" title="8.4 信号"></a>8.4 信号</h6><p>OS通过异常控制流来支持进程上下文切换，还有一种linux信号，允许进程和内核中断其他进程。</p>
<p>发送一个信号到目的进程由两个不同步骤组成：</p>
<ul>
<li>发送信号。内核通过更新目的进程上下文某个状态，发送一个信号给目的进程。发送信号可以有如下两种原因：1）内核检测到一个系统事件，如除零错误、子进程终止；2）一个进程调用kill函数</li>
<li>接收信号。目的进程被内核强迫以某种方式对信号的发送做出反应，它就接收了信号，进程可以忽略这个信号、终止或通过执行一个称为信号处理程序的用户层函数捕获这个信号。</li>
</ul>
<p>一个发出而没被接收的信号叫做待处理信号，一种类型至多有一个待处理信号，如果一个进程有一个类型为k的待处理信号，接下来发送到这个进程的类型为k的信号都不会排队等待，直接丢弃。</p>
<p>一个待处理信号最多只能被接收一次，内核为每个进程在pending位向量中维护着待处理信号集合，在blocked位向量维护着被阻塞的信号集合。只要传送一个类型为k的信号，内核就会设置pending中第k位，而只要接收了一个类型为k的信号，内核就会清楚pending中第k位。</p>
<p>每个进程都属于一个进程组，子进程和父进程属于同一个进程组；kill向另外进程发送信号；shell使用作业这个抽象概念对一条命令行求值而创建的进程，任何时刻至多只有一个前台作业和多个后台作业。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ls | sort</span><br></pre></td></tr></table></figure></p>
<p>会创建一个由两个进程组成的前台作业，两个后台进程组；这两个进程通过unix管道连接起来，一个ls程序，一个sort程序，shell为每个作业创建一个独立的进程组，进程组ID取父进程中的一个。</p>
<p>键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组每个进程，默认情况终止前台作业；输入Ctrl+Z会发送SIGTSTP信号到前台进程组每个进程，结果是停止(挂起)前台作业。</p>
<p>接收信号：当把进程p从内核模式切换到用户模式(如从系统调用返回或是完成了一次上下文切换)，会检查进程p的未被阻塞的待处理信号的结合，</p>
<h6 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h6><p>c提供一种用户级别异常控制流形式，称为非本地跳转，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列，非本地跳转通过setjmp和longjmp函数提供。非本地跳转一个重要应用是允许从一个深层嵌套的函数调用立即返回，通常是由检测到某个错误引起的。</p>
<p>Linux提供大量的监控和操作进程的有用工具：</p>
<ul>
<li>STRACE，打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹；</li>
<li>PS列出当前系统中的进程</li>
<li>TOP：打印关于当前进程资源使用信息</li>
<li>PMAP：显示进程内存映射</li>
</ul>
<h5 id="9、虚拟内存"><a href="#9、虚拟内存" class="headerlink" title="9、虚拟内存"></a>9、虚拟内存</h5><p>虚拟内存VM是硬件异常、硬件地址翻译、主存、磁盘文件和内核文件的完美交互，为每个进程提供了一个大的、一致的、私有的地址空间。</p>
<ul>
<li>将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，根据需要在磁盘和主存之间来回传送数据，通过这种方式，高效使用主存；</li>
<li>为每个进程提供一致的地址空间，简化内存管理；</li>
<li>保护每个进程的地址空间不被其他进程破坏</li>
</ul>
<p>使用虚拟寻址，CPU通过生成一个虚拟地址Virtual Address来访问主存，这个VA被送到主存前先转换成适当物理地址，将一个VA转换成物理地址的任务叫做地址翻译address translation。地址翻译需要CPU硬件和OS合作，CPU芯片上叫做内存管理单元MMU的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。</p>
<p><strong>虚拟内存空间被组织为一个存放在磁盘上的M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引</strong></p>
<h5 id="9-1-VM作为缓存工具"><a href="#9-1-VM作为缓存工具" class="headerlink" title="9.1 VM作为缓存工具"></a>9.1 VM作为缓存工具</h5><p>主存每个字节都有一个选自虚拟地址空间的虚拟地址和一个物理地址空间的物理地址；</p>
<p>磁盘上的内容缓存在主存中，磁盘上的数据被分割成块，作为磁盘和主存之间传输单元。VM将虚拟内存分割为虚拟页virtual page的大小固定块来处理这个问题。每个虚拟页VP大小为<code>$P=2^p$</code>字节。物理内存被分割为物理页PP，大小也为P字节，被称为页帧page frame。</p>
<p>任意时刻，虚拟页面集合分成三个不相交子集：</p>
<ul>
<li>未分配的：VM系统还未分配的页，未分配的块没有任何数据和它们相关联，不占用任何磁盘空间；</li>
<li>缓存的：当前已缓存在物理内存中的已分配页；</li>
<li>为缓存的：未缓存在无力内存中的已分配页；</li>
</ul>
<h6 id="9-1-1-DRAM缓存组织结构"><a href="#9-1-1-DRAM缓存组织结构" class="headerlink" title="9.1.1 DRAM缓存组织结构"></a>9.1.1 DRAM缓存组织结构</h6><p>SRAM缓存表示CPU和主存之间的L1、L2和L3高速缓存，用DRAM缓存表示虚拟内存系统的缓存，在主存中缓存虚拟页。DRAM比SRAM慢10倍，磁盘比DRAM慢大约慢10 0000倍。DRAM缓存不命中比SRAM缓存不命中更昂贵。</p>
<p><strong>因为大的不命中处罚和访问第一个字节开销，虚拟页往往很大，通常是4KB~2MB。由于大的不命中处罚，DRAM缓存是全相联的，任何虚拟页都可以放置在任何物理页中。不命中的替换策略也很重要，替换错了虚拟页的处罚也非常高，因此，与硬件对SRAM缓存，OS对DRAM缓存使用了更复杂精密的替换算法。因为对磁盘访问时间很长，DRAM缓存总是使用写回，而不是直写。</strong></p>
<h6 id="9-1-2-页表"><a href="#9-1-2-页表" class="headerlink" title="9.1.2 页表"></a>9.1.2 页表</h6><p>同任何缓存一样，VM必须有某种方法判定一个虚拟页是否缓存在DRAM某个地方，如果是还需要确定这个虚拟页在哪个物理页中，如果不命中，判断虚拟页存放在磁盘哪个位置，在物理内存中选择牺牲一页，将虚拟页从磁盘复制到DRAM，替换这个牺牲页。</p>
<p>这些功能是由软硬件联合提供的，包括OS软件、MMU内存管理单元中的地址翻译硬件和一个存放在物理内存的页表，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。OS负责维护页表内容，以及在磁盘与DRAM之间来回传送页。</p>
<p>页表就是一个页表条目(PTE)Page Table Entry的数组，虚拟地址空间中每个页在页表中一个固定偏移量处都有一个PTE。</p>
<p>DRAM缓存不命中称为缺页page fault，假如CPU引用了VP3中一个字，但是并未缓存在DRAM中，地址翻译硬件从内存读取PTE3，推断VP3未被缓存，并且触发一个缺页异常。缺页异常会调用缺页异常处理程序，该程序会选择一个牺牲页，(存放存放PP3的VP4)，如果VP4已经被修改，内核就会将其复制回磁盘。无论哪种情况，内核都会修改VP4的页表条目，表明VP4不再缓存在主存中。</p>
<p>接下来，内核从磁盘复制VP3到内存中的PP3，更新PTE3.随后返回，当异常处理程序返回时，会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是VP3已经缓存在主存中，页命中也能由地址翻译硬件正常处理了。</p>
<p>虚拟内存和SRAM缓存有很多相似的概念但是使用了不同术语，虚拟内存中，块被称为页，磁盘和内存之间传送页的活动叫做交换swapping或者页面调度。页从磁盘换入DRAM、从DRAM换出磁盘，当有不命中发生时，才换入页面的这种策略称为按需页面调度。</p>
<p><strong>虚拟页和磁盘文件映射，然后缓存到物理页。</strong></p>
<h6 id="9-1-3-分配页面"><a href="#9-1-3-分配页面" class="headerlink" title="9.1.3 分配页面"></a>9.1.3 分配页面</h6><p>当OS分配一个新的虚拟内存页，如调用malloc的结果，VP5的分配过程是在磁盘上创建空间并更新PTE5，使它指向磁盘上这个新创建的页面。</p>
<h6 id="9-1-4-局部性"><a href="#9-1-4-局部性" class="headerlink" title="9.1.4 局部性"></a>9.1.4 局部性</h6><p>尽管在整个运行过程中程序引用不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了任意时刻，程序将趋于在一个较小的活动页面集合上工作，这个集合叫工作集working set或者常驻集合。在初始开销，将工作集调度到内存后，接下来对这个工作集的引用将导致命中，不会产生额外磁盘流量。</p>
<p>只要程序有良好局部性，虚拟内存就能工作的很好。如果工作集大小超出了物理内存大小，程序就会产生抖动，这时页面不断地换进换出。</p>
<h6 id="9-1-5-虚拟内存作为内存管理工具"><a href="#9-1-5-虚拟内存作为内存管理工具" class="headerlink" title="9.1.5 虚拟内存作为内存管理工具"></a>9.1.5 虚拟内存作为内存管理工具</h6><p>OS为每个进程提供一个独立的页表，即一个独立的虚拟地址空间。比如进程i的页表将VP1映射到PP2，VP2映射到PP7。进程j的页表将VP1映射到PP7，VP2映射到PP10，多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p>VM简化了链接、加载、代码和数据共享，以及应用程序的内存分配：</p>
<ul>
<li>简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，不管代码和数据实际存放在物理内存何处。一个linux系统上每个进程都使用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址0x400000开始，数据段跟在代码段后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高部分，向下生长。这样的一致性极大简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中的代码、数据的最终位置；</li>
<li>简化加载。VM使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中的.text和.data加载到一个新创建的进程，Linux加载器为代码和数据段分配虚拟页，把它们标记为无效的(未被缓存的),将页表条目指向目标文件适当位置。<strong>但是加载器不从磁盘复制数据到内存。在每个页初次被引用时，要么是CPU取指令时引用的、或是一条正在执行的指令引用一个内存位置时引用的，VM会按照需要自动调入数据页。</strong><br>将一组连续虚拟页映射到任意一个文件中的任意位置表示的方法称作内存映射memory mapping。linux提供一个mmap的系统调用，允许应用程序自己做内存映射。</li>
<li>简化共享。独立地址空间为OS提供一个管理用户进程和OS自身之间共享的一致机制。一般情况下，每个进程都有自己私有的代码、数据、堆以及栈区，是不和其他进程共享的。这种情况，OS创建页表，将相应虚拟页映射到不连续的物理页面。</li>
</ul>
<p><strong>一些情况下需要进程共享代码和数据，如每个进程需调用相同OS内核代码(printf)。OS将不同进程中相应的虚拟页面映射到相同物理页面，从而多个进程共享这部分代码的一个副本。</strong></p>
<ul>
<li>简化内存分配。VM向用户进程提供一个简单的分配额外内存的机制，当一个运行在用户进程中的程序要求额外的堆空间，OS分配一个适当数字(k)个连续虚拟内存页面，将它们映射到物理内存中任意位置的k个任意的物理页面。由于页表工作方式，OS没有必要分配k个连续的物理内存页面，页面可以随机分散在物理内存中。</li>
</ul>
<h5 id="9-2-虚拟内存作为保护工具"><a href="#9-2-虚拟内存作为保护工具" class="headerlink" title="9.2 虚拟内存作为保护工具"></a>9.2 虚拟内存作为保护工具</h5><p>不允许用户进程修改只读代码段，不允许读或修改任何内核中的代码和数据结构，不允许读其他进程私有内存，不允许修改与其他进程共享的虚拟页面。</p>
<p>提供独立的地址空间使得区分不同进程的私有内存变的容易。但是地址翻译机制以一种自然的方式扩展到提供更好的访问控制，<strong>每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，通过在PTE添加一些额外的许可位来控制对一个虚拟页内容的访问。</strong> 比如PTE添加三个许可位，SUP位表示是否只能在内核模式访问，READ和WRITE控制对页面的读和写访问。如果一条指令违反这些许可条件，CPU会触发一个一般保护故障，将控制传给内核异常处理程序，段错误segmentation fault。</p>
<h5 id="9-3-地址翻译"><a href="#9-3-地址翻译" class="headerlink" title="9.3 地址翻译"></a>9.3 地址翻译</h5><p>MMU利用页表实现虚拟内存映射，CPU中一个控制寄存器-页表基址寄存器PageTableBaseRegister指向当前页表，n位的虚拟地址包含两部分，一个p位的虚拟页面偏移VPOffset和一个n-p位的虚拟页号virtual page number。MMU利用VPN选择适当PTE。当页面命中时，CPU执行步骤：</p>
<ul>
<li>处理器生成一个虚拟地址，传送给MMU</li>
<li>MMU生成PTE地址，从高速缓存/缓存请求得到；</li>
<li>高速缓存/主存向MMU返回PTE</li>
<li>MMU构造物理地址，并把它传送给告诉缓存/主存</li>
<li>高速缓存/主存返回所请求的数据字给处理器</li>
</ul>
<p>页面命中完全由硬件处理，处理缺页要求硬件和OS内核协作完成：</p>
<ul>
<li>1-3步与上述相同</li>
<li>PET中有效位是0，MMU触发异常，传递CPU中的控制到OS内核中的缺页异常处理程序；</li>
<li>缺页处理程序确定出物理内存中的牺牲页，如果这个页被修改了，换出到磁盘；</li>
<li>缺页处理程序页面调入新的页面，并更新内存中的PTE</li>
<li>缺页处理程序返回到原来进程，再次执行导致缺页的指令，CPU将引起缺页的虚拟地址重新发给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。</li>
</ul>
<h6 id="9-3-1-结合高速缓存和虚拟内存"><a href="#9-3-1-结合高速缓存和虚拟内存" class="headerlink" title="9.3.1 结合高速缓存和虚拟内存"></a>9.3.1 结合高速缓存和虚拟内存</h6><p>在使用虚拟内存和SRAM的系统中，存在使用虚拟地址还是物理地址访问SRAM的问题，大多数会使用物理寻址。使用物理寻址，多个进程同时在cache中有存储块和共享来自相同虚拟页面的块是很简单的，cache无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</p>
<p><strong>假如CPU执行两道不同进程，进程的指令访问都是基于虚拟地址的，可能出现：进程A在被执行一段时间后，由于进程调度，被切换出去，需要执行进程B，而进程A的PCA(进程A的取地址指针)所指向的一段代码在cache中，而进程B的PCB由于是虚拟地址概念，有可能PCA=PCB(经过虚实地址转换后，物理PCB不会等于PCA)，如果在cache中利用PCB访问PCA，则会导致cache hit。为了解决这个问题，就采用物理地址访问cache，需要将地址进行一次转换</strong></p>
<p>用虚拟地址访问cache：</p>
<ul>
<li>如果两段进程虚拟PC正好相同，会出现虚地址访问cache冲突；</li>
<li>安全保护方法基于进程描述符ID，体现到了内存页表上，因此OS保护依赖于页表的安全，如果cache直接用虚拟地址访问，就绕过了页表机制，从而使用流水线中指令的执行不再存在保护；</li>
<li>OS允许多个虚拟页面映射到同一个物理地址页面空间，如果纯粹是虚拟地址访问，可能出现读写不一致情况；</li>
<li>读写外部设备问题：现在外部IO设备的地址映射一般是物理地址映射，TLB可以把虚拟地址映射为物理地址，但是在读写外部IO设备时，没有机制把物理地址映射为虚拟地址；</li>
</ul>
<p>虚拟地址访问cache，物理地址比较tag，利用了页表的虚拟地址和物理地址在低位是相同的，不同的是高位映射，物理地址映射：</p>
<ul>
<li>利用虚拟地址访问TLB，进行虚实地址转换，假设TLB命中，需要一个时钟周期；</li>
<li>利用得到的物理地址访问cache，取出cache行的tag信息和data信息；假设命中需要一个时钟周期；</li>
<li>基于物理地址，对TAG信息进行比较选择合适cache data。</li>
</ul>
<p>虚实结合方式：</p>
<ul>
<li>利用虚拟地址访问TLB，虚实地址转换，在这个周期中，利用虚拟地址低位访问cache，取出cache中存储的tag信息和data信息，这个时候tag信息其实对应的是物理地址的tag；</li>
<li>假设TLB和cache都命中，利用上个节拍得到的物理地址进行tag比较，选择合适cache和data数据。</li>
</ul>
<p>主要思路是在地址翻译发生在高速缓存查找之前，页表条目可以缓存：<br><img src="https://note.youdao.com/yws/public/resource/9acf20157b8185176248dd461973ffe0/xmlnote/00ADDEA3642648D7BC31884F4A1D418F/29951" alt="image"></p>
<h6 id="9-3-2-利用TLB加速地址翻译"><a href="#9-3-2-利用TLB加速地址翻译" class="headerlink" title="9.3.2 利用TLB加速地址翻译"></a>9.3.2 利用TLB加速地址翻译</h6><p>每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。最坏情况要求从内存多取一次数据，代价是几百个周期。如果PTE碰巧缓存在L1中，开销就会下降到1或2个周期。在MMU中包括一个关于PTE的小的缓存，称为翻译后备缓冲器TLB。每一行都保存着一个由单个PTE组成的块，通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址的虚拟页号提取出来的，如果TLB有<code>$T=2^t$</code>个组，那么TLB索引是由VPN的t个最低位组成的，而TLB标记是由VPN剩余位组成的。<br>当TLB命中：</p>
<ul>
<li>CPU产生一个虚拟地址</li>
<li>MMU从TLB取出相应PTE</li>
<li>MMU将这个虚拟地址翻译成一个物理地址，发送到cache/memory</li>
<li>cache/memory将所请求的数据字返回给CPU</li>
</ul>
<p>TLB不命中时，MMU必须从L1缓存取出相应PTE，新取出的PTE存放在TLB中，可能会覆盖一个已存在的条目。</p>
<h6 id="9-3-3-多级页表"><a href="#9-3-3-多级页表" class="headerlink" title="9.3.3 多级页表"></a>9.3.3 多级页表</h6><p>用来压缩页表常用方法是使用层次结构的页表；多级页表从两个方面减少了内存要求：</p>
<ul>
<li>如果一级页表中一个PTE是空的，相应的二级页表根本不会存在，存在很大节约，因为大部分虚拟地址空间是未分配的；</li>
<li>只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建、页面调入或调出二级页表，减少了主存压力，只有最经常使用的二级页表才需要缓存在主存中。</li>
</ul>
<h5 id="9-4-Intel-Core-Linux内存系统"><a href="#9-4-Intel-Core-Linux内存系统" class="headerlink" title="9.4 Intel Core/Linux内存系统"></a>9.4 Intel Core/Linux内存系统</h5><p>处理器封装包括四个核、一个大的所有核共享的L3高速缓存以及一个DDR3内存控制器。每个核包含一个层次结构的TLB、一个层次结构的数据和指令高速缓存，以及一组快速的点到点链路，这个链路基于QuickPath技术，为了让一个核与其他核与外部I/O桥直接通信。TLB是虚拟寻址、四路组相联，L1、L2、L3是物理寻址的，块大小为64字节。L1和L2是8路组相联的，L3是16路组相联，页大小可以在启动时被配置为4KB或4MB,linux使用4KB的页，使用4级页表，每个进程有自己私有的页表层次结构，当一个linux进程在运行时，允许页表换进换出，但是与已分配的页相关联的页表都是驻留在内存中的。</p>
<h6 id="优化地址翻译"><a href="#优化地址翻译" class="headerlink" title="优化地址翻译"></a>优化地址翻译</h6><p>地址翻译有两个步骤：1）MMU将虚拟地址翻译成物理地址2）将物理地址传送到L1高速缓存。 硬件实际上允许这些步骤部分重叠，加速了对L1高速缓存的访问。比如页大小为4KB的系统上有12位的VPO，并且这些位和相应物理地址的PPO12位是相同的。因为八路组相联、物理寻址的L1有64个组和大小为64字节的缓存块，每个物理地址有6个缓存偏移位<code>$log_2^{64}$</code>和6个索引位，这12位恰好是虚拟地址VPO部分，这不是偶然。当CPU需要翻译一个虚拟地址，发送VPN到MMU，发送VPO到L1，当MMU向TLB请求一个页表条目时，L1利用VPO查找相应的组，读出这个组里8个标记和相应数据字，MMU从TLB得到PPN时，缓存已经准备好试着把这个PPN与这8个标记进行匹配了。</p>
<h6 id="9-4-2-Linux虚拟内存系统"><a href="#9-4-2-Linux虚拟内存系统" class="headerlink" title="9.4.2 Linux虚拟内存系统"></a>9.4.2 Linux虚拟内存系统</h6><p>linux为每个进程维护一个单独虚拟地址空间，内核虚拟内存包含内核的代码和数据结构，内核虚拟内存某些区域被映射到所有进程共享的物理页面。Linux也将一组连续的虚拟页面映射到相应的一组连续的物理页面，为内核提供便利的方法来访问物理内存中特定位置，例如当需要访问页表或一些设备上执行内存映射的I/O操作，而这些设备被映射到特定的物理内存位置。</p>
<p>内核虚拟内存其他区域包含每个进程都不相同的数据，比如页表、内核在进程的上下文中执行代码使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p>
<p>linux将VM组织成一些段的集合，一个段就是已经存在着的虚拟内存的连续片，这些页以某种方式相关联的，例如代码段、数据段、堆、共享库段，以及用户栈都是不同区域。</p>
<h5 id="9-5-内存映射"><a href="#9-5-内存映射" class="headerlink" title="9.5 内存映射"></a>9.5 内存映射</h5><p>linux将一个虚拟内存区域与一个磁盘上的对象关联起来，初始化这个虚拟内存区域的内容，这个过程就是内存映射memory mapping。虚拟内存可以映射到两种类型对象：</p>
<ul>
<li>Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件连续部分，例如一个可执行目标文件。文件区section被分成页大小的片，每一片都包含一个虚拟页面初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用页面(即发射一个虚拟地址)，如果区域比文件大，用零填充余下部分。</li>
<li>匿名文件。一个区域也可以映射到一个匿名文件，由内核创建，包含的全是二进制0。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中。在磁盘和内存间并没有实际的数据传送，因此映射到匿名文件的区域中的页面有时也叫请求二进制的页demand-zero page</li>
</ul>
<p>无论哪种情况，一旦一个虚拟页面被初始化了，就在一个由内核维护的专门的交换文件之间换来换去，交换文件也叫做交换空间swap space。任何时刻，<strong>交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</strong></p>
<h6 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h6><p>一个对象可以被映射到虚拟内存一个区域，作为共享对象或者私有对象。共享对象被映射到多个共享区域，物理内存只需要存放共享对象一个副本；私有对象使用一种叫做写时复制copy-on-write的技术映射到虚拟内存中。</p>
<h6 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h6><p>fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给新进程创建虚拟内存创建了当前进程的mm_struct、区域结构和页表原样副本，将两个进程中每个页表标记为只读，并将两个进程中两个区域结构都标记为私有的写时复制。当fork函数在新进程中返回时，新进程现在的VM刚好和调用fork时存在的VM内存相同，当两个进程中任一个后来进行写操作时，写时复制就会创建新页面，因此为每个进程保持了私有地址空间的抽象概念。</p>
<h6 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h6><p>虚拟内存和内存映射将程序加载到内存的过程中扮演很关键的角色。假如调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;a.out&quot;,null,null)</span><br></pre></td></tr></table></figure></p>
<p>execve函数在当前进程中加载并运行包含可执行文件的目标文件a.out中的程序，包括以下几个步骤：</p>
<ul>
<li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分的已存在的区域结构；</li>
<li>映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新区域都是私有的、写时复制的。代码和数据区域被映射到a.out文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为0.</li>
<li>映射共享区域。如果a.out与共享对象链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到虚拟地址空间中的共享区域内。</li>
<li>设置程序计数器PC。execve做的最后一件事就是设置当前进程上下文中的PC，使之指向代码区域入口点。</li>
</ul>
<p>下一次调度这个进程，将从这个入口点开始执行。</p>
<h6 id="使用mmap函数的用户级内存映射"><a href="#使用mmap函数的用户级内存映射" class="headerlink" title="使用mmap函数的用户级内存映射"></a>使用mmap函数的用户级内存映射</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(vaoid *start,size_t length,int prot,int flags,int df,off_t offset)</span><br></pre></td></tr></table></figure>
<p>mmap函数要求内核创建一个新的虚拟内存区域，最好是从start开始的一个区域，并将文件描述符fd指定的对象的一个连续的片chunk映射到这个新的区域。连续的对象片大小文length字节，从距文件开始处偏移量为offset字节的地方开始。start地址仅仅是个暗示，通常被定义为null。</p>
<p>prot包含描述新映射的虚拟内存区域的访问权限位。flags由描述被映射对象类型的位组成，如果设置了MAP_ANON标记位，被映射的对象就是一个匿名对象，相应虚拟页是请求二进制的。MAP_PRIVATE表示被映射的对象是一个私有的、写时复制对象，MAP_SHARED表示是一个共享对象。munmap删除虚拟内存的区域。</p>
<h5 id="9-6-动态内存分配"><a href="#9-6-动态内存分配" class="headerlink" title="9.6 动态内存分配"></a>9.6 动态内存分配</h5><p>虽然可以使用mmap和munmap函数创建、删除虚拟内存区域，但是动态内存分配dynamic memory allocator更方便，也具有更好移植性。</p>
<p>动态内存分配器维护着进程虚拟内存区域的堆heap。它紧接着在未初始化的数据区域开始，向上生长(向更高的地址)，对于每个进程，内核维护着一个变量brk，指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片chunk，要么是已分配的、要么是空闲的。已分配的块保持已分配状态，直到它被释放，这种释放是程序显示执行、或者是内存分配器隐式执行。</p>
<ul>
<li>显示分配器。通过malloc和free管理内存；</li>
<li>隐式分配器。也叫做垃圾回收。</li>
</ul>
<p>malloc通过使用mmap和munmap函数，显示分配和释放堆内存，还可以使用sbrk函数，通过将内核的brk指针增加incr来扩展和收缩堆。</p>
<h6 id="为什么要使用动态内存分配"><a href="#为什么要使用动态内存分配" class="headerlink" title="为什么要使用动态内存分配"></a>为什么要使用动态内存分配</h6><p>谋者程序直到运行时才知道某些数据结构大小。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">hecy</p>
              <p class="site-description motion-element" itemprop="description">a dreamer</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hecy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
